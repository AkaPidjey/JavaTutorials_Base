[Java Tutorials](README.md)

# JavaLanguages
1) [Какая основная идея языка?](#Какая-основная-идея-языка)
2) [За счет чего обеспечивается кроссплатформенность?](#За-счет-чего-обеспечивается-кроссплатформенность)
3) [Какие преимущества у java?](#Какие-преимущества-у-java)
4) [Какие недостатки у Java?](#Какие-недостатки-у-Java)
5) [Что такое JDK? Что в него входит?](#Что-такое-JDK-Что-в-него-входит)
6) [Что такое JRE? что в него входит?](#Что-такое-JRE-что-в-него-входит)
7) [Что такое JVM?](#Что-такое-JVM)
8) [Что такое byte code?](#Что-такое-byte-code)
9) [Что такое загрузчик классов (classloader)?](#Что-такое-загрузчик-классов-classloader)
10) [Что такое JIT?](#Что-такое-JIT)
11) [Что такое Heap и Stack память в Java? Чем они отличаются?](#Что-такое-Heap-и-Stack-память-в-Java-Чем-они-отличаются)
12) [Виды ссылок в Java](#Виды-ссылок-в-Java)
13) [Что такое сборщик мусора? (Garbage collector)](#Что-такое-сборщик-мусора-Garbage-collector)
14) [Как работает сборщик мусора?](#Как-работает-сборщик-мусора)
15) [Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?](#Какие-разновидности-сборщиков-мусора-реализованы-в-виртуальной-машине-hotspot)
16) [Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.](#Опишите-алгоритм-работы-какого-нибудь-сборщика-мусора-реализованного-в-виртуальной-машине-hotspot)
17) [Что произойдет со сборщиком мусора, если выполнение метода `finalize()` требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?](#Что-произойдет-со-сборщиком-мусора-если-выполнение-метода-finalize-требует-ощутимо-много-времени-или-в-процессе-выполнения-будет-выброшено-исключение)
18) [Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?](#Верно-ли-утверждение-что-примитивные-типы-данных-всегда-хранятся-в-стеке-а-экземпляры-ссылочных-типов-данных-в-куче)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)
[к оглавлению](#javaLanguages)


## Какая основная идея языка?
«Написано однажды - работает везде».
Идея основывается в написании одного кода, который будет работать на любой платформе.
+ [Вопрос#1  К оглавлению](#javaLanguages)

## За счет чего обеспечивается кроссплатформенность?
Кроссплатформенность была достигнута за счёт создания виртуальной машины Java. `Java Virtual Machine` или `JVM` - это программа, являющаяся прослойкой между операционной системой и Java программой. В среде виртуальной машины выполняются коды Java программ. Сама `JVM` реализована для разных ОС.
+ [Вопрос#2  К оглавлению](#javaLanguages)

## Какие преимущества у java?
__1) Объектно-ориентированное программирование__   
+ структура данных становится объектом, которым можно управлять для создания отношений между различными объектами.

__2) Язык высокого уровня с простым синтаксисом и плавной кривой обучения__ 
+ синтаксис Java основан на C++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов.

__3) Стандарт для корпоративных вычислительных систем__
+ корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.

__4) Безопасность__ 
+ благодарю отсутсвию указателей и `Security Manager` (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в "песочнице").

__5) Независимость от платформы__ 
+ Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (`JVM`). Таким образом, `JVM` служит уровнем абстракции между кодом и оборудованием.

__6) Язык для распределенного программирования и комфортной удаленной совместной работы__
+ Специфическая для Java методология распределенных вычислений называется `Remote Method Invocation (RMI)`. `RMI` позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.

__7) Автоматическое управление памятью__
+ Разработчикам Java не нужно вручную писать код для управления памятью благодаря 
автоматическому управлению памятью (`AMM`).

__8) Многопоточность__
+ Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.

__9) Стабильность и сообщество__
+ Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 используют Java.
+ [Вопрос#3  К оглавлению](#javaLanguages)

## Какие недостатки у Java?
__1) Платное коммерческое использование (с 2019)__

__2) Низкая производительность__
+ из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.

__3) Не развитые инструменты по созданию GUI приложений на чистой java.__

__4) Многословный код__
+ Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.
+ [Вопрос#4  К оглавлению](#javaLanguages)

## Что такое JDK? Что в него входит?
__JDK (Java Development Kit) - включает `JRE` и набор инструментов разработчика приложений на языке Java:__
- компилятор Java (javac)
- стандартные библиотеки классов java
- примеры
- документацию
- различные утилиты

+ [Вопрос#5  К оглавлению](#javaLanguages)

## Что такое JRE? что в него входит?
__JRE (java Runtime Environment)__ - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из `JVM`, `ClassLoader` и стандартного набора библиотек и классов Java
+ [Вопрос#6  К оглавлению](#javaLanguages)

## Что такое JVM?
__JVM (Java Virtual Machine)__ - виртуальная машина Java исполняет байт-код Java, предварительно созданный из кода `JIT компилятором`, с помощью встроенного интерпретатора байткода.
`HotSpot` представляет собой реализацию концепции `JVM`.
+ [Вопрос#7  К оглавлению](#javaLanguages)

## Что такое byte code?	
Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый `JVM`.
+ [Вопрос#8  К оглавлению](#javaLanguages)

## Что такое загрузчик классов (classloader)?
Используется для передачи в `JVM` скомпилированного байт-кода, хранится в файлах с расширением `.class`

__При запуске `JVM`, используются три загрузчика классов:__

__1) Bootstrap ClassLoader__ - базовый загрузчик
- загружает платформенные классы JDK из архива `rt.jar`

__2) AppClassLoader__ - системный загрузчик
- загружает классы приложения, определенные в `CLASSPATH` 

__3) Extension ClassLoader__ - загрузчик расширений 
- загружает классы расширений, которые по умолчанию находятся в каталоге `jre/lib/ext`.

__ClassLoader выполняет три основных действия в строгом порядке:__

__1) Загрузка:__ находит и импортирует двоичные данные для типа.

__2) Связывание:__ выполняет проверку, подготовку и (необязательно) разрешение.
+ Проверка: обеспечивает правильность импортируемого типа.
+ Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
+ Разрешение: преобразует символические ссылки из типа в прямые ссылки.

__3) Инициализация:__ вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.

Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать
+ [Вопрос#9  К оглавлению](#javaLanguages)

## Что такое JIT?
JIT (Just-in-time compilation) - компиляция на лету или динамическая компиляция - технология увеличения производительности программных систем, использующих байт-код, путем компиляции байт-кода в машинный код во время работы программы.
+ [Вопрос#10  К оглавлению](#javaLanguages)

## Что такое Heap и Stack память в Java? Чем они отличаются?
__Память процесса делится на `Stack(стек)` и `Heap(куча)` :__
- `Stack` содержит `staсk frame'ы`, они делятся на три части: параметры метода, указатель на предыдущий фрейм и локальные переменные.
- Структура `Heap` зависит от выбранного сборщика мусора. Читай про GC!

`MetaSpace` - специальное пространство кучи, отделенное от кучи основной памяти. `JVM` хранит здесь весь статический контент. Это включает в себя все статические методы, примитивные переменные и ссылки на статические объекты. Кроме того, он содержит данные о байт-коде, именах и `JIT-информации` . До Java 7 `String Pool` также был частью этой памяти. 

С помощью опций `Xms` и `Xmx` можно настроить начальный и максимально допустимый размер кучи соответственно. Существуют опции для настройки величины стека.
- `Heap` - используется всем приложением, `Stack` - одним потоком исполняемой программы.
- Новый обьект создается в `heap`, в `stack` размещается ссылка на него. В стеке размещаются локальные переменные примитивных типов. 
- Обьекты в куче доступны из любого места программы, стековая память не доступна для других потоков.
- Если память стека закончилась `JRE` вызовет исключение `StackOverflowError`, если куча заполнена `OutOfMemoryError`
- Размер памяти стека, меньше памяти кучи. Стековая память быстрее памяти кучи.
- В куче есть ссылки между объектами и их классами. На этом основана рефлексия.

Обе области хранятся в RAM.
+ [Вопрос#11  К оглавлению](#javaLanguages)

## Виды ссылок в Java

__1) StrongReference__ — это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.
        StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder.
        
__2) SoftReference__ —  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит `OutOfMemoryError`. `SoftReference` это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.
        StringBuilder builder = new StringBuilder();
        SoftReference<StringBuilder> softBuilder = new SoftReference(builder);

softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется null.
softBuilder.clear() — удалит ссылку на объект StringBuilder
То же самое работает для WeakReference.

__3) WeakReference__ — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезли strong-ссылки), то он удалит его из памяти

__4) PhantomReference__ — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.
Особенностей у этого типа ссылок две.
+ Первая это то, что метод get() всегда возвращает null. Именно из-за этого `PhantomReference` имеет смысл использовать только вместе с `ReferenceQueue`.
+ Вторая особенность – в отличие от `SoftReference` и `WeakReference`, GC добавит phantom-ссылку в `ReferenceQueue` после того как выполниться метод `finalize()`.

So in brief: Soft references try to keep the reference. Weak references don’t try to keep the reference. Phantom references don’t free the reference until cleared

__ReferenceQueue.__ Он позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. При создании `Reference` мы можем передать в конструктор `ReferenceQueue`, в который будут помещаться ссылки после удаления
+ [Вопрос#12  К оглавлению](#javaLanguages)

## Что такое сборщик мусора? (Garbage collector)
Сборщик мусора выполняет две задачи:
+ поиск мусора;
+ очистка мусора.

Для обнаружения мусора есть два подхода:

__1) Учет ссылок (Reference counting);__
+ Учет ссылок - если обьект не имеет ссылок, он считается мусором.
Проблема - не возможность выявить циклические ссылки, когда два обьекта не имеют внешних ссылок, но ссылаются друг на друга -> утечка памяти

__2) Трассировка (Tracing). (используется в HotSpot6)__
+ Трассировка - до обьекта можно добраться из Корневых точек (GC root). 
До чего добраться нельзя - мусор.
Всё, что доступно из «живого» объекта, также является «живым».

__Типы корневых точек (GC Roots) java приложения:__
+ объекты в статических полях классов
+ объекты, доступные из стека потоков
+ объекты из JNI(java native interface) ссылок в native методах

Самое простое java приложение будет иметь корневые точки:

+ Локальные переменные внутри `main()` метода и параметры `main()` метода;
+ Поток который выполняет `main()`;
+ Статические переменные класса, внутри которого находится `main()` метод.

__Процессы сборки мусора разделяются на несколько видов:__

__1) minor GC (малая)__ - частый и быстрый, работает только с областью памяти "`young generation`";
+ приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);
+ «живые» объекты из Eden перемещаются в область памяти «To»;
+ «живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»;
+ Eden и «From» очищаются от мусора;
+ «To» и «From» меняются местами;
+ приложение возобновляет работу.

__2) major GC (старшая)__ - редкий и более длительный, затрагивает объекты старшего поколения.
В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.

__3) full GC (полная)__ -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения).

Про 4 типа сборщиков мусора читай сдесь: habr.com/ru/post/269621

Для очистки памяти от мусора существуют два основных метода:

+ _Copying collectors_
+ _Mark-and-sweep_

При __copying collectors__ подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:

+ Объекты создаются в «from-space»;
+ Когда «from-space» заполняется, приложение приостанавливается;
+ Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;
+ Когда все объекты скопированы «from-space» полностью очищается;
+ «to-space» и «from-space» меняются местами.

Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:

1. Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;
2. В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.

Алгоритм работы __mark-and-sweep__ можно описать так:

+ Объекты создаются в памяти;
+ В момент, когда нужно запустить сборщик мусора приложение приостанавливается;
+ Сборщик проходится по дереву объектов, помечая живые объекты;
+ Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;
+ Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».

Минусы этого способа:

1. Приложение не работает пока происходит сборка мусора;
2. Время остановки напрямую зависит от размеров памяти и количества объектов;
3. Если не использовать «compacting» память будет использоваться не эффективно.

Сборщики мусора HotSpot VM используют комбинированный подход __Generational Garbage Collection__, который позволяет использовать разные алгоритмы для разных этапов сборки мусора. Этот подход опирается на том, что:

+ большинство создаваемых объектов быстро становятся мусором;
+ существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.

+ [Вопрос#13  К оглавлению](#javaLanguages)

## Как работает сборщик мусора?
Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых объектов.

Объекты создаются посредством оператора `new`, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив переменной ссылку на другой объект или значение `null`; прекратить выполнение метода, чтобы его локальные переменные завершили свое существование естественным образом. Объекты, ссылки на которые отсутствуют, принято называть мусором (_garbage_), который будет удален.

Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект, обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти. Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим посредством цепочки ссылок, начиная с корневой (_GC Root_) ссылки, т.е. ссылки, непосредственно существующей в выполняемом коде.

Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.

Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления большого количества объектов существенным образом сказывается на производительности приложений и если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора, подлежащего утилизации.
+ [Вопрос#14  К оглавлению](#javaLanguages)

## Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?
Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:

+ __Serial (последовательный)__ — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. На данный момент используется сравнительно редко, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. Использование Serial GC включается опцией `-XX:+UseSerialGC`.
+ __Parallel (параллельный)__ — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. Параллельный сборщик включается опцией `-XX:+UseParallelGC`.
+ __Concurrent Mark Sweep (CMS)__ — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти. Использование CMS GC включается опцией `-XX:+UseConcMarkSweepGC`.
+ __Garbage-First (G1)__ — создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных. _G1_ включается опцией Java `-XX:+UseG1GC`.

+ [Вопрос#15  К оглавлению](#javaLanguages)

## Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.
__Serial Garbage Collector (Последовательный сборщик мусора)__ был одним из первых сборщиков мусора в HotSpot VM. Во время работы этого сборщика приложения приостанавливается и продолжает работать только после прекращения сборки мусора. 

Память приложения делится на три пространства:

+ _Young generation_. Объекты создаются именно в этом участке памяти.
+ _Old generation_. В этот участок памяти перемещаются объекты, которые переживают «minor garbage collection».
+ _Permanent generation_. Тут хранятся метаданные об объектах, _Class data sharing (CDS)_, _пул строк (String pool)_. Permanent область делится на две: только для чтения и для чтения-записи. Очевидно, что в этом случае область только для чтения не чистится сборщиком мусора никогда.

Область памяти Young generation состоит из трёх областей: _Eden_ и двух меньших по размеру _Survivor spaces_ - _To space_ и _From space_. Большинство объектов создаются в области Eden, за исключением очень больших объектов, которые не могут быть размещены в ней и поэтому сразу размещаются в Old generation. В Survivor spaces перемещаются объекты, которые пережили по крайней мере одну сборку мусора, но ещё не достигли порога «старости» (_tenuring threshold_), чтобы быть перемещенными в Old generation.

Когда Young generation заполняется, то в этой области запускается процесс лёгкой сборки (_minor collection_), в отличие от процесса сборки, проводимого над всей кучей (_full collection_). Он происходит следующим образом: в начале работы одно из Survivor spaces - To space, является пустым, а другое - From space, содержит объекты, пережившие предыдущие сборки. Сборщик мусора ищет живые объекты в Eden и копирует их в To space, а затем копирует туда же и живые «молодые» (то есть не пережившие еще заданное число сборок мусора) объекты из From space. Старые объекты из From space перемещаются в Old generation. После лёгкой сборки From space и To space меняются ролями, область Eden становится пустой, а число объектов в Old generation увеличивается.

Если в процессе копирования живых объектов To space переполняется, то оставшиеся живые объекты из Eden и From space, которым не хватило места в To space, будут перемещены в Old generation, независимо от того, сколько сборок мусора они пережили.

Поскольку при использовании этого алгоритма сборщик мусора просто копирует все живые объекты из одной области памяти в другую, то такой сборщик мусора называется _copying_ (копирующий). Очевидно, что для работы копирующего сборщика мусора у приложения всегда должна быть свободная область памяти, в которую будут копироваться живые объекты, и такой алгоритм может применяться для областей памяти сравнительно небольших по отношению к общему размеру памяти приложения. Young generation как раз удовлетворяет этому условию (по умолчанию на машинах клиентского типа эта область занимает около 10% кучи (значение может варьироваться в зависимости от платформы)).

Однако, для сборки мусора в Old generation, занимающем большую часть всей памяти, используется другой алгоритм.

В Old generation сборка мусора происходит с использованием алгоритма _mark-sweep-compact_, который состоит из трёх фаз. В фазе _Mark_ (пометка) сборщик мусора помечает все живые объекты, затем, в фазе _Sweep_ (очистка) все не помеченные объекты удаляются, а в фазе _Сompact_ (уплотнение) все живые объекты перемещаются в начало Old generation, в результате чего свободная память после очистки представляет собой непрерывную область. Фаза уплотнения выполняется для того, чтобы избежать фрагментации и упростить процесс выделения памяти в Old generation.

Когда свободная память представляет собой непрерывную область, то для выделения памяти под создаваемый объект можно использовать очень быстрый (около десятка машинных инструкций) алгоритм _bump-the-pointer_: адрес начала свободной памяти хранится в специальном указателе, и когда поступает запрос на создание нового объекта, код проверяет, что для нового объекта достаточно места, и, если это так, то просто увеличивает указатель на размер объекта.

Последовательный сборщик мусора отлично подходит для большинства приложений, использующих до 200 мегабайт кучи, работающих на машинах клиентского типа и не предъявляющих жёстких требований к величине пауз, затрачиваемых на сборку мусора. В то же время модель «stop-the-world» может вызвать длительные паузы в работе приложения при использовании больших объёмов памяти. Кроме того, последовательный алгоритм работы не позволяет оптимально использовать вычислительные ресурсы компьютера, и последовательный сборщик мусора может стать узким местом при работе приложения на многопроцессорных машинах.
+ [Вопрос#16  К оглавлению](#javaLanguages)

## Что произойдет со сборщиком мусора, если выполнение метода `finalize()` требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?
Непосредственно вызов `finalize()` происходит в отдельном потоке _Finalizer_ (`java.lang.ref.Finalizer.FinalizerThread`), который создаётся при запуске виртуальной машины (в статической секции при загрузке класса `Finalizer`). Методы `finalize()` вызываются последовательно в том порядке, в котором были добавлены в список сборщиком мусора. Соответственно, если какой-то `finalize()` зависнет, он подвесит поток _Finalizer_, но не сборщик мусора. Это в частности означает, что объекты, не имеющие метода `finalize()`, будут исправно удаляться, а вот имеющие будут добавляться в очередь, пока поток _Finalizer_ не освободится, не завершится приложение или не кончится память. 

То же самое применимо и выброшенным в процессе `finalize()` исключениям: метод `runFinalizer()` у потока _Finalizer_ игнорирует все исключения выброшенные в момент выполнения `finalize()`. Таким образом возникновение исключительной ситуации никак не скажется на работоспособности сборщика мусора.
+ [Вопрос#17  К оглавлению](#javaLanguages)

## Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?
Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора `new`) хранится в куче.
+ [Вопрос#18  К оглавлению](#javaLanguages)


## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ

+ [Дюк, вынеси мусор! — Часть 1(2015)-->]( https://habr.com/ru/post/269621/ )
+ [Дюк, вынеси мусор! — Часть 2(2015)-->]( https://habr.com/ru/post/269707/ )
+ [Дюк, вынеси мусор! — Часть 3(2015)-->]( https://habr.com/ru/post/269863/ )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )


+ [к оглавлению](#javaLanguages)
