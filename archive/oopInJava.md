[Java Tutorials](README.md)

# OOPInJava

## 1-Classes
+ 1.1) [Какие типы классов бывают в java?](#Какие-типы-классов-бывают-в-java)
+ 1.2) [Что такое _«статический класс»_?](#Что-такое-статический-класс)
+ 1.3) [Что такое _«локальный класс»_? Каковы его особенности?](#Что-такое-локальный-класс-Каковы-его-особенности)
+ 1.4) [Что такое _«анонимные классы»_? Где они применяются?](#Что-такое-анонимные-классы-Где-они-применяются)
+ 1.5) [Что такое абстрактные классы? Чем они отличаются от обычных?](#Что-такое-абстрактные-классы-Чем-они-отличаются-от-обычных)
+ 1.6) [Может ли быть абстрактный класс без абстрактных методов?](#Может-ли-быть-абстрактный-класс-без-абстрактных-методов)
+ 1.7) [Что имеет более высокий уровень абстракции - _класс_, _абстрактный класс_ или _интерфейс_?](#Что-имеет-более-высокий-уровень-абстракции---класс-абстрактный-класс-или-интерфейс)
+ 1.8) [Расскажите про вложенные классы. В каких случаях они применяются?](#Расскажите-про-вложенные-классы-В-каких-случаях-они-применяются)
+ 1.9) [Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?](#Какие-существуют-особенности-использования-вложенных-классов-статических-и-внутренних-В-чем-заключается-разница-между-ними)
+ 1.10) [Каким образом из вложенного класса получить доступ к полю внешнего класса?](#Каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса)
+ 1.11) [Что такое перечисления (enum)?](#Что-такое-перечисления-enum)
+ 1.12) [Как проблема ромбовидного наследования решена в java?](#Как-проблема-ромбовидного-наследования-решена-в-java)
+ 1.13) [Расскажите про классы-загрузчики и про динамическую загрузку классов.](#Расскажите-про-классы-загрузчики-и-про-динамическую-загрузку-классов)
+ 1.14) [Что такое _Reflection_?](#Что-такое-reflection)



## 2-Interfaces
+ 2.1) [Дайте определение понятию _«интерфейс»_. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#Дайте-определение-понятию-интерфейс-Какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
+ 2.2) [Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?](#Чем-абстрактный-класс-отличается-от-интерфейса-В-каких-случаях-следует-использовать-абстрактный-класс-а-в-каких-интерфейс)
+ 2.3) [Почему в некоторых интерфейсах вообще не определяют методов?](#Почему-в-некоторых-интерфейсах-вообще-не-определяют-методов)
+ 2.4) [Почему нельзя объявить метод интерфейса с модификатором `final`?](#Почему-нельзя-объявить-метод-интерфейса-с-модификатором-final)
+ 2.5) [Может ли один интерфейс наследоваться от другого? От двух других?](#Может-ли-один-интерфейс-наследоваться-от-другого-От-двух-других)
+ 2.6) [Что такое дефолтные методы интерфейсов? Для чего они нужны?](#Что-такое-дефолтные-методы-интерфейсов-Для-чего-они-нужны)
+ 2.7) [Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?](#Как-решается-проблема-ромбовидного-наследования-при-наследовании-интерфейсов-при-наличии-default-методов)



## 3-Constructors and initialization
+ 3.1) [Дайте определение понятию «конструктор».](#Дайте-определение-понятию-конструктор)
+ 3.2) [Что такое _«конструктор по умолчанию»_?](#Что-такое-конструктор-по-умолчанию)
+ 3.3) [Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?](#Чем-отличаются-конструктор-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами)
+ 3.4) [Где и как вы можете использовать приватный конструктор?](#Где-и-как-вы-можете-использовать-приватный-конструктор) 
+ 3.5) [Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?](#Могут-ли-быть-конструкторы-у-абстрактных-классов-Для-чего-они-нужны)
+ 3.6) [Что значит слово “инициализация”?](#Что-значит-слово-инициализация)
+ 3.7) [Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?](#Каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учётом-иерархии-классов)
+ 3.8) [Зачем нужны и какие бывают блоки инициализации?](#Зачем-нужны-и-какие-бывают-блоки-инициализации)
+ 3.9) [Где разрешена инициализация статических/нестатических полей?](#Где-разрешена-инициализация-статическихнестатических-полей)
+ 3.10) [Что произойдет, если в блоке инициализации возникнет исключительная ситуация?](#Что-произойдет-если-в-блоке-инициализации-возникнет-исключительная-ситуация)
+ 3.11) [Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?](#Какое-исключение-выбрасывается-при-возникновении-ошибки-в-блоке-инициализации-класса)



## 4-Access Modifiers
+ 4.1) [Какие существуют модификаторы доступа?](#Какие-существуют-модификаторы-доступа)
+ 4.2) [О чем говорит ключевое слово `final`?](#О-чем-говорит-ключевое-слово-final)
+ 4.3) [Где и для чего используется модификатор `abstract`?](#Где-и-для-чего-используется-модификатор-abstract)
+ 4.4) [Что означает модификатор `static`?](#Что-означает-модификатор-static)
+ 4.5) [Может ли объект получить доступ к члену класса объявленному как `private`? Если да, то каким образом?](#Может-ли-объект-получить-доступ-к-члену-класса-объявленному-как-private-Если-да-то-каким-образом)
+ 4.6) [Для чего в Java используются статические блоки инициализации?](#Для-чего-в-java-используются-статические-блоки-инициализации)
+ 4.7) [Может ли статический метод быть переопределён или перегружен?](#Может-ли-статический-метод-быть-переопределён-или-перегружен)
+ 4.8) [Могут ли нестатические методы перегрузить статические?](#Могут-ли-нестатические-методы-перегрузить-статические)
+ 4.9) [Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?](#Можно-ли-сузить-уровень-доступатип-возвращаемого-значения-при-переопределении-метода)
+ 4.10) [Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции `throws`?](#Возможно-ли-при-переопределении-метода-изменить-модификатор-доступа-возвращаемый-тип-тип-аргумента-или-их-количество-имена-аргументов-или-их-порядок-убирать-добавлять-изменять-порядок-следования-элементов-секции-throws)
+ 4.11) [Как получить доступ к переопределенным методам родительского класса?](#Как-получить-доступ-к-переопределенным-методам-родительского-класса)
+ 4.12) [Можно ли объявить метод абстрактным и статическим одновременно?](#Можно-ли-объявить-метод-абстрактным-и-статическим-одновременно)
+ 4.13) [В чем разница между членом экземпляра класса и статическим членом класса?](#В-чем-разница-между-членом-экземпляра-класса-и-статическим-членом-класса)
+ 4.14) [Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?](#Что-можно-изменить-в-сигнатуре-метода-при-переопределении-Можно-ли-менять-модификаторы-throws-и-тп)
+ 4.15) [Могут ли классы быть статическими?](#Могут-ли-классы-быть-статическими)
+ 4.16) [Что означает модификатор final? К чему он может быть применим?](#Что-означает-модификатор-final-К-чему-он-может-быть-применим)
+ 4.17) [К каким конструкциям Java применим модификатор `static`?](#К-каким-конструкциям-java-применим-модификатор-static)
+ 4.18) [Чем отличаются `final`, `finally` и `finalize()`?](#Чем-отличаются-final-finally-и-finalize)


## 5-Class Object
+ 5.1) [Что такое класс `Object`? Какие в нем есть методы?](#Что-такое-класс-object-Какие-в-нем-есть-методы)
+ 5.2) [Расскажите про equals и hashcode](#Расскажите-про-equals-и-hashcode)
+ 5.3) [Каким образом реализованы методы hashCode() и equals() в классе Object?](#Каким-образом-реализованы-методы-hashCode-и-equals-в-классе-Object)
+ 5.4) [Зачем нужен `equals()`. Чем он отличается от операции `==`?](#Зачем-нужен-equals-Чем-он-отличается-от-операции)
+ 5.5) [Правила переопределения метода `Object.equals()`.](#Правила-переопределения-метода-objectequals)
+ 5.6) [Что будет, если переопределить `equals()` не переопределяя `hashCode()`? Какие могут возникнуть проблемы?](#Что-будет-если-переопределить-equals-не-переопределяя-hashcode-Какие-могут-возникнуть-проблемы)
+ 5.7) [Для чего нужен метод `hashCode()`?](#Для-чего-нужен-метод-hashcode)
+ 5.8) [Какой контракт между `hashCode()` и `equals()`?](#Какой-контракт-между-hashCode-и-equals)
+ 5.9) [Правила переопределения метода `hashcode()`](#Правила-переопределения-метода-hashcode)
+ 5.10) [Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете `hashCode()`?](#Есть-ли-какие-либо-рекомендации-о-том-какие-поля-следует-использовать-при-подсчете-hashcode)
+ 5.11) [Могут ли у разных объектов быть одинаковые `hashCode()`?](#Могут-ли-у-разных-объектов-быть-одинаковые-hashcode)
+ 5.12) [Есть класс `Point{int x, y;}`. Почему хэш код в виде `31 * x + y` предпочтительнее чем `x + y`?](#Есть-класс-pointint-x-y-Почему-хэш-код-в-виде-31--x--y-предпочтительнее-чем-x--y)
+ 5.13) [Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?](#Почему-нельзя-реализовать-hashcode-который-будет-гарантированно-уникальным-для-каждого-объекта)
+ 5.14) [Чем a.getClass().equals(A.class) отличается от a instanceOf A.class](#Чем-a.getClass-.equals-A.class-отличается-от-a-instanceOf-A.class)
+ 5.15) [Если у класса `Point{int x, y;}` реализовать метод `equals(Object that) {(return this.x == that.x && this.y == that.y)}`, но сделать хэш код в виде `int hashCode() {return x;}`, то будут ли корректно такие точки помещаться и извлекаться из `HashSet`?](#Если-у-класса-pointint-x-y-реализовать-метод-equalsobject-that-return-thisx--thatx--thisy--thaty-но-сделать-хэш-код-в-виде-int-hashcode-return-x-то-будут-ли-корректно-такие-точки-помещаться-и-извлекаться-из-hashset)
+ 5.16) [Могут ли у разных объектов `(ref0 != ref1)` быть `ref0.equals(ref1) == true`?](#Могут-ли-у-разных-объектов-ref0--ref1-быть-ref0equalsref1--true)
+ 5.17) [Могут ли у разных ссылок на один объект `(ref0 == ref1)` быть `ref0.equals(ref1) == false`?](#Могут-ли-у-разных-ссылок-на-один-объект-ref0--ref1-быть-ref0equalsref1--false)
+ 5.18) [Можно ли так реализовать метод `equals(Object that) {return this.hashCode() == that.hashCode()}`?](#Можно-ли-так-реализовать-метод-equalsobject-that-return-thishashcode--thathashcode)
+ 5.19) [В `equals()` требуется проверять, что аргумент `equals(Object that)` такого же типа что и сам объект. В чем разница между `this.getClass() == that.getClass()` и `that instanceof MyClass`?](#В-equals-требуется-проверять-что-аргумент-equalsobject-that-такого-же-типа-что-и-сам-объект-В-чем-разница-между-thisgetclass--thatgetclass-и-that-instanceof-myclass)
+ 5.20) [Можно ли реализовать метод `equals()` класса `MyClass` вот так: `class MyClass {public boolean equals(MyClass that) {return this == that;}}`?](#Можно-ли-реализовать-метод-equals-класса-myclass-вот-так-class-myclass-public-boolean-equalsmyclass-that-return-this--that)
+ 5.21) [Что такое `finalize()`? Зачем он нужен?](#Что-такое-finalize-Зачем-он-нужен)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)
+ [к оглавлению](#OOPInJava)



## 1-Classes

## Какие типы классов бывают в java?
1) _Top level class_ (Обычный класс):
    + _Abstract class_ (Абстрактный класс);
    + _Final class_ (Финализированный класс).
2) _Interfaces_ (Интерфейс).
3) _Enum_ (Перечисление).
4) _Nested class_ (Вложенный класс):
    + _Static nested class_ (Статический вложенный класс);
    + _Member inner class_ (Простой внутренний класс);
    + _Local inner class_ (Локальный класс);
    + _Anonymous inner class_ (Анонимный класс).

+ [Вопрос#1.1  К оглавлению](#OOPInJava)

## Что такое _«статический класс»_?
Это вложенный класс, объявленный с использованием ключевого слова `static`. К классам верхнего уровня модификатор `static` неприменим.
+ [Вопрос#1.2  К оглавлению](#OOPInJava)

## Что такое _«локальный класс»_? Каковы его особенности?
__Local inner class__ (Локальный класс) - это вложенный класс, который может быть декларирован в любом блоке, в котором разрешается декларировать переменные. Как и простые внутренние классы (_Member inner class_) локальные классы имеют имена и могут использоваться многократно. Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в нестатическом контексте.
С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.

Локальные классы имеют следующие особенности:
+ Видны только в пределах блока, в котором объявлены;
+ Не могут быть объявлены как `private`/`public`/`protected` или `static`;
+ Не могут иметь внутри себя статических объявлений методов и классов, но могут иметь финальные статические поля, проинициализированные константой;
+ Имеют доступ к полям и методам обрамляющего класса;
+ Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором `final`.

+ [Вопрос#1.3  К оглавлению](#OOPInJava)

## Что такое _«анонимные классы»_? Где они применяются?
Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:
+ Их использование разрешено только в одном месте программы - месте его создания;
+ Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
+ Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для: 
+ создания объекта функции (_function object_), например, реализация интерфейса `Comparator`;
+ создания объекта процесса (_process object_), такого как экземпляры классов `Thread`, `Runnable` и подобных;
+ в статическом методе генерации;
+ инициализации открытого статического поля `final`, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.

Анонимные классы всегда являются конечными классами. Каждое объявление анонимного класса уникально. Видны только внутри того метода, в котором определены. В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». 
+ [Вопрос#1.4  К оглавлению](#OOPInJava)

## Что такое абстрактные классы? Чем они отличаются от обычных?
Как обычный класс, но с абстрактными методами. 
Нельзя создать объект или экземпляр абстрактного класса.
Наследниками абстрактного класса могут быть другие абстрактные классы
+ [Вопрос#1.5  К оглавлению](#OOPInJava)

## Может ли быть абстрактный класс без абстрактных методов?
Да. Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор `abstract`.
+ [Вопрос#1.6  К оглавлению](#OOPInJava)

## Что имеет более высокий уровень абстракции - _класс_, _абстрактный класс_ или _интерфейс_?
Интерфейс.
+ [Вопрос#1.7  К оглавлению](#OOPInJava)

## Расскажите про вложенные классы. В каких случаях они применяются?
1) __Статические вложенные классы (Static nested classes)__
+ Есть возможность обращения к внутренним статическим полям и методам класса обертки.
2) __Простой внутренний класс(Member inner class)__
+ Есть возможность обращения к внутренним полям и методам класса обертки.
+ Не может иметь статических объявлений.
+ Внутри такого класса нельзя объявить перечисления.
+ Если нужно явно получить this внешнего класса — OuterClass.this
3) __Локальный класс (Local inner class)__
+ Видны только в пределах блока, в котором объявлены.
+ Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).
+ Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final)
+ Имеют доступ к полям и методам обрамляющего класса.
+ Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final.
4) __Анонимные классы (Anonymous inner class)__
+ Локальный класс без имени.

Нужны для обслуживания внешних классов
Класс называется вложенным (_Nested class_), если он определен внутри другого класса. 
Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. 
Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня. 
Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. 
Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.
Такие категории классов, за исключением первого, также называют внутренними (_Inner class_). 
Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.

Каждая из категорий имеет рекомендации по своему применению:
+ Если вложенный класс должен быть виден за пределами одного метода или он слишком длинный для того, 
чтобы его можно было удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр, 
то используется нестатический внутренний класс. 
+ В случае, если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим. 
+ Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в этом методе, то используется локальный класс. 
+ А, если к тому же применение класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий этот класс, 
то рекомендуется делать его анонимным классом.

+ [Вопрос#1.8  К оглавлению](#OOPInJava)

## Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?
+ Вложенные классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным. 
+ Для создания объекта статического вложенного класса объект внешнего класса не требуется.
+ Из объекта статического вложенного класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.
+ Обычные вложенные классы не могут содержать статических методов, блоков инициализации и классов. Статические вложенные классы - могут.
+ В объекте обычного вложенного класса хранится ссылка на объект внешнего класса. Внутри статической такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание `.this` после его имени. Например: `Outer.this`.

+ [Вопрос#1.9  К оглавлению](#OOPInJava)

## Каким образом из вложенного класса получить доступ к полю внешнего класса?
Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса. 

Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземляр. Например: `Outer.this.field`.
+ [Вопрос#1.10  К оглавлению](#OOPInJava)

## Что такое перечисления (enum)?
__Перечисления представляют набор логически связанных констант.__ 
+ Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.
+ Перечисления, как и обычные классы, могут определять конструкторы, поля и методы. Следует отметить, что конструктор по умолчанию приватный. Также можно определять методы для отдельных констант.

Методы:
+ `__ordinal()__` возвращает порядковый номер определенной константы (нумерация начинается с 0)
+ `__values()__` возвращает массив всех констант перечисления
`Еnum` имеет ряд преимуществ при использовании в сравнении с `static final int`. 
Главным отличием является то что используя `enum` вы можете проверить тип данных.

Недостатки:
+ К ним не применимы операторы >, <, >=, <=
+ `enum` также требует больше памяти для хранения чем обычная константа.

Нужны для ограничения области допустимых значений: например, времена года, дни недели
+ [Вопрос#1.11  К оглавлению](#OOPInJava)

## Как проблема ромбовидного наследования решена в java?
__В Java нет поддержки множественного наследования классов.__
Предположим, что `SuperClass` — это абстрактный класс, описывающий некоторый метод, а классы `ClassA` и `ClassB` — обычные классы наследники `SuperClass`, а класс `ClassC` наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов. Интерфейсы – это только  резервирование/описание метода, а реализация самого метода будет в конкретном классе, реализующем эти интерфейсы, таким образом исключается неопределенность при множественном наследовании интерфейсов. В случае, если вызывается default-метод из интерфейса его обязательно надо будет переопределить.  
+ [Вопрос#1.12  К оглавлению](#OOPInJava)

## Расскажите про классы-загрузчики и про динамическую загрузку классов.
При запуске JVM, используются три загрузчика классов:

1) __Bootstrap ClassLoader - главный загрузчик__ - загружает платформенные классы JDK из архива rt.jar
2) __AppClassLoader - системный загрузчик__ - загружает классы приложения, определенные в CLASSPATH 
3) __Extension ClassLoader - загрузчик расширений__ - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.

Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().
Основа работы с классами в Java — классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и создания объекта класса по его имени во время работы приложения.

В начале работы программы создается 3 основных загрузчика классов:

+ __базовый загрузчик (bootstrap/primordial)__. Загружает основные системные и внутренние классы JDK (_Core API_ - пакеты `java.*` (`rt.jar` и `i18n.jar`) . Важно заметить, что базовый загрузчик является _«Изначальным»_ или _«Корневым»_ и частью JVM, вследствие чего его нельзя создать внутри кода программы.
+ __загрузчик расширений (extention)__. Загружает различные пакеты расширений, которые располагаются в директории `<JAVA_HOME>/lib/ext` или другой директории, описанной в системном параметре `java.ext.dirs`. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений реализован классом `sun.misc.Launcher$ExtClassLoader`. 
+ __системный загрузчик (system/application)__. Загружает классы, пути к которым указаны в переменной окружения `CLASSPATH` или пути, которые указаны в командной строке запуска JVM после ключей `-classpath` или `-cp`. Системный загрузчик реализован классом `sun.misc.Launcher$AppClassLoader`.

Загрузчики классов являются иерархическими: каждый из них (кроме базового) имеет родительский загрузчик и в большинстве случаев, перед тем как попробовать загрузить класс самостоятельно, он посылает вначале запрос родительскому загрузчику загрузить указанный класс. Такое делегирование позволяет загружать классы тем загрузчиком, который находится ближе всего к базовому в иерархии делегирования. Как следствие поиск классов будет происходить в источниках в порядке их доверия: сначала в библиотеке _Core API_, потом в папке расширений, потом в локальных файлах `CLASSPATH`. 

Процесс загрузки класса состоит из трех частей:

+ _Loading_ – на этой фазе происходит поиск и физическая загрузка файла класса в определенном источнике (в зависимости от загрузчика). Этот процесс определяет базовое представление класса в памяти. На этом этапе такие понятия как «методы», «поля» и т.д. пока не известны.
+ _Linking_ – процесс, который может быть разбит на 3 части:
    + _Bytecode verification_ – проверка байт-кода на соответствие требованиям, определенным в спецификации JVM.
    + _Class preparation_ – создание и инициализация необходимых структур, используемых для представления полей, методов, реализованных интерфейсов и т.п., определенных в загружаемом классе.
    + _Resolving_ – загрузка набора классов, на которые ссылается загружаемый класс.
+ _Initialization_ – вызов статических блоков инициализации и присваивание полям класса значений по умолчанию.

Динамическая загрузка классов в Java имеет ряд особенностей:

+ _отложенная (lazy) загрузка и связывание классов_. Загрузка классов производится только при необходимости, что позволяет экономить ресурсы и распределять нагрузку.
+ _проверка корректности загружаемого кода (type safeness)_. Все действия связанные с контролем использования типов производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.
+ _программируемая загрузка_. Пользовательский загрузчик полностью контролирует процесс получения запрошенного класса — самому ли искать байт-код и создавать класс или делегировать создание другому загрузчику. Дополнительно существует возможность выставлять различные атрибуты безопасности для загружаемых классов, позволяя таким образом работать с кодом из ненадежных источников.
+ _множественные пространства имен_. Каждый загрузчик имеет своё пространство имён для создаваемых классов. Соответственно, классы, загруженные двумя различными загрузчиками на основе общего байт-кода, в системе будут различаться.

Существует несколько способов инициировать загрузку требуемого класса:

+ явный: вызов `ClassLoader.loadClass()` или `Class.forName()` (по умолчанию используется загрузчик, создавший текущий класс, но есть возможность и явного указания загрузчика);
+ неявный: когда для дальнейшей работы приложения требуется ранее не использованный класс, JVM инициирует его загрузку.

+ [Вопрос#1.13  К оглавлению](#OOPInJava)

## Что такое _Reflection_?
__Рефлексия (Reflection)__ - это механизм получения данных о программе во время её выполнения (runtime). В Java _Reflection_ осуществляется с помощью _Java Reflection API_, состоящего из классов пакетов `java.lang` и `java.lang.reflect`.

Возможности `Java Reflection API`: 

+ Определение класса объекта;
+ Получение информации о модификаторах класса, полях, методах, конструкторах и суперклассах;
+ Определение интерфейсов, реализуемых классом;
+ Создание экземпляра класса;
+ Получение и установка значений полей объекта;
+ Вызов методов объекта;
+ Создание нового массива.

+ [Вопрос#1.14  К оглавлению](#OOPInJava)



## 2-Interfaces

## Дайте определение понятию _«интерфейс»_. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
Ключевое слово `interface` используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как публичные `public`  и абстрактными `abstract`.

Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию `default` и статических `static` методов.

Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными `public`, статическими `static` и неизменяемыми `final`.
+ [Вопрос#2.1  К оглавлению](#OOPInJava)

## Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?
1) В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
2) Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
3) Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как `public abstract` или (начиная с Java 8) `default` - методами с реализацией по-умолчанию, а поля - `public static final`.
4) Интерфейсы позволяют создавать структуры типов без иерархии.
5) Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.
+ [Вопрос#2.2  К оглавлению](#OOPInJava)

## Почему в некоторых интерфейсах вообще не определяют методов?
Это так называемые _маркерные интерфейсы_. Они просто указывают что класс относится к определенному типу. Примером может послужить интерфейс `Clonable`, который указывает на то, что класс поддерживает механизм клонирования.
+ [Вопрос#2.3  К оглавлению](#OOPInJava)

## Почему нельзя объявить метод интерфейса с модификатором `final`?
В случае интерфейсов указание модификатора `final` бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор `final`.
+ [Вопрос#2.4  К оглавлению](#OOPInJava)

## Может ли один интерфейс наследоваться от другого? От двух других?
Да, может. Используется ключевое слово extends
+ [Вопрос#2.5  К оглавлению](#OOPInJava)

## Что такое дефолтные методы интерфейсов? Для чего они нужны?
В JDK 8 была добавлена такая функциональность как методы по умолчанию с модификатором `default`. И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Это нужно для обратной совместимости. 
(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.) 
+ [Вопрос#2.6  К оглавлению](#OOPInJava)

## Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?
__Обязательным переопределением default-метода__
В случае, если вызывается default-метод из интерфейса его обязательно надо будет переопределить.
+ [Вопрос#2.7  К оглавлению](#OOPInJava)



## 3-Constructors and initialization

## Дайте определение понятию «конструктор».
__Конструктор__ — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для его инициализации.
+ [Вопрос#3.1  К оглавлению](#OOPInJava)

## Что такое _«конструктор по умолчанию»_?
+ Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый __«конструктор по умолчанию»__.
```java
public class ClassName() {}
```
+ Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.
+ В классе-наследнике при отсутствии переопределенного конструктора будет использован конструктор родителя.

+ [Вопрос#3.2  К оглавлению](#OOPInJava)

## Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?
+ У конструктора по умолчанию отсутствуют какие-либо аргументы. 
+ Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона. 
+ Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).

+ [Вопрос#3.3  К оглавлению](#OOPInJava)

## Где и как вы можете использовать приватный конструктор?
Приватный (помеченный ключевым словом `private`, скрытый) конструктор может использоваться публичным статическим методом генерации объектов данного класса. Также доступ к нему разрешён вложенным классам и может использоваться для их нужд.
Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.
Нужен для реализации паттернов, например singleton.
+ [Вопрос#3.4  К оглавлению](#OOPInJava)

## Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?
__Да. Необходимы для наследников.__

В абстрактном классе в Java можно объявить и определить конструкторы. Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, необходимые для настройки класса.
+ [Вопрос#3.5  К оглавлению](#OOPInJava)

## Что значит слово “инициализация”?
Инициализация (от англ. initialization, инициирование) — создание, активация, подготовка к работе, определение параметров. Приведение программы или устройства в состояние готовности к использованию. С точки зрения Java – выделение памяти под объект, например при создании MyClass myClass = new MyClass(). Таким образом будет выделена память под объект myClass (он будет инициализирован). Без инициализации (new MyClass()) запись MyClass myClass; просто резервирует имя (объявляется переменная myClass типа MyClass).
+ [Вопрос#3.6  К оглавлению](#OOPInJava)

## Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?
1) Статические блоки от первого до последнего предка
2) Попарно динамической блок инициализации и конструктор от первого до последнего предка
Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса. 

Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.

>Parent static block(s) → Child static block(s) → Grandchild static block(s)
>
> → Parent non-static block(s) → Parent constructor →
>
> → Child non-static block(s) → Child constructor →
>
> → Grandchild non-static block(s) → Grandchild constructor

Пример 1:

```java
public class MainClass {

    public static void main(String args[]) {
        System.out.println(TestClass.v);
        new TestClass().a();
    }

}
```

```java
public class TestClass {

    public static String v = "Some val";

    {
        System.out.println("!!! Non-static initializer");
    }

    static {
        System.out.println("!!! Static initializer");
    }

    public void a() {
        System.out.println("!!! a() called");
    }

}
```

Результат выполнения:

```
!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called
```

Пример 2:

```java
public class MainClass {

    public static void main(String args[]) {        
        new TestClass().a();
    }

}
```

```java
public class TestClass {

    public static String v = "Some val";

    {
        System.out.println("!!! Non-static initializer");
    }

    static {
        System.out.println("!!! Static initializer");
    }

    public void a() {
        System.out.println("!!! a() called");
    }

}
```

Результат выполнения:

```
!!! Static initializer
!!! Non-static initializer
!!! a() called
```
+ [Вопрос#3.7  К оглавлению](#OOPInJava)

## Зачем нужны и какие бывают блоки инициализации?
Существуют статические и нестатические блоки инициализации.
Используююся для выполнения кода, который должен выполняться один раз при инициализации класса.
Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов. 

+ Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора. 
+ Несколько блоков инициализации выполняются в порядке следования в коде класса. 
+ Блок инициализации способен генерировать исключения, если их объявления перечислены в `throws` всех конструкторов класса.
+ Блок инициализации возможно создать и в анонимном классе.

+ [Вопрос#3.8  К оглавлению](#OOPInJava)

## Где разрешена инициализация статических/нестатических полей?
+ Статические поля можно инициализировать при объявлении, в статическом или нестатическом блоке инициализации. 
+ Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициализации или в конструкторе.

+ [Вопрос#3.9  К оглавлению](#OOPInJava)

## Что произойдет, если в блоке инициализации возникнет исключительная ситуация?
+ __Для нестатических блоков инициализации__, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции. 
+ __Для статического блока__ выбрасывание исключения в явном виде, приводит к ошибке компиляции.

+ [Вопрос#3.10  К оглавлению](#OOPInJava)

## Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
Если возникшее исключение - наследник RuntimeException:
+ для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;
+ для нестатических будет проброшено исключение-источник.
+ Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.
+ Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.

+ [Вопрос#3.11  К оглавлению](#OOPInJava)



## 4-Access Modifiers

## Какие существуют модификаторы доступа?
1) __private__ (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово `private`.
2) __default__, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное обозначение не требуется.
3) __protected__ (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово `protected`.
4) __public__ (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово `public`.

Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.

Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия _принципу подстановки Барбары Лисков_).

Класс может быть объявлен с модификатором `public` и `default`.
+ [Вопрос#4.1  К оглавлению](#OOPInJava)

## О чем говорит ключевое слово `final`?
Модификатор `final` может применяться к переменным, параметрам методов, полям и методам класса или самим классам.

+ Класс не может иметь наследников;
+ Метод не может быть переопределен в классах наследниках;
+ Поле не может изменить свое значение после инициализации;
+ Параметры методов не могут изменять своё значение внутри метода;
+ Локальные переменные не могут быть изменены после присвоения им значения.

+ [Вопрос#4.2 К оглавлению](#OOPInJava)

## Где и для чего используется модификатор `abstract`?
Класс помеченный модификатором `abstract` называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.

Метод помеченный ключевым словом `abstract` - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.

Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.
+ [Вопрос#4.3  К оглавлению](#OOPInJava)

## Что означает модификатор `static`?
__Статическая переменная - это переменная, принадлежащая классу, а не объекту.__ 
А статический класс- это вложенный класс, который может обращаться только к статическим полям обертывающего его класса. 
Внутри `static` метода нельзя вызвать не статический метод по имени класса.
+ [Вопрос#4.4  К оглавлению](#OOPInJava)

## Может ли объект получить доступ к члену класса объявленному как `private`? Если да, то каким образом?
+ Внутри класса доступ к приватной переменной открыт без ограничений;
+ Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;
+ Доступ к приватным переменным извне может быть организован через отличные от приватных методов, которые предоставлены разработчиком класса. Например: `getX()` и `setX()`.
+ Через механизм рефлексии (Reflection API):

```java
class Victim { 
    private int field = 42;
}
//...
Victim victim = new Victim(); 
Field field = Victim.class.getDeclaredField("field"); 
field.setAccessible(true); 
int fieldValue = (int) field.get(victim);
//...
```
+ [Вопрос#4.5  К оглавлению](#OOPInJava)

## Для чего в Java используются статические блоки инициализации?
Статические блоки инициализация используются __для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов__, в момент, предшествующий созданию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса `Class`).
+ [Вопрос#4.6  К оглавлению](#OOPInJava)

## Может ли статический метод быть переопределён или перегружен?
__Перегружен - ДА.__ Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается. 

__Переопределён - НЕТ.__ Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.

В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.
+ [Вопрос#4.7  К оглавлению](#OOPInJava)

## Могут ли нестатические методы перегрузить статические?
__ДА. В итоге получится два разных метода.__ Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.
+ [Вопрос#4.8  К оглавлению](#OOPInJava)

## Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
При переопределении метода __нельзя сузить модификатор доступа к методу__ (например, с `public` до `private`), но можно расширить.
__Изменить тип возвращаемого значения нельзя,__ но можно сузить возвращаемое значение, если они совместимы. Например, если метод возвращает объект класса, а переопределенный метод возвращает класс-наследник.
+ [Вопрос#4.9  К оглавлению](#OOPInJava)

## Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции `throws`?
При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.

Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:

+ Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
+ При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить _overloading_ (перегрузка) метода.
+ Секцию `throws` метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения `RuntimeException`. Порядок следования таких элементов при переопределении значения не имеет.

+ [Вопрос#4.10  К оглавлению](#OOPInJava)

## Как получить доступ к переопределенным методам родительского класса?
С помощью ключевого слова `super` мы можем обратиться к любому члену родительского класса - методу или полю, если они не определены с модификатором `private`.

```java
super.method();
```
+ [Вопрос#4.11  К оглавлению](#OOPInJava)

## Можно ли объявить метод абстрактным и статическим одновременно?
Нет. В таком случае компилятор выдаст ошибку: _"Illegal combination of modifiers: ‘abstract’ and ‘static’"_. Модификатор `abstract` говорит, что метод будет реализован в другом классе, а `static` наоборот указывает, что этот метод будет доступен по имени класса.
+ [Вопрос#4.12  К оглавлению](#OOPInJava)

## В чем разница между членом экземпляра класса и статическим членом класса?
Модификатор `static` говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. Поля, помеченные `static` инициализируются при инициализации класса. На методы, объявленные как `static`, накладывается ряд ограничений:

+ Они могут вызывать только другие статические методы.
+ Они должны осуществлять доступ только к статическим переменным.
+ Они не могут ссылаться на члены типа `this` или `super`.

В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. Вызов метода экземпляра возможен только после предварительного создания объекта класса.

Пример:
```java
public class MainClass {

	public static void main(String args[]) {
		System.out.println(TestClass.v);
		new TestClass().a();
		System.out.println(TestClass.v);
	}

}
```

```java
public class TestClass {

	public static String v = "Initial val";

	{
		System.out.println("!!! Non-static initializer");
		v = "Val from non-static";
	}

	static {
		System.out.println("!!! Static initializer");
		v = "Some val";
	}

	public void a() {
		System.out.println("!!! a() called");
	}

}
```

Результат:

```
!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called
Val from non-static

```
+ [Вопрос#4.13  К оглавлению](#OOPInJava)

## Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?
__В сигнатуре(имя + параметры) менять ничего нельзя.__
+ Возможно расширение уровня доступа.
+ Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
+ Секцию `throws` метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

+ [Вопрос#4.14  К оглавлению](#OOPInJava)

## Могут ли классы быть статическими?
Класс можно объявить статическим за исключением классов верхнего уровня.
Такие классы известны как «вложенные статические классы» (nested static class). 
+ [Вопрос#4.15  К оглавлению](#OOPInJava)

## Что означает модификатор final? К чему он может быть применим?
+ Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. 
+ Следует также отметить, что к abstract-классам нельзя применить модификатор `final`, т.к. это взаимоисключающие понятия.
+ Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено
+ Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.
+ Т.к. массив – это объект, то `final` означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.

+ [Вопрос#4.16  К оглавлению](#OOPInJava)

## К каким конструкциям Java применим модификатор `static`?
+ полям;
+ методам;
+ вложенным классам;
+ членам секции `import`.

+ [Вопрос#4.17  К оглавлению](#OOPInJava)

## Чем отличаются `final`, `finally` и `finalize()`?
Модификатор `final`:

+ Класс не может иметь наследников;
+ Метод не может быть переопределен в классах наследниках;
+ Поле не может изменить свое значение после инициализации;
+ Локальные переменные не могут быть изменены после присвоения им значения;
+ Параметры методов не могут изменять своё значение внутри метода.

Оператор `finally` гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке `try-catch`.

Метод `finalize()` вызывается перед тем как сборщик мусора будет проводить удаление объекта.

Пример:
```java

public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		System.out.println("result of a.a() is " + a.a());
		a = null;
		System.gc(); // Принудительно зовём сборщик мусора
		a = new TestClass();
		System.out.println("result of a.a() is " + a.a());
		System.out.println("!!! done");
	}

}
```

```java
public class TestClass {

	public int a() {
		try {
			System.out.println("!!! a() called");
			throw new Exception("");
		} catch (Exception e) {
			System.out.println("!!! Exception in a()");
			return 2;
		} finally {
			System.out.println("!!! finally in a() ");
		}
	}

	@Override
	protected void finalize() throws Throwable {
		System.out.println("!!! finalize() called");
		super.finalize();
	}
}
```

Результат выполнения:

```
!!! a() called
!!! Exception in a()
!!! finally in a() 
result of a.a() is 2
!!! a() called
!!! Exception in a()
!!! finally in a() 
!!! finalize() called
result of a.a() is 2
!!! done
```
+ [Вопрос#4.18  К оглавлению](#OOPInJava)


## 5-Class Object

## Что такое класс `Object`? Какие в нем есть методы?
Все классы являются наследниками суперкласса `Object`. Это не нужно указывать явно. В результате объект `Object` может ссылаться на объект любого другого класса.

Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения.

+ `public boolean equals(Object obj)` – служит для сравнения объектов по значению;
+ `int hashCode()` – возвращает hash код для объекта;
+ `String toString()` – возвращает строковое представление объекта;
+ `Class getClass()` – возвращает класс объекта во время выполнения;
+ `protected Object clone()` – создает и возвращает копию объекта;
+ `protected void finalize()` – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

Для многопоточки: 
+ `void notify()` – возобновляет поток, ожидающий монитор;
+ `void notifyAll()` – возобновляет все потоки, ожидающие монитор;
+ `void wait()` – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;
+ `void wait(long timeout)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;
+ `void wait(long timeout, int nanos)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта; Нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.

+ [Вопрос#5.1  К оглавлению](#OOPInJava)

## Расскажите про equals и hashcode
1) __Хеш-код__ — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.
2) __Equals__ - это метод, определенный в `Object`, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам. При сравнении по `equals()` идет сравнение по состояниям объектов. 

Свойства equals():
+ __Симметричность:__ Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)
+ __Рефлексивность:__ Для всех ненулевых ссылок, a.equals(a)
+ __Постоянство:__ повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.
+ __Транзитивность:__ Если a.equals(b) и b.equals(c), то тогда a.equals(c)
+ __Совместимость с hashCode():__ Два тождественно равных объекта должны иметь одно и то же значение `hashCode()`

При переопределении `equals()` обязательно нужно переопределить метод `hashCode()`. Равные объекты должны возвращать одинаковые хэш коды.
+ [Вопрос#5.2  К оглавлению](#OOPInJava)

## Каким образом реализованы методы hashCode() и equals() в классе Object?
1) Реализация метода `Object.equals()` сводится к проверке на равенство двух ссылок:
```java
public boolean equals(Object obj) {
  return (this == obj);
}
```
2) Реализация метода `Object.hashCode()` описана как `native`, т.е. написана не на Java. Непереопределенный `hashCode` возвращает идентификационный хеш, основанный на состоянии потока, объединённого с `xorshift` (в OpenJDK8). А вообще, функция предлагает шесть методов на базе значения переменной `hashCode`.

2.1) Случайно сгенерированное число.
2.2) Функция адреса объекта в памяти.
2.3) Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).
2.4) Последовательность.
2.5) Адрес объекта в памяти, приведённый к целочисленному значению.
2.6) Состояние потока, объединённое с xorshift (https://en.wikipedia.org/wiki/Xorshift)
```java
public native int hashCode();
```
+ [Вопрос#5.3  К оглавлению](#OOPInJava)

## Зачем нужен `equals()`. Чем он отличается от операции `==`?
Метод `equals()` - определяет отношение эквивалентности объектов.
+ При сравнении объектов с помощью `==` сравнение происходит лишь между ссылками. 
+ При сравнении по переопределённому разработчиком `equals()` - по внутреннему состоянию объектов.

+ [Вопрос#5.4  К оглавлению](#OOPInJava)

## Правила переопределения метода `Object.equals()`.
1) Проверить на равенство ссылки объектов `this` и параметра метода o.
```java
if (this == o) return true;
```
2) Проверить, определена ли ссылка o, т. е. является ли она `null`.
Если в дальнейшем при сравнении типов объектов будет использоваться оператор `instanceof`, этот пункт можно пропустить, т. к. этот параметр возвращает `false` в данном случае `null instanceof Object`.
3) Сравнить типы объектов `this` и o с помощью оператора `instanceof` или метода `getClass()`, руководствуясь описанием выше и собственным чутьем.
4) Если метод `equals` переопределяется в подклассе, не забудьте сделать вызов `super.equals(o)`
5) Выполнить преобразование типа параметра o к требуемому классу.
6) Выполнить сравнение всех значимых полей объектов:
+ для примитивных типов (кроме `float` и `double`), используя оператор ==
+ для ссылочных полей необходимо вызвать их метод `equals`
+ для массивов можно воспользоваться перебором по циклу, либо методом `Arrays.equals()`
+ для типов `float` и `double` необходимо использовать методы сравнения соответствующих оберточных классов `Float.compare()` и `Double.compare()`

+ [Вопрос#5.5  К оглавлению](#OOPInJava)

## Что будет, если переопределить `equals()` не переопределяя `hashCode()`? Какие могут возникнуть проблемы?
Классы и методы, которые используют правила этого контракта могут работать некорректно. Так для `HashMap` это может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.
+ [Вопрос#5.6  К оглавлению](#OOPInJava)

## Для чего нужен метод `hashCode()`?
Метод `hashCode()` необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число, в более широком смыле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java множество возможных хэш кодов ограничено типом `int`, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:

+ если хэш коды разные, то и объекты гарантированно разные;
+ если хэш коды равны, то объекты не обязательно равны.

+ [Вопрос#5.7  К оглавлению](#OOPInJava)

## Какой контракт между hashCode() и equals()?
1) Если два объекта возвращают разные значения `hashcode()`, то они не могут быть равны
2) Если `equals` объектов true, то и хэшкоды должны быть равны.  
3) Переопределив `equals`, всегда нужно переопределять и `hashcode`.
+ [Вопрос#5.8  К оглавлению](#OOPInJava)

## Правила переопределения метода hashcode().
1) Если хеш-коды разные, то и входные объекты гарантированно разные.
2) Если хеш-коды равны, то входные объекты не всегда равны.
3) При вычислении хэш-кода следует использовать те же поля, которые сравниваются в `equals` и которые не вычисляются на основе других значений.
+ [Вопрос#5.9  К оглавлению](#OOPInJava)

## Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете `hashCode()`?
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например, такие как `id`, `uuid`. При этом нужно следовать правилу, если поля задействованы при вычислении `hashCode()`, то они должны быть задействованы и при выполнении `equals()`.
+ [Вопрос#5.10  К оглавлению](#OOPInJava)

## Могут ли у разных объектов быть одинаковые `hashCode()`?
Да, могут. Метод `hashCode()` не гарантирует уникальность возвращаемого значения. Ситуация, когда у разных объектов одинаковые хэш коды называется __коллизией__. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш кода.
+ [Вопрос#5.11  К оглавлению](#OOPInJava)

## Есть класс `Point{int x, y;}`. Почему хэш код в виде `31 * x + y` предпочтительнее чем `x + y`?
Множитель создает зависимость значения хэш кода от очередности обработки полей, что в итоге порождает лучшую хэш функцию.
+ [Вопрос#5.12  К оглавлению](#OOPInJava)

## Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?
В Java множество возможных хэш кодов ограничено типом `int`, а множество объектов ничем не ограничено.
Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть
+ [Вопрос#5.13  К оглавлению](#OOPInJava)

## Чем a.getClass().equals(A.class) отличается от a instanceOf A.class
+ `getClass()` получает только класс
+ оператор `instanceof` проверяет является ли объект экземпляром класса или его потомком
+ [Вопрос#5.14  К оглавлению](#OOPInJava)

## Если у класса `Point{int x, y;}` реализовать метод `equals(Object that) {(return this.x == that.x && this.y == that.y)}`, но сделать хэш код в виде `int hashCode() {return x;}`, то будут ли корректно такие точки помещаться и извлекаться из `HashSet`?
`HashSet` использует `HashMap` для хранения элементов. При добавлении элемента в `HashMap` вычисляется хэш код, по которому определяется позиция в массиве, куда будет вставлен новый элемент. У всех экземпляров класса `Point` хэш код будет одинаковым для всех объектов с одинаковым `x`, что приведёт к вырождению хэш таблицы в список. 

При возникновении коллизии в `HashMap` осуществляется проверка на наличие элемента в списке: `e.hash == hash && ((k = e.key) == key || key.equals(k))`. Если элемент найден, то его значение перезаписывается. В нашем случае для разных объектов метод `equals()` будет возвращать `false`. Соответственно новый элемент будет успешно добавлен в `HashSet`. Извлечение элемента также будет осуществляться успешно. Но производительность такого кода будет невысокой и преимущества хэш таблиц использоваться не будут.
+ [Вопрос#5.15  К оглавлению](#OOPInJava)

## Могут ли у разных объектов `(ref0 != ref1)` быть `ref0.equals(ref1) == true`?
Да, могут. Для этого в классе этих объектов должен быть переопределен метод `equals()`.

Если используется метод `Object.equals()`, то для двух ссылок `x` и `y` метод вернет `true` тогда и только тогда, когда обе ссылки указывают на один и тот же объект (т.е. `x == y` возвращает `true`).
+ [Вопрос#5.16  К оглавлению](#OOPInJava)

## Могут ли у разных ссылок на один объект `(ref0 == ref1)` быть `ref0.equals(ref1) == false`?
В общем случае - могут, если метод `equals()` реализован некорректно и не выполняет свойство рефлексивности: для любых ненулевых ссылок `x` метод `x.equals(x)` должен возвращать `true`.
+ [Вопрос#5.17  К оглавлению](#OOPInJava)

## Можно ли так реализовать метод `equals(Object that) {return this.hashCode() == that.hashCode()}`?
Строго говоря нельзя, поскольку метод `hashCode()` не гарантирует уникальность значения для каждого объекта. Однако для сравнения экземпляров класса `Object` такой код допустим, т.к. метод `hashCode()` в классе `Object` возвращает уникальные значения для разных объектов (его вычисление основано на использовании адреса объекта в памяти).
+ [Вопрос#5.18  К оглавлению](#OOPInJava)

## В `equals()` требуется проверять, что аргумент `equals(Object that)` такого же типа что и сам объект. В чем разница между `this.getClass() == that.getClass()` и `that instanceof MyClass`?
Оператор `instanceof` сравнивает объект и указанный тип. Его можно использовать для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.

`this.getClass() == that.getClass()` проверяет два класса на идентичность, поэтому для корректной реализации контракта метода `equals()` необходимо использовать точное сравнение с помощью метода `getClass()`.
+ [Вопрос#5.19  К оглавлению](#OOPInJava)

## Можно ли реализовать метод `equals()` класса `MyClass` вот так: `class MyClass {public boolean equals(MyClass that) {return this == that;}}`?
Реализовать можно, но данный метод не переопределяет метод `equals()` класса `Object`, а перегружает его.
+ [Вопрос#5.20  К оглавлению](#OOPInJava)

## Что такое `finalize()`? Зачем он нужен?
Через вызов метода `finalize()` (который наследуется от Java.lang.Object) JVM реализуется функциональность аналогичная функциональности деструкторов в С++, используемых для очистки памяти перед возвращением управления операционной системе. Данный метод вызывается при уничтожении объекта сборщиком мусора (_garbage collector_) и переопределяя `finalize()` можно запрограммировать действия необходимые для корректного удаления экземпляра класса - например, закрытие сетевых соединений, соединений с базой данных, снятие блокировок на файлы и т.д. 

После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это считается серьезной проблемой метода `finalize()` т.к. он мешает сборщику мусора освобождать память). Вызов этого метода не гарантируется, т.к. приложение может быть завершено до того, как будет запущена сборка мусора.

Объект не обязательно будет доступен для сборки сразу же - метод `finalize()` может сохранить куда-нибудь ссылку на объект. Подобная ситуация называется «возрождением» объекта и считается антипаттерном. Главная проблема такого трюка - в том, что «возродить» объект можно только 1 раз.

Пример:
```java
public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		a.a();
		a = null;
		a = new TestClass();
		a.a();
		System.out.println("!!! done");
	}
}
```
```java

public class TestClass {

	public void a() {
		System.out.println("!!! a() called");
	}

	@Override
	protected void finalize() throws Throwable {
		System.out.println("!!! finalize() called");
		super.finalize();
	}
}
```
Так как в данном случае сборщик мусора может и не быть вызван (в силу простоты приложения), то результат выполнения программы с большой вероятностью будет следующий:
```
!!! a() called
!!! a() called
!!! done
```
Теперь несколько усложним программу, добавив принудительный вызов Garbage Collector:
```java
public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		a.a();
		a = null;
		System.gc(); // Принудительно зовём сборщик мусора
		a = new TestClass();
		a.a();
		System.out.println("!!! done");
	}

}
```
Как и было сказано ранее, Garbage Collector может в разное время отработать, поэтому результат выполнения может разниться от запуска к запуску:
Вариант а:
```
!!! a() called
!!! a() called
!!! done
!!! finalize() called
```
Вариант б:
```
!!! a() called
!!! a() called
!!! finalize() called
!!! done
```
+ [Вопрос#5.21  К оглавлению](#OOPInJava)




## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ

+ [История эволюции интерфейсов в Java (2019)-->]( https://habr.com/ru/post/482498/ )
+ [Как сгенерировать hashCode в Java-->]( http://www.seostella.com/ru/article/2012/10/04/kak-sgenerirovat-hashcode-v-java.html )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )


+ [к оглавлению](#OOPInJava)
