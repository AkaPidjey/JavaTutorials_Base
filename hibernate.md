[Java Tutorials](README.md)

# Hibernate

## JPA & Hibernet
1) [Что такое ORM? Что такое JPA? Что такое Hibernate?](#Что-такое-ORM-Что-такое-JPA-Что-такое-Hibernate)
2) [Назовите интерфейсы Hibernate?](#Назовите-интерфейсы-Hibernate)
3) [Чем HQL отличается от SQL?](#Чем-HQL-отличается-от-SQL)
4) [Какие можно устанавливать параметры в hbm2ddl?](#Какие-можно-устанавливать-параметры-в-hbm2ddl)
5) [Можно ли использовать JPA c noSQl базами?](#Можно-ли-использовать-JPA-c-noSQl-базами)
6) [В чем отличие JPA от JDO?](#В-чем-отличие-JPA-от-JDO)
7) [Что делает пустой конструктор и для чего он нужен?](#Что-делает-пустой-конструктор-и-для-чего-он-нужен)
8) [Стратегия генерации первичных ключей?](#Стратегия-генерации-первичных-ключей)
9) [Что такое `EntityManager`? Какие функции он выполняет?](#Что-такое-EntityManager-Какие-функции-он-выполняет)
10) [Что такое Entity?](#Что-такое-Entity)
11) [Какие требования JPA к Entity классам вы можете перечислить?](#Какие-требования-JPA-к-Entity-классам-вы-можете-перечислить)
12) [Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можите перечислить?](#Какие-четыре-статуса-жизненного-цикла-Entity-объекта-вы-можите-перечислить)
13) [Перечислите два типа доступа (access) к элементам Entity классов.?](#перечислите-два-типа-доступа-access-к-элементам-Entity-классов)
14) [Какие типы данных допустимы в атрибутах Entity класса (полях или свойствах)?](#Какие-типы-данных-допустимы-в-атрибутах-Entity-класса-полях-или-свойствах)
15) [Какие типы данных можно использовать в атрибутах, входящих в первичный ключ Entity класса ?](#Какие-типы-данных-можно-использовать-в-атрибутах-входящих-в-первичный-ключ-Entity-класса)
16) [Как влияет операция `persist`, `remove`, `merge`, `refresh`, `detach` на Entity объекты каждого из четырех статусов?](#Как-влияет-операция-persist-remove-merge-refresh-detach-на-Entity-объекты-каждого-из-четырех-статусов)
17) [Что такое встраиваемый (Embeddable) класс? Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?](#Что-такое-встраиваемый-Embeddable-класс-Какие-требования-JPA-устанавливает-к-встраиваемым-Embeddable-классам)
18) [Что такое Mapped Superclass?](#Что-такое-Mapped-Superclass)
19) [Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?](#Какие-три-типа-стратегий-наследования-мапинга-Inheritance-Mapping-Strategies-описаны-в-JPA)
20) [Как мапятся Enum'ы?](#Как-мапятся-Enum'ы)
21) [Как мапятся даты (до java 8 и после)?](#Как-мапятся-даты-до-java-8-и-после)
22) [Как “смапить” коллекцию примитивов?](#Как-смапить-коллекцию-примитивов)
23) [Какие есть виды связей?](#Какие-есть-виды-связей)
24) [Что такое владелец связи?](#Что-такое-владелец-связи)
25) [Что такое каскады?](#Что-такое-каскады)
26) [Разница между PERSIST и MERGE?](#Разница-между-PERSIST-и-MERGE)
27) [Какие два типа fetch стратегии в JPA вы знаете?](#Какие-два-типа-fetch-стратегии-в-JPA-вы-знаете)
28) [Назовите аннотации Hibernate?](#Назовите-аннотации-Hibernate)
29) [Для чего нужна аннотация Basic?](#Для-чего-нужна-аннотация-Basic)
30) [Для чего нужна аннотация Column?](#Для-чего-нужна-аннотация-Column)
31) [Для чего нужна аннотация Access?](#Для-чего-нужна-аннотация-Access)
32) [Для чего нужна аннотация @Cacheable?](#Для-чего-нужна-аннотация-Cacheable)
33) [Для чего нужна аннотация @Cache?](#Для-чего-нужна-аннотация-Cache)
34) [Для чего нужны аннотации @Embedded и @Embeddable?](#Для-чего-нужны-аннотации-Embedded-и-Embeddable)
35) [Как смапить составной ключ?](#Как-смапить-составной-ключ)
36) [Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?](#Для-чего-нужна-аннотаци-ID-Какие-GeneratedValue-вы-знаете)
37) [Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?](#Расскажите-про-аннотации-JoinColumn-и-JoinTable-Где-и-для-чего-они-используются)
38) [Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?](#Для-чего-нужны-аннотации-OrderBy-и-OrderColumn-чем-они-отличаются)
39) [Для чего нужна аннотация @Transient?](#Для-чего-нужна-аннотация-Transient)
40) [Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?](#Какие-шесть-видов-блокировок-lock-описаны-в-спецификации-JPA-или-какие-есть-значения-у-enum-LockModeType-в-JPA)
41) [Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?](#Какие-два-вида-кэшей-cache-вы-знаете-в-JPA-и-для-чего-они-нужны)
42) [Как работать с кешем 2 уровня?](#Как-работать-с-кешем-2-уровня)
43) [Что такое JPQL/HQL и чем он отличается от SQL?](#Что-такое-JPQL/HQL-и-чем-он-отличается-от-SQL)
44) [Что такое Criteria API и для чего он используется?](#Что-такое-Criteria-API-и-для-чего-он-используется)
45) [Расскажите про проблему N+1 Select и путях ее решения.](#Расскажите-про-проблему-N+1-Select-и-путях-ее-решения)
46) [Что такое EntityGraph? Как и для чего их использовать?](#Что-такое-EntityGraph-Как-и-для-чего-их-использовать)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)

+ [К оглавлению](#hibernate)


## Что такое ORM? Что такое JPA? Что такое Hibernate?
+ __ORM — Object-Relational Mapping или в переводе на русский объектно-реляционное отображение__. Это технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования. Если упростить, то ORM это связь Java объектов и записей в БД.
+ ORM — это по сути концепция о том, что Java объект можно представить как данные в БД (и наоборот). Она нашла воплощение в виде спецификации JPA — Java Persistence API.
+ 
+ __JPA (Java Persistence API)__ это спецификация Java EE и Java SE, описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде. Сама Java не содержит реализации JPA, однако есть существует много реализаций данной спецификации от разных компаний (открытых и нет). Это не единственный способ сохранения java объектов в базы данных (ORM систем), но один из самых популярных в Java мире. 

__JPA состоит из 3 основных пунктов:__
+ __API__ интерфейсы в пакете `javax.persistance`. Набор интерфейсов, которые позволяют взаимодействовать с ORM провайдером.
+ __JPQL__ объектный язык запросов. Очень похож на SQL, но запросы выполняются к объектам.
+ __Metadata__ аннотации над объектами. Набор аннотаций, которыми мы описываем метаданные отображения. Тогда уже JPA знает какой объект в какую таблицу нужно сохранить. Метаданные можно описывать 2 способами: XML-файлом или через аннотации.

+ __Hibernate__ —Это одна из наиболее популярных реализаций ORM-модели. Объектно-реляционная модель описывает отношения между программными объектами и записями в БД. Это  фреймворк библиотека, которая предназначена для задач объектно-реляционного отображения. Если простыми словами —  hibernate позволяет разработчику работать с базой данных не напрямую, как мы это делали с помощью библиотеки JDBC, а  с помощью представления таблиц баз данных в виде классов java.

__Важные интерфейсы Hibernate:__
+ `Session` - обеспечивает физическое соединение между приложением и БД. Основная функция - предлагать DML-операции для экземпляров сущностей.
+ `SessionFactory` - это фабрика для объектов `Session`. Обычно создается во время запуска приложения и сохраняется для последующего использования. Является потокобезопасным объектом и используется всеми потоками приложения.
+ `Transaction` - однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC транзакций. `Session` может занимать несколько `Transaction` в определенных случаях, является необязательным API. 
+ `Query` - интерфейс позволяет выполнять запросы к БД. Запросы написаны на HQL или на SQL.

В чем разница между JPA и Hibernate? Как связаны все эти понятия?
Hibernate одна из самых популярных открытых реализаций последней версии спецификации (JPA 2.1). Даже скорее самая популярная, почти стандарт де-факто. То есть JPA только описывает правила и API, а Hibernate реализует эти описания, впрочем у Hibernate (как и у многих других реализаций JPA) есть дополнительные возможности, не описанные в JPA (и не переносимые на другие реализации JPA).
+ [Вопрос# 1 К оглавлению](#hibernate)


## Назовите интерфейсы Hibernate?
Существует пять ключевых интерфейсов которые используются в каждом приложении связанном с Hibernate:
+ Session interface;
+ SessionFactory interface;
+ Configuration interface;
+ Transaction interface;
+ Query and Criteria interfaces.

+ SessionFactory (org.hibernate.SessionFactory) – неизменяемый потокобезопасный объект с компилированным маппингом для одной базы данных. Необходимо инициализировать SessionFactory всего один раз. Экземпляр SessionFactory используется для получения объектов Session, которые используются для операций с базами данных.
+ Session (org.hibernate.Session) – однопоточный короткоживущий объект, который предоставляет связь между объектами приложения и базой данных. Он оборачивает JDBC java.sql.Connection и работает как фабрика для org.hibernate.Transaction. Разработчик должен открывать сессию по необходимости и закрывать ее сразу после использования. Экземпляр Session является интерфейсом между кодом в java приложении и hibernate framework и предоставляет методы для операций CRUD.
+ Transaction (org.hibernate.Transaction) – однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC или JTA транзакций. org.hibernate.Session может занимать несколько org.hibernate.Transaction в определенных случаях.

+ [Вопрос# 2 К оглавлению](#hibernate)


## Чем HQL отличается от SQL?
__HQL (Hibernate Query Language)__ – это объекто-ориентированный язык запросов, который очень похож на SQL. Главное различие языков HQL и SQL связано с тем, что SQL формирует запросы из наименований таблиц в базе данных и их столбцов, а HQL работает с сущностями (классами) и их полями (аттрибутами класса).

Hibernate транслирует HQL–запросы в понятные для БД SQL–запросы, которые и выполняют необходимые действия в БД.
+ [Язык запросов HQL-->]( http://java-online.ru/hibernate-hql.xhtml )

+ [Вопрос# 3 К оглавлению](#hibernate)


## Какие можно устанавливать параметры в hbm2ddl?
hibernate.hbm2ddl.auto Автоматически проверяет или экспортирует DDL схемы в базу данных при создании SessionFactory. С помощью create-drop схема базы данных будет удалена, когда SessionFactory будет закрыт явно.

Итак, список возможных вариантов:
+ __validate__ : проверяет схему, не вносит изменений в базу данных.
+ __update__ : обновить схему.
+ __create__ : создает схему, уничтожая предыдущие данные.
+ __create-drop__ : удалить схему при явном закрытии SessionFactory, обычно при остановке приложения.
+ __none__ - действие не выполняется. Схема не будет сгенерирована.
+ __create-only__ - Схема базы данных будет сгенерирована.
+ __drop__ - Схема базы данных будет удалена и впоследствии создана.

+ [Вопрос# 4 К оглавлению](#hibernate)


## Можно ли использовать JPA c noSQl базами?
Вообще, спецификация JPA говорит только о отображении java объектов в таблицы реляционных баз данных, но при этом существует ряд реализаций данного стандарта для noSql баз данных: Kundera, DataNucleus, ObjectDB и ряд других. Естественно, при это не все специфичные для реляционных баз данных особенности спецификации переносятся при этом на nosql базы полностью.
+ [Вопрос# 5 К оглавлению](#hibernate)


## В чем отличие JPA от JDO?
JPA (Java Persistence API) и Java Data Objects (JDO) две спецификации сохранения java объектов в базах данных. Если JPA сконцентрирована только на реляционных базах, то JDO более общая спецификация которая описывает ORM для любых возможных баз и хранилищ. В принципе можно рассматривать JPA как специализированную на релятивистских баз часть спецификации JDO, даже при том что API этих двух спецификаций не полностью совпадает. Также отличаются «разработчики» спецификаций — если JPA разрабатывается как JSR, то JDO сначала разрабатывался как JSR, теперь разрабатывается как проект Apache JDO.
+ [Вопрос# 6 К оглавлению](#hibernate)


## Что делает пустой конструктор и для чего он нужен?
Спящий режим и код в целом, который создает объекты через отражение, использует Class<T>.newInstance(), чтобы создать новый экземпляр ваших классов. Этот метод требует, чтобы публичный конструктор no-arg мог создавать экземпляр объекта. Для большинства случаев использование конструктора no-arg не является проблемой.
Существуют хаки, основанные на сериализации, которые могут работать без создания конструктора no-arg, поскольку сериализация использует jvm magic для создания объектов без вызова конструктора. Но это не доступно для всех виртуальных машин. Например, XStream может создавать экземпляры объектов, у которых нет открытого конструктора no-arg, но только путем запуска в так называемом "так называемый" расширенный" режим, который доступен только на некоторых виртуальных машинах. (Подробнее см. Ссылку). Дизайнеры Hibernate, безусловно, решили поддерживать совместимость со всеми виртуальными машинами и поэтому избегают таких трюков и используют официально поддерживаемый метод отражения Class<T>.newInstance(), требующий конструктора no-arg.
+ [Вопрос# 7 К оглавлению](#hibernate)


## Стратегия генерации первичных ключей?
В JPA на этот случай предсмотрены механизмы автоматической генерации значений суррогатных ключей, которые включается аннотацией @GeneratedValue
Есть 4 стратегии генерации:
+ @GeneratedValue(strategy = GenerationType.AUTO)
+ GenerationType.IDENTITY - работает с базами, у которых есть специальные IDENTITY поля, например с MySQL или DB2. В этом случае, для примера выше, таблицу необходимо было бы создавать.
+ GenerationType.SEQUENCE - использует встроенный в базы данных, такие как PostgreSQL или Oracle, механизм генерации последовательных значений (sequence). Использование этого генератора требует как создания отдельной sequence в базе данных.
+ enerationType.TABLE - не зависит от поддержки конкретной базой данных и хранит счётчики значений в отдельной таблице. С одной стороны это более гибкое и настраиваемое решение, с другой стороны более медленное и требующее большей настройки. Вначале требуется создать (вручную!) и проинициализировать (!) таблицу для значений ключей

Подробнее #### [Первичные ключи в JPA-->]( https://easyjava.ru/data/jpa/pervichnye-klyuchi-v-jpa/ )
+ [Вопрос# 8 К оглавлению](#hibernate)


## Что такое EntityManager? Какие функции он выполняет?
__EntityManager интерфейс JPA__, который описывает API для всех основных операций над `Entity`, а также для получения данных и других сущностей JPA. 

 Это интерфейс `JPA`, используемый для взаимодействия с персистентным контекстом. `EntityManager` описывает API для всех основных операций над `Entity`, а также для получения данных и других сущностей JPA. По сути - главный API для работы с JPA.
Персистентный контекст - это набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции - это и есть кэш первого уровня. Внутри контекста персистентности происходит управление экземплярами сущностей и их жизненным циклом. `EntityManager` автоматически сохраняет в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода `flush()`.
Один или несколько `EntityManager` образуют или могут образовать `persistence context`.
Если проводить аналогию с обычным JDBC, то `EntityManagerFactory` будет аналогом `DataSource`, а `EntityManager` аналогом `Connection`.
Интерфейс `Session` из `Hibernate` представлен в JPA как раз интерфейсом `EntityManager`.

 __Основные функции EntityManager:__
 1) Операции над Entity: `persist` (добавление Entity), `merge` (обновление), `remove` (удаления), `refresh` (обновление данных), `detach` (удаление из управление JPA), `lock` (блокирование Entity от изменений в других thread),
 2) Получение данных: `find` (поиск и получение Entity), `createQuery`, `createNamedQuery`, `createNativeQuery`, `contains`, `createNamedStoredProcedureQuery`, `createStoredProcedureQuery`
 3) Получение других сущностей JPA: `getTransaction`, `getEntityManagerFactory`, `getCriteriaBuilder`, `getMetamodel`, `getDelegate`
 4) Работа с `EntityGraph`: `createEntityGraph`, `getEntityGraph`
 5) Общие операции над `EntityManager` или всеми `Entities`: `close`, `clear`, `isOpen`, `getProperties`, `setProperty`.
Объекты `EntityManager` не являются потокобезопасными. Это означает, что каждый поток должен получить свой экземпляр `EntityManager`, поработать с ним и закрыть его в конце.

+ [Вопрос# 9 К оглавлению](#hibernate)


## Что такое Entity?
__Entity__ это легковесный хранимый объект бизнес логики (persistent domain object). Основная программная сущность это entity класс, который так же может использовать дополнительные классы, который могут использоваться как вспомогательные классы или для сохранения состояния еntity.
+ Может ли Entity класс наследоваться от не Entity классов? --> Может
+ Может ли не Entity класс наследоваться от Entity класса? --> Да
+ Может ли Entity быть абстрактным классом? --> Может, при этом он сохраняет все свойства Entity, за исключением того что его нельзя непосредственно инициализировать.

+ [Вопрос# 10 К оглавлению](#hibernate)


## Какие требования JPA к Entity классам вы можете перечислить?
 
__Entity__ 
Сущность (`entity`) - это объект персистентной области. Как правило, сущность представляет таблицу в реляционной базе данных, и каждый экземпляр сущности соответствует строке в этой таблице. Основным программным представлением сущности является класс сущности. Класс сущности может использовать другие классы, которые служат вспомогательными классами или используются для представления состояния сущности (например `embedded`).
Персистентное состояние сущности представлено персистентными полями или персистентными свойствами.
Персистентное поле - поле сущности, которое отражается в БД в виде столбца таблицы.
Персистентное свойство - это методы, которые аннотированы вместо полей для доступа провайдера к ним (полям).
Эти поля или свойства используют аннотации объектно-реляционного сопоставления (маппинга) для сопоставления сущностей и отношений между ними с реляционными данными в хранилище данных. Примеры аннотаций: `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`.
Есть два вида доступа к состоянию сущности:
1)	Доступ по полю, когда аннотации стоят над полями. В этом случае провайдер, например, `Hibernate`, обращается к полям класса напрямую, используя `Reflection`.
2)	Доступ по свойству, когда аннотации стоят над методами-геттерами. В этом случае провайдер, например, `Hibernate`, обращается к полям класса через методы.
В JPA принято называть эти персистентные поля и свойства атрибутами класса-сущности.

__Требования к `Entity` классу в JPA:__
1)	`Entity` класс должен быть помечен аннотацией `@Entity` или описан в XML файле конфигурации JPA.
2)	`Entity` класс должен содержать `public` или `protected` конструктор без аргументов (он также может иметь конструкторы с аргументами).
3)	`Entity` класс должен быть классом верхнего уровня (top-level class).
4)	Перечисление `enum` или интерфейс `interface` не могут быть определены как сущность `Entity`.
5)	`Entity` класс не может быть финальным классом (`final class`). `Entity` класс не может содержать финальные поля или методы, если они участвуют в маппинге (`persistent final methods or persistent final instance variables`).
6)	Если объект `Entity` класса будет передаваться по значению как отделённый от контекста персистентности объект (`detached object`), например через удаленный интерфейс (`through a remote interface`), то он также должен реализовывать интерфейс `Serializable`.
7)	Как обычный так и абстрактный класс может быть `Entity`. `Entities` могут наследоваться как от не `Entity` классов, так и от `Entity` классов. А не `Entity` классы могут наследоваться от `Entity` классов.
8)	Поля `Entity` класса должны быть объявлены `private`, `protected` или `package-private`, быть напрямую доступными только методам самого `Entity` класса и не должны быть напрямую доступны другим классам, использующим этот `Entity`. Другие классы должны обращаться только к специальным методам `Entity` класса, предоставляющим доступ к этим полям (`getter/setter-методам` или другим методам бизнес-логики в `Entity` классе).
9)	`Entity` класс должен содержать первичный ключ, то есть атрибут или группу атрибутов, которые уникально определяют запись этого `Entity` класса в базе данных.

__Требования к `Entity` классу в `Hibernate`:__
`Hibernate` не так строг в своих требованиях. Вот отличия от требований JPA:
❖	Класс сущности должен иметь конструктор без аргументов, который может быть не только `public` или `protected`, но и `package visibility`.
❖	Класс сущности не обязательно должен быть классом верхнего уровня.
❖	Технически `Hibernate` может сохранять финальные классы или классы с финальными методами (`getter / setter`). Однако, как правило, это не очень хорошая идея, так как это лишит `Hibernate` возможности генерировать прокси для отложенной загрузки сущности.
❖	`Hibernate` не запрещает разработчику приложения открывать прямой доступ к переменным экземпляра и ссылаться на них извне класса сущности. Однако обоснованность такого подхода спорна.

+ [Вопрос# 11 К оглавлению](#hibernate)


## Какие четыре статуса жизненного цикла Entity объекта вы можите перечислить?
У Entity объекта существует четыре статуса жизненного цикла: transient(new), managed, detached, или removed. Их описание
+ __transient(new)__ — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных.
+ __managed__ — объект создан, управляется JPA, имеет сгенерированные первичные ключи.
+ __detached__ — объект создан, не управляется JPA. В этом состоянии сущность не связана со своим контекстом (отделена от него) и нет экземпляра `Session`, который бы ей управлял.
+ __removed__ — объект создан, управляется JPA, будет удален при commit-е и статус станет опять detached

+ [Вопрос# 12 К оглавлению](#hibernate)


## Перечислите два типа доступа (access) к элементам Entity классов.
JPA указывает что она может работать как с свойствами классов (property), оформленные в стиле JavaBeans, либо с полями (field), то есть переменными класса (instance variables). Соответственно, при этом тип доступа будет либо property access или field access. Оба типа элементов Entity класса называются атрибутами Entity класса.
+ [Вопрос# 13 К оглавлению](#hibernate)


## Какие типы данных допустимы в атрибутах Entity класса (полях или свойствах)?
Допустимые типы атрибутов у Entity классов:
+ 1- примитивные типы и их обертки Java.
+ 2- строки.
+ 3- любые сериализуемые типы Java (реализующие Serializable интерфейс).
+ 4- enums.
+ 5- entity types.
+ 6- embeddable классы.
+ 7- и коллекции типов 1-6.

+ [Вопрос# 14 К оглавлению](#hibernate)


## Какие типы данных можно использовать в атрибутах, входящих в первичный ключ Entity класса ?
Допустимые типы атрибутов, входящих в первичный ключ:
+ 1- примитивные типы и их обертки Java.
+ 2- строки.
+ 3- BigDecimal и BigInteger.
+ 4- java.util.Date и java.sql.Date.

В случае автогенерируемого первичного ключа (generated primary keys) допустимы
+ 1- только числовые типы.

В случае использования других типов данных в первичном ключе, он может работать только для некоторых баз данных, т.е. становится не переносимым (not portable),
+ [Вопрос# 15 К оглавлению](#hibernate)


## Как влияет операция persist, remove, merge, refresh, detach на Entity объекты каждого из четырех статусов?
__PERSIST:__
1) Если статус Entity `new`, то он меняется на `managed` и объект будет сохранен в базу при commit'е транзакции или в результате flush операций.
2) Если статус уже `managed`, операция игнорируется, однако зависимые Entity могут поменять статус на `managed`, если у них есть аннотации каскадных изменений.
3) Если статус `remove`d, то он меняется на `managed`.
4) Если статус `detached`, будет выкинут exception сразу или на этапе commit'а транзакции.

__REMOVE:__
1) Если статус Entity `new`, операция игнорируется, однако зависимые Entity могут поменять статус на `removed`, если у них есть аннотации каскадных изменений и они имели статус `managed`.
2) Если статус `managed`, то статус меняется на `removed` и запись объект в базе данных будет удалена при commit'е транзакции (так же произойдут операции remove для всех каскадно зависимых объектов).
3) Если статус `removed`, то операция игнорируется.
4) Если статус `detached`, будет выкинут exception сразу или на этапе commit'а транзакции.

__MERGE:__
1) Если статус Entity `new`, то будет создана новый managed entity, в который будут скопированы данные прошлого объекта.
2) Если статус `managed`, операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если их статус не `managed`.
3) Если статус `removed`, будет выкинут exception сразу или на этапе commit'а транзакции.
4) Если статус `detached`, то либо данные будет скопированы в существующей managed entity с тем же первичным ключом, либо создан новый managed в который скопируются данные.

__REFRESH:__
1) Если статус Entity `managed`, то в результате операции будут востановлены все изменения из базы данных данного Entity, так же произойдет refresh всех каскадно зависимых объектов.
2) Если статус `new`, `removed` или `detached`, будет выкинут exception.

__DETACH:__
1) Если статус Entity `managed` или `removed`, то в результате операции статус Entity (и всех каскадно-зависимых объектов) станет `detached`.
2) Если статус `new` или `detached`, то операция игнорируется.

+ [Вопрос# 16 К оглавлению](#hibernate)


## Что такое встраиваемый `Embeddable` класс? Какие требования JPA устанавливает к встраиваемым `Embeddable` классам?
__Embeddable класс__ - это класс, который не используется сам по себе, а является частью одного или нескольких Entity-классов. Entity-класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity-класса и не может быть использован для передачи данных между объектами Entity-классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких `Entity`.

__Требования:__
1) Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией Entity
2) Embeddable класс должен быть помечен аннотацией @Embeddable или описан в XML файле конфигурации JPA. А поле этого класса в Entity аннотацией @Embedded

Embeddable-класс может содержать другой встраиваемый класс.

Встраиваемый класс может содержать связи с другими Entity или коллекциями Entity, если такой класс не используется как первичный ключ или ключ map'ы
+ [Вопрос# 17 К оглавлению](#hibernate)


## Что такое Mapped Superclass?
__Mapped Superclass__ - это класс, от которого наследуются `Entity`, он может содержать анотации JPA, однако сам такой класс не является `Entity`, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях `EntityManager` или `Query`. Такой класс должен быть отмечен аннотацией `@MappedSuperclass` или описан в xml файле.
Создание такого класса-предка оправдано тем, что мы заранее определяем ряд свойств и методов, которые должны быть определены в сущностях. Использование такого подхода позволило сократить количество кода.
+ [Вопрос# 18 К оглавлению](#hibernate)


## Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?
__Inheritance Mapping Strategies__ описывает как JPA будет работать с классами-наследниками Entity:
1) __Одна таблица на всю иерархию классов (SINGLE_TABLE)__ — все `entity`, со всеми наследниками записываются в одну таблицу, для идентификации типа `entity` определяется специальная колонка “discriminator column”. Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все `entity` записываются в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog». 
+ Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соотвественно.
+ Нельзя делать констраинт notNull, но можно использовать тригеры.
2) __Стратегия «соединения» (JOINED)__ — в этой стратегии каждый класс `entity` сохраняет данные в свою таблицу, но только уникальные поля (не унаследованные от классов-предков) и первичный ключ, а все унаследованные колонки записываются в таблицы класса-предка, дополнительно устанавливается связь (relationships) между этими таблицами, например в случае классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. 
+ Минусом тут являются потери производительности от объединения таблиц (join) для любых операций.
3) __Таблица для каждого класса (TABLE_PER_CLASS)__ — каждый отдельный класс-наследник имеет свою таблицу, т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. 
+ Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса.

Для задания стратегии наследования используется аннотация @Inheritance (или соответствующие блоки)
+ [Вопрос# 19 К оглавлению](#hibernate)


## Как мапятся Enum'ы?
@Enumerated(EnumType.STRING) - означает, что в базе будут храниться имена Enum.
@Enumerated(EnumType.ORDINAL) - в базе будут храниться порядковые номера Enum.

Другой вариант - мы можем смапить наши enum в БД и обратно в методах с аннотациями @PostLoad и @PrePersist. @EntityListener над классом Entity, в которой указать класс, в котором создать два метода, помеченнх этими аннотациями.
Идея в том, чтобы в сущности иметь не только поле с Enum, но и вспомогательное поле. Поле с Enum аннотируем @Transient, а в БД будет храниться значение из вспомогательного поля. 

В JPA с версии 2.1 можно использовать Converter для конвертации Enum’а в некое его значение для сохранения в БД и получения из БД. Все, что нам нужно сделать, это создать новый класс, который реализует `javax.persistence.AttributeConverter` и аннотировать его с помощью @Converter и поле в сущности аннотацией @Convert.
+ [Вопрос# 20 К оглавлению](#hibernate)


## Как мапятся даты (до java 8 и после)?
Аннотация @Temporal до Java 8, в которой надо было указать какой тип даты мы хотим использовать.
В Java 8 и далее аннотацию ставить не нужно.
+ [Вопрос# 21 К оглавлению](#hibernate)


## Как “смапить” коллекцию примитивов?
+ @ElementCollection
+ @OrderBy
Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities). Если у нашей сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов для этих случаев в JPA имеется специальная аннотация @ElementCollection, которая указывается в классе сущности над полем коллекции. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов.
При добавлении новой строки в коллекцию, она полностью очищается и заполняется заного, так как у элементов нет id. Можно решить с помощью 
+ @OrderColumn
+ @CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать

+ [Вопрос# 22 К оглавлению](#hibernate)


## Какие есть виды связей?
__Существуют 4 типа связей:__
1) __OneToOne__ - когда один экземпляр `Entity` может быть связан не больше чем с одним экземпляром другого `Entity`.
2) __OneToMany__ - когда один экземпляр `Entity` может быть связан с несколькими экземплярами других `Entity`.
3) __ManyToOne__ - обратная связь для `OneToMany`. Несколько экземпляров `Entity` могут быть связаны с одним экземпляром другого `Entity`.
4) __ManyToMany__ - экземпляры `Entity` могут быть связаны с несколькими экземплярами друг друга.

Каждую из которых можно разделить ещё на два вида:
1) __Bidirectional__ с использованием mappedBy на стороне, где указывается `@OneToMany`
2) __Unidirectional__

__Bidirectional__ — ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).
__Undirectional__- ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.
+ [Вопрос# 23 К оглавлению](#hibernate)


## Что такое владелец связи?
В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.
По сути, у кого есть внешний ключ на другую сущность - тот и владелец связи. То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.
В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.
+ [Вопрос# 24 К оглавлению](#hibernate)


## Что такое каскады?
__Каскадирование__ - это когда мы выполняем какое-то действие с целевой `Entity`, то же самое действие будет применено к связанной `Entity`.
__JPA CascadeType:__
+ __ALL__ -  гарантируют, что все персистентные события, которые происходят на родительском объекте, будут переданы дочернему объекту.
+ __PERSIST__ -  означает, что операции save () или persist () каскадно передаются связанным объектам.
+ __MERGE__ - означает, что связанные `entity` объединяются, когда объединяется entity-владелец.

+ [Вопрос# 25 К оглавлению](#hibernate)


## Разница между PERSIST и MERGE?
+ persist(entity) следует использовать с совершенно новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, будет выброшено исключение EntityExistsException).
+ Но в случае merge(entity) сущность, которая уже управляется в контексте персистентности, будет заменена новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Но рекомендуется использовать для уже сохраненных сущностей.

+ [Вопрос# 26 К оглавлению](#hibernate)


## Какие два типа fetch стратегии в JPA вы знаете?
1) __LAZY__ — Hibernate может загружать данные не сразу, а при первом обращении к ним, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и @ElementCollection. В объект загружается прокси lazy-поля.
2) __EAGER__ — данные поля будут загруженны немедленно. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.

+ [Вопрос# 27 К оглавлению](#hibernate)


## Назовите аннотации Hibernate?
Рассмотрим аннотации, которые используются в стандарте JPA и в различных фреймворках вроде Hibernate.
+ @Entity	javax.persistence.Entity   – Указывает, что данный бин (класс) является сущностью.
+ @Table	javax.persistence.Table   – указывает на имя таблицы, которая будет отображаться в этой сущности.
+ @Column	javax.persistence.Table  – указывает на имя колонки, которая отображается в свойство сущности.
+ @Id	javax.persistence.Id   – id колонки
+ @GeneratedValue	javax.persistence.GeneratedValue   – указывает, что данное свойство будет создаваться согласно указанной стратегии
+ @Version	javax.persistence.Version   – управление версией в записи сущности. При изменении записи увеличится на 1.
+ @OrderBy	javax.persistence.OrderBy   – указание сортировки. В примере множество кошек будет отсортировано по имени по возрастанию
+ @Transient	javax.persistence.Transient   – указывает, что свойство не нужно записывать. Значения под этой аннотацией не записываются в базу данных (так же не участвуют в сериализации). static и final переменные экземпляра всегда transient.
+ @Lob	javax.persistence.Lob   – указание на большие объекты.
+ @PersistenceContext	javax.persistence.PersistenceContext   – указывает на зависимость EntityManager в контейнере
+ @Temporal	javax.persistence.TemporalType   – применяется к полям или свойствам с типом java.util.Date и java.util.Calendar. Например, если в БД время сохраняется как sql.Date, то чтобы использовать дату из java.util.Date указываем эту аннотацию.
+ @Embedded	javax.persistence.Embedded   – Определяет класс, экземпляры которого хранятся как неотъемлемая часть исходного объекта. Каждый из @Embedded экземпляров сопоставляется с таблицей базы данных сущности.

Аннотации для связи ассоциаций
+ @OneToOne	javax.persistence.OneToOne
+ @ManyToOne	javax.persistence.ManyToOne
+ @OneToMany	javax.persistence.OneToMany
+ @ManyToMany	javax.persistence.ManyToMany
+ @PrimaryKeyJoinColumn	javax.persistence.PrimaryKeyJoinColumn
+ @JoinColumn	javax.persistence.PrimaryKeyJoinColumn
+ @JoinTable	javax.persistence.JoinTable
+ @MapsId	javax.persistence.MapsId

Аннотации наследования
+ @Inheritance	javax.persistence.Inheritance
+ @DiscriminatorColumn	javax.persistence.DiscriminatorColumn
+ @DiscriminatorValue	javax.persistence.DiscriminatorValue

Аннотации запросов
+ @NamedQueries	javax.persistence.NamedQueries
+ @NamedQuery	javax.persistence.NamedQuery
+ @SqlResultSetMapping	javax.persistence.SqlResultSetMapping
+ @EntityResult	javax.persistence.EntityResult

Аннотации Hibernate
+ @Audited	org.hibernate.envers.Audited
+ @NotAudited	org.hibernate.envers.NotAudited
+ @Type	org.hibernate.annotations.Type

+ [Аннотации Java для работы с базой данных-->]( https://javastudy.ru/spring-data-jpa/annotation-persistence/ )

+ [Вопрос# 28 К оглавлению](#hibernate)


## Для чего нужна аннотация Basic?
__@Basic__ - указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. Может быть применена к полю любого из следующих типов:
1. Примитивы и их обертки.
2. java.lang.String
3. java.math.BigInteger
4. java.math.BigDecimal
5. java.util.Date
6. java.util.Calendar
7. java.sql.Date
8. java.sql.Time
9. java.sql.Timestamp
10. byte[] or Byte[]
11. char[] or Character[]
12. enums
13. любые другие типы, которые реализуют Serializable.
Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию.

__Аннотация @Basic определяет 2 атрибута:__
1. __optional - boolean (по умолчанию true)__ - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение.

2. __fetch - FetchType (по умолчанию EAGER)__ - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка.

Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null
+ [Вопрос# 29 К оглавлению](#hibernate)


## Для чего нужна аннотация Column?
__@Column__ сопоставляет поле класса столбцу таблицы, а её атрибуты определяют поведение в этом столбце, используется для генерации схемы базы данных

__@Basic vs @Column:__
1. Атрибуты `@Basic` применяются к сущностям JPA, тогда как атрибуты `@Column` применяются к столбцам базы данных.
2. `@Basic` имеет атрибут `optional`, который говорит о том, может ли поле объекта быть null или нет; с другой стороны атрибут `nullable` аннотации `@Column` указывает, может ли соответствующий столбец в таблице быть null.
3. Мы можем использовать `@Basic`, чтобы указать, что поле должно быть загружено лениво.
4. Аннотация `@Column` позволяет нам указать имя столбца в таблице и ряд других свойств:
 a. insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;
 b. length - длина, для строковых типов данных, по умолчанию 255.
Коротко, в Column (колум) мы задаем constraints (констрейнтс), а в Basic (бейсик) - ФЕТЧ ТАЙП

+ [Вопрос# 30 К оглавлению](#hibernate)


## Для чего нужна аннотация Access?
Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода:
1. __Field access (доступ по полям).__ При таком способе аннотации маппинга (Id, Column,...) размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их.
2. __Property access (доступ по свойствам).__ При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами.

По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. Если она будет над полем - это будет `AccessType.FIELD`, если над геттером - это `AccessType.PROPERTY`.
Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию `@Access`, которая может быть указана у сущности, Mapped Superclass и Embeddable class, а также над полями или методами.
Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса.
Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.
+ [Вопрос# 31 К оглавлению](#hibernate)


## Для чего нужна аннотация @Cacheable?
__@Cacheable__ - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня. JPA говорит о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:

+ __ENABLE_SELECTIVE:__ только сущности с аннотацией `@Cacheable` (равносильно значению по умолчанию @Cacheable(value=true)) будут сохраняться в кэше второго уровня.
+ __DISABLE_SELECTIVE:__ все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных @Cacheable(value=false) как некэшируемые.
+ __ALL:__ сущности всегда кэшируются, даже если они помечены как некэшируемые.
+ __NONE:__ ни одна сущность не кэшируется, даже если помечена как кэшируемая. При данной опции имеет смысл вообще отключить кэш второго уровня.
+ __UNSPECIFIED:__ применяются значения по умолчанию для кэша второго уровня, определенные Hibernate. Это эквивалентно тому, что вообще не используется shared-cache-mode, так как Hibernate не включает кэш второго уровня, если используется режим `UNSPECIFIED`.

Аннотация `@Cacheable` размещается над классом сущности. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.
+ [Вопрос# 32 К оглавлению](#hibernate)


## Для чего нужна аннотация @Cache?
Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate. 
__@Cache принимает три параметра:__
1) __include__ - имеет по умолчанию значение all и означающий кэширование всего объекта. Второе возможное значение - non-lazy, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.
2) __region__ - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша. Например, можно было бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные - во второй. Ehcache по умолчанию создает регион для каждой сущности с именем класса этой сущности, соответственно в этом регионе хранятся только эти сущности. К примеру, экземпляры Foo хранятся в Ehcache в кэше с именем “com.baeldung.hibernate.cache.model.Foo”.
3) __usage__ - задаёт стратегию одновременного доступа к объектам.
transactional
read-write
nonstrict-read-write
read-only
+ [Вопрос# 33 К оглавлению](#hibernate)


## Для чего нужны аннотации @Embedded и @Embeddable?
+ __@Embeddable__ - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.
+ __@Embedded__ - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.

+ [Вопрос# 34 К оглавлению](#hibernate)


## Как смапить составной ключ?
Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы.

@IdClass
Допустим, у нас есть таблица с именем Account, и она имеет два столбца - accountNumber и accountType, которые формируют составной ключ. Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, ComplexKey с этими полями.

Затем нам нужно аннотировать сущность Account аннотацией @IdClass(ComplexKey.class). Мы также должны объявить поля из класса ComplexKey в сущности Account с такими же именами и аннотировать их с помощью @Id.

@EmbeddedId
Рассмотрим пример, в котором мы должны сохранить некоторую информацию о книге с заголовком и языком в качестве полей первичного ключа. В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable.
Затем нам нужно встроить этот класс в сущность Book, используя @EmbeddedId.

```java
@Embeddable
public class BookId implements Serializable {
    private String title;
    private String language;
    // default constructor
    public BookId(String title, String language) {
        this.title = title;
        this.language = language;
    }
    // getters, equals() and hashCode() methods
}
@Entity
public class Book {
    @EmbeddedId
    private BookId bookId;
    // constructors, other fields, getters and setters
}
```
+ [Вопрос# 35 К оглавлению](#hibernate)


## Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?
Аннотация @Id определяет простой (не составной) первичный ключ, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:
1) примитивные типы и их обертки;
2) строки;
3) BigDecimal и BigInteger;
4) java.util.Date и java.sql.Date.

Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @GeneratedValue.
__Возможно 4 варианта генерации первичного ключа:__ 
1) __AUTO(default)__ - Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию. Поведение по умолчанию - исходить из типа поля идентификатора. 
2) __IDENTITY__ - для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена.
3) __SEQUENCE__ - тип генерации, рекомендуемый документацией Hibernate. Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как хибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение.
SEQUENCE - это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе. 
4) __TABLE__ - Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.

+ [Вопрос# 36 К оглавлению](#hibernate)


## Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?
+ __@JoinColumn__ используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями. Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице. 

__Особенности использования:__
+ __@OneToOne:__ означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности
+ __@OneToMany/@ManyToOne:__ если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами.
+ __@JoinColumns__ используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.
В каждой аннотации @JoinColumn должны быть указаны элементы `name` и `referencedColumnName`.
+ __@JoinTable__ используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.

+ [Вопрос# 37 К оглавлению](#hibernate)


## Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?
+ __@OrderBy__ указывает порядок, в соответствии с которым должны располагаться элементы коллекций сущностей, базовых или встраиваемых типов при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет. Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany.
При использовании с коллекциями базовых типов, которые имеют аннотацию @ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов.
+ Если это коллекция встраиваемых типов (@Embeddable), то используя точку (".") мы можем сослаться на атрибут внутри встроенного атрибута. 
Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности:
Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу.
В случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy ("supervisor.name") повлечет Runtime Exceprtion

+ __@OrderColumn__ создает в таблице столбец с индексами порядка элементов, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса.
Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице.

+ __@OrderBy vs @OrderColumn__
Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.

+ [Вопрос# 38 К оглавлению](#hibernate)


## Для чего нужна аннотация @Transient?
__@Transient__ используется для объявления того, какие поля у сущности, встраиваемого класса или Mapped SuperClass не будут сохранены в базе данных.
__Persistent fields (постоянные поля)__ - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля.
__Transient fields (временные поля):__
+ static и final поля сущностей;
+ иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.

+ [Вопрос# 39 К оглавлению](#hibernate)


## Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?
В порядке от самого ненадежного и быстрого, до самого надежного и медленного:
1) __NONE__ — без блокировки.
2) __OPTIMISTIC__ (синоним READ в JPA 1) — оптимистическая  блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле `@Version`, то будет сделан RollBack транзакции и будет выброшено `OptimisticLockException`.
3) __OPTIMISTIC_FORCE_INCREMENT__ (синоним WRITE в JPA 1) — работает по тому же алгоритму, что и `LockModeType.OPTIMISTIC` за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение).
4) __PESSIMISTIC_READ__ — данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание `PessimisticLockException`.
5) __PESSIMISTIC_WRITE__ — данные блокируются в момент записи и никто с момента захвата блокировки не может в них писать и не может их читать до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.
6) __PESSIMISTIC_FORCE_INCREMENT__ — ведёт себя как `PESSIMISTIC_WRITE`, но в конце транзакции увеличивает значение поля `@Version`, даже если фактически сущность не изменилась.

+ __Оптимистичное блокирование__ - подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных. Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии:
+ @Version
+ private long version;
Поле, аннотирование @Version, может быть целочисленным или временнЫм. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто `OptimisticLockException`. Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности.
Позволяет отказатьсь от блокировок на уровне БД и делать всё с JPA.

+ __Пессимистичное блокирование__ - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности.

Блокировки ставятся путём вызова метода `lock()` у `EntityManager`, в который передаётся сущность, требующая блокировки и уровень блокировки:
```java
EntityManager em = entityManagerFactory.createEntityManager();
em.lock(company1, LockModeType.OPTIMISTIC);
```
+ [Вопрос# 40 К оглавлению](#hibernate)


## Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?
1) __first-level cache (кэш первого уровня)__ — кэширует данные одной транзакции;
2) __second-level cache (кэш второго уровня)__ — кэширует данные транзакций от одной фабрики сессий. Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.

Кэш первого уровня – это кэш сессии (Session), который является обязательным, это и есть `PersistenceContext`. Через него проходят все запросы.
В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление этого объекта для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти истребованиях одного и того же объекта из БД в рамках одного `persistence context`, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кэша. Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются, а далее – либо сохраняются в БД, либо обновляются.

__Особенности кэша первого уровня:__
+ включен по умолчанию, его нельзя отключить;
+ связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;
+ при закрытии сессии `PersistenceContext` очищается - кэшированные объекты, находившиеся в нем, удаляются;
+ при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;
+ если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;
+ сущность можно удалить из кэша сессии методом `evict()`, после чего следующая попытка получить эту же сущность повлечет обращение к базе данных;
+ метод `clear()` очищает весь кэш сессии.

Если кэш первого уровня привязан к объекту сессии, то кэш второго уровня привязан к объекту-фабрике сессий (Session Factory object) и, следовательно, кэш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности. Кэш второго уровня требует некоторой настройки и поэтому не включен по умолчанию. Настройка кэша заключается в конфигурировании реализации кэша и разрешения сущностям быть закэшированными.
Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кэшей.
+ [Вопрос# 41 К оглавлению](#hibernate)


## Как работать с кешем 2 уровня?
Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.
Hibernate поставляется со встроенной поддержкой стандарта кэширования `Java JCache`, а также двух популярных библиотек кэширования: `Ehcache` и `Infinispan`.

В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: `Ehcache`, `OSCache`, `SwarmCache`, `JBoss TreeCache`. Для Hibernate требуется только реализация интерфейса `org.hibernate.cache.spi.RegionFactory`, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, `RegionFactory` действует как мост между Hibernate и поставщиками кэша. В примерах будем использовать `Ehcache`. Что нужно сделать:
+ добавить мавен-зависимость кэш-провайдера нужной версии
+ включить кэш второго уровня и определить конкретного провайдера
```java
hibernate.cache.use_second_level_cache=true
hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
```
+ установить у нужных сущностей JPA-аннотацию `@Cacheable`, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию `@Cache`, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа

__Стратегии параллельного доступа к объектам:__
Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом. Следовательно надо как-то обеспечивать их одинаковым представлением этого объекта.
1) __READ_ONLY:__ Используется только для сущностей, которые никогда не изменяются (будет выброшено исключение, если попытаться обновить такую сущность). Очень просто и производительно. Подходит для некоторых статических данных, которые не меняются.
2) __NONSTRICT_READ_WRITE:__ Кэш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их. Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно между обновлением данных в БД и обновлением тех же данных в кэше, во время которого параллельная транзакция может получить из кэша устаревшие данные.
3) __READ_WRITE:__ Эта стратегия гарантирует строгую согласованность, которую она достигает, используя «мягкие» блокировки: когда обновляется кэшированная сущность, на нее накладывается мягкая блокировка, которая снимается после коммита транзакции. Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с наложенной мягкой блокировкой, не смогут их прочитать или записать и отправят запрос в БД. `Ehcache` использует эту стратегию по умолчанию.
4) __TRANSACTIONAL:__ полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, словно они работали с ними последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности.

+ [Вопрос# 42 К оглавлению](#hibernate)


## Что такое JPQL/HQL и чем он отличается от SQL?
__Hibernate Query Language (HQL)__ и __Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL. JPQL - это подмножество HQL

__JPQL__ - это язык запросов, практически такой же как SQL, однако, вместо имен и колонок таблиц базы данных, он использует имена классов `Entity` и их атрибуты. В качестве параметров запросов также используются типы данных атрибутов `Entity`, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм, то есть каждый запрос к `Entity` возвращает не только объекты этого `Entity`, но также объекты всех его классов-потомков, независимо от стратегии наследования. В JPA запрос представлен в виде `javax.persistence.Query` или `javax.persistence.TypedQuery`, полученных из `EntityManager`. 

В Hibernate HQL-запрос представлен `org.hibernate.query.Query`, полученный из `Session`. Если HQL является именованным запросом, то будет использоваться `Session#getNamedQuery`, в противном случае требуется `Session#createQuery`.
+ [Вопрос# 43 К оглавлению](#hibernate)


## Что такое Criteria API и для чего он используется?
Начиная с версии 5.2 `Hibernate Criteria API` объявлен `deprecated`. Вместо него рекомендуется использовать `JPA Criteria API`.
__JPA Criteria API__ - это актуальный API, используемый только для выборки(select) сущностей из БД в более объектно-ориентированном стиле.
__Основные преимущества JPA Criteria API:__
+ ошибки могут быть обнаружены во время компиляции;
+ позволяет динамически формировать запросы на этапе выполнения приложения.
__Основные недостатки:__
+ нет контроля над запросом, сложно отловить ошибку
+ влияет на производительность, множество классов

Для динамических запросов - фрагменты кода создаются во время выполнения - `JPA Criteria API` является предпочтительней. 

__Вот некоторые области применения Criteria API:__
+ Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде `sum()`, `min()`, `max()` и т.д.
+ Criteria API может использовать `ProjectionList` для извлечения данных только из выбранных колонок.
+ Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы `createAlias()`, `setFetchMode()` и `setProjection()`.
+ Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод `add()` с помощью которого добавляются ограничения (Restrictions).
+ Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода `addOrder()`.    

+ [Вопрос# 44 К оглавлению](#hibernate)


## Расскажите про проблему N+1 Select и путях ее решения.
Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса.

1) __JOIN FETCH__
И при `FetchType.EAGER` и при `FetchType.LAZY` нам поможет JPQL-запрос с `JOIN FETCH`. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта.
Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).
```sql
select pc
    from PostComment pc
    join fetch pc.post p
```    
2) __EntityGraph__
В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать `EntityGraph`.
3) __@Fetch(FetchMode.SUBSELECT)__
Аннотация Hibernate. Можно использовать только с коллекциями. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций:
```java
@Fetch(value = FetchMode.SUBSELECT)
    private Set<Order> orders = new HashSet<>();
``` 
4) __Batch fetching__
Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. Количество загружаемых сущностей указывается в аннотации.
```java
@BatchSize(size=5)
private Set<Order> orders = new HashSet<>();
 ```
5) __HibernateSpecificMapping, SqlResultSetMapping__
Для нативных запросов рекомендуется использовать именно их.

+ [Вопрос# 45 К оглавлению](#hibernate)


## Что такое EntityGraph? Как и для чего их использовать?
__Основная цель JPA Entity Graph - улучшить производительность в рантайме при загрузке базовых полей сущности и связанных сущностей и коллекций.__
Вкратце, Hibernate загружает весь граф в одном SELECT-запросе, то есть все указанные связи от нужной нам сущности. Если надо загрузить дополнительные сущности, находящиеся в связанных сущностях - используется `Subgraph`.
`EntityGraph` можно определить с помощью аннотации `@NamedEntityGraph` для `Entity`, она определяет уникальное имя и список атрибутов ( attributeNodes ), которые должны быть загружены, и используя `entityManager` из JPA API:
```java
EntityGraph<Post> entityGraph = entityManager.createEntityGraph(Post.class);
entityGraph.addAttributeNodes("subject");
entityGraph.addAttributeNodes("user");
entityGraph.addSubgraph("comments").addAttributeNodes("user");
```
JPA определяет два свойства или подсказки, с помощью которых Hibernate может выбирать стратегию извлечения графа сущностей во время выполнения:
+ __fetchgraph__ - все атрибуты перечисленные в `EntityGraph` меняют `fetchType` на `EAGER`, все остальные на `LAZY`
+ __loadgraph__ - все атрибуты перечисленные в `EntityGraph` меняют `fetchType` на `EAGER`, все остальные сохраняют свой `fetchType`. С помощью `NamedSubgraph` можно также изменить `fetchType` вложенных объектов `Entity`.

__Загрузить `EntityGraph` можем тремя способами:__
1) Используя перегруженный метод `find()`, который принимает Map с настройками `EntityGraph`
2) Используя JPQL и передав подсказку через `setHint()`
3) С помощью `Criteria API`

+ [Вопрос# 46 К оглавлению](#hibernate)


## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )
### ---Info---
+ [JPA & Hibernate pdf manual JM-->]( https://docs.google.com/document/d/1cfs-ZBOSbYTrBWkdzh1rhR4eeE1TSv6_yo5AfU1eBV4/edit# )
+ [Package javax.persistence-->]( https://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html )
+ [Hibernate.org-->]( https://hibernate.org/orm/ )

### ---Video---
+ [YouTube/kuidreS/Hibernate - немного теории-->]( https://www.youtube.com/watch?v=HS7qJ4SRznM )
+ [YouTube/kuidreS/Урок 4 - Hibernate XML mapping-->]( https://www.youtube.com/watch?v=HUBuijE_Jg0 )
+ [YouTube/kuidreS/Урок 5 - Hibernate annotation mapping-->]( https://www.youtube.com/watch?v=qnZnu0dR36o&t=2s )
+ [YouTube/kuidreS/Урок 6 - содание DAO и Service слоев (Hibernate annotations, H2)-->]( https://www.youtube.com/watch?v=cCklIY78tc0 )
+ [YouTube/Java Vision/Java Hibernate часть 1-->](https://www.youtube.com/watch?v=Qt7HwPfwEKM )
+ [YouTube/Java Vision/Java Hibernate часть 2 Many To One-->]( https://www.youtube.com/watch?v=XcjE5dS21uE )
+ [YouTube/Java Vision/Java Hibernate часть 3 One To Many-->]( https://www.youtube.com/watch?v=R_j5mXF-Fe4 )
+ [YouTube/Java Vision/Java Hibernate часть 4 Many To Many-->]( https://www.youtube.com/watch?v=VQPoe2OVghQ )
+ [YouTube/JUG .ru/Вячеслав Круглов — Введение в Hibernate: что, зачем, и где стандартные ловушки-->]( https://www.youtube.com/watch?v=C-wEZjEOhWc )
+ [YouTube/LessonFirst/Java hibernate: Настройка конфигов, урок 1!-->]( https://www.youtube.com/watch?v=1qYOxJ-OEWs&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0 )
+ [YouTube/LessonFirst/Java hibernate: xml маппинг, урок 2!-->]( https://www.youtube.com/watch?v=cnw5PHdsDtQ&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=2 )
+ [YouTube/LessonFirst/Java hibernate: XML мапинг, связь многие к одному, урок 3!-->]( https://www.youtube.com/watch?v=hhO6JgfHitU&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=3 )
+ [YouTube/LessonFirst/Java hibernate: XML мапинг, связь один к одному, урок 4!-->]( https://www.youtube.com/watch?v=FsBGZW6qJXM&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=4 )
+ [YouTube/LessonFirst/Java hibernate: XML мапинг, связь многие ко многим, урок 5!-->]( https://www.youtube.com/watch?v=rUER9XgNuy4&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=5 )
+ [YouTube/LessonFirst/Java hibernate: Введение в JPA, урок 6!-->]( https://www.youtube.com/watch?v=-Ld6xgd2K4k&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=6 )
+ [YouTube/LessonFirst/Java hibernate: JPA связь многие к одному, урок 7!-->]( https://www.youtube.com/watch?v=wfnbF7aELUk&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=7)
+ [YouTube/LessonFirst/Java hibernate: JPA связь один к одному, урок 8!-->]( https://www.youtube.com/watch?v=JJBrkkKuC2M&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=8 )
+ [YouTube/LessonFirst/Java hibernate: JPA связь многие ко многим, урок 9!-->]( https://www.youtube.com/watch?v=h3PHEUuOmZA&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=9 )
+ [YouTube/LessonFirst/Java hibernate: JPA Пример использования мапинга, урок 10!-->]( https://www.youtube.com/watch?v=3WjcQiemvWM&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=10 )
+ [YouTube/LessonFirst/Java hibernate: Транзакции, урок 11!-->]( https://www.youtube.com/watch?v=j2Eky9D9RkA&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=11 )
+ [YouTube/LessonFirst/Java hibernate: SQL запросы, урок 12!-->]( https://www.youtube.com/watch?v=p1B4pz0G19o&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=12 )
+ [YouTube/LessonFirst/Java hibernate: HQL запросы, урок 13!-->]( https://www.youtube.com/watch?v=IJMgD1MNdNM&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=13 )
+ [YouTube/LessonFirst/Java hibernate: Criteria запросы, урок 14!-->]( https://www.youtube.com/watch?v=oJi4ljPJ6IA&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=14 )
+ [YouTube/LessonFirst/Java hibernate: Валидация, урок 15!-->]( https://www.youtube.com/watch?v=Pg96t-T1G-E&list=PLi3gxGWPyGGQsEZyjQNPoUEHwNtxiMf-0&index=15 )
+ [YouTube/GeekBrains/Изучите Hibernate на практике GeekBrains-->]( https://www.youtube.com/watch?v=4CLlk9EeUeo )
+ [YouTube/D2D/Курс Java для начинающих. Занятие №9. ORM JPA Hibernate-->]( https://www.youtube.com/watch?v=u4GSk3GVZNw )
+ [YouTube/luv2code/Hibernate Tutorial #1 - Hibernate Overview(ENG)-->]( https://www.youtube.com/watch?v=0hm3QidFwYY&list=PLEAQNNR8IlB7fNkRsUgzrR346i-UqE5CG&index=1 )

### ---Lessons---
+ [Hibernate. Основные принципы работы с сессиями и транзакциями-->]( https://habr.com/ru/post/271115/ )
+ [Ваше первое приложение на Hibernate-->]( https://javarush.ru/groups/posts/hibernate-java )
+ [Аннотации. Часть первая, немного скучная-->]( https://javarush.ru/groups/posts/500-annotacii-chastjh-pervaja-nemnogo-skuchnaja )
+ [Аннотации. Часть вторая. Lombok-->]( https://javarush.ru/groups/posts/518-annotacii-chastjh-vtoraja-lombok )
+ [Hibernate — Краткое руководство-->]( https://coderlessons.com/tutorials/java-tekhnologii/vyuchit-hibernate/hibernate-kratkoe-rukovodstvo )
+ [Руководство Java Hibernate для начинающих-->]( https://o7planning.org/ru/10201/java-hibernate-tutorial-for-beginners#a77362 )
+ [Java Query примеры использования-->]( https://java.hotexamples.com/ru/examples/javax.persistence/Query/-/java-query-class-examples.html )
+ [QueryDSL: Предикаты-->]( https://habr.com/ru/post/344450/ )
+ [Объектно-реляционные и объектные базы данных-->](https://oracle-patches.com/db/2867-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%B1%D0%B0%D0%B7%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 )
+ [Реляционные БД vs Объектно-ориентированные БД-->]( https://habr.com/ru/post/93356/ )
+ [Мета-данные. На пути к идеалам управления моделями данных-->]( https://habr.com/ru/post/90528/ )
+ [Hibernate – Hibernate Query (HQL) примеры: SELECT, INSERT, UPDATE, DELETE-->]( https://javastudy.ru/hibernate/hibernate-hql-examples/ )
+ [Язык запросов HQL-->]( http://java-online.ru/hibernate-hql.xhtml )
+ [Hibernate — о чем молчат туториалы-->]( https://habr.com/ru/post/416851/ )
+ [Связанные сущности в Hibernate-->]( http://java-online.ru/hibernate-entities.xhtml )
+ [JPA EntityManager: управляем сущностями(2016)-->]( https://easyjava.ru/data/jpa/jpa-entitymanager-upravlyaem-sushhnostyami/ )

### ---Forum---
+ [Hibernate 5 Java Configuration Example-->]( https://dzone.com/articles/hibernate-5-java-configuration-example )

[к оглавлению](#hibernate)
