[JavaTutorials](README.md)

# Theme1___Exceptions
1) [Что такое исключения?](#Что-такое-исключения)
2) [Какова иерархия исключений?](#Какова-иерархия-исключений)
3) [Расскажите про обрабатываемые и необрабатываемые исключения](#Расскажите-про-обрабатываемые-и-необрабатываемые-исключения)
4) [Можно ли обработать необрабатываемые исключения?](#Можно-ли-обработать-необрабатываемые-исключения)
5) [В чем особенность `RuntimeException`?](#В-чем-особенность-RuntimeException)
6) [Можно и нужно ли обрабатывать ошибки `jvm`?](#Можно-и-нужно-ли-обрабатывать-ошибки-jvm)
7) [Может ли метод _`main()`_ выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#Может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
8) [Какие существуют способы обработки исключений?](#Какие-существуют-способы-обработки-исключений)
9) [О чем говорит ключевое слово `throws`?](#О-чем-говорит-ключевое-слово-throws)
10) [Какой оператор позволяет принудительно выбросить исключение?](#Какой-оператор-позволяет-принудительно-выбросить-исключение)
11) [Опишите работу блока _`try-catch-finally`_?](#Опишите-работу-блока-try-catch-finally)
12) [Что такое механизм _`try-with-resources`_?](#Что-такое-механизм-try-with-resources)
13) [В чем особенность блока `finally`? Всегда ли он исполняется?](#В-чем-особенность-блока-finally-Всегда-ли-он-исполняется)
14) [Существуют ли ситуации, когда блок `finally` не будет выполнен?](#Существуют-ли-ситуации-когда-блок-finally-не-будет-выполнен)
15) [Может ли не быть ни одного блока `catch` при отлавливании исключений?](#Может-ли-не-быть-ни-одного-блока-catch-при-отлавливании-исключений)
16) [Может ли один блок `catch` отлавливать сразу несколько исключений?](#Может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений)
17) [Как написать собственное («пользовательское») исключение?](#Как-написать-собственное-пользовательское-исключение)
18) [Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?](#Что-произойдёт-если-в-блоке-инициализации-возникнет-исключительная-ситуация)
19) [Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?](#Какое-исключение-выбрасывается-при-возникновении-ошибки-в-блоке-инициализации-класса)
20) [Когда в приложении может быть выброшено исключение `ClassCastException`?](#Когда-в-приложении-может-быть-выброшено-исключение-ClassCastException)
21) [Какие существуют _`unchecked exception`_?](#Какие-существуют-unchecked-exception)
22) [Что представляет из себя ошибки класса `Error`?](#Что-представляет-из-себя-ошибки-класса-Error)
23) [Что вы знаете о `OutOfMemoryError`?](#Что-вы-знаете-о-OutOfMemoryError)
24) [Предположим, есть метод, который может выбросить `IOException` и `FileNotFoundException` в какой последовательности должны идти блоки `catch`? Сколько блоков `catch` будет выполнено?](#Предположим-есть-метод-который-может-выбросить-IOException-и-FileNotFoundException-в-какой-последовательности-должны-идти-блоки-catch-Сколько-блоков-catch-будет-выполнено)
25) [Если оператор `return` содержится и в блоке `catch` и в `finally`, какой из них “главнее”?](#Если-оператор-return-содержится-и-в-блоке-catch-и-в-finally-какой-из-них-главнее)
26) [Что вы знаете о `SQLException`? К какому типу `checked` или `unchecked` оно относится, почему?](#Что-вы-знаете-о-SQLException-К-какому-типу-checked-или-unchecked-оно-относится-почему)
27) [Предположим, есть блок `try-finally`. В блоке `try` возникло исключение и выполнение переместилось в блок `finally`. В блоке `finally` тоже возникло исключение. Какое из двух исключений “выпадет” из блока `try-finally`? Что случится со вторым исключением?](#Предположим-есть-блок-try-finally-В-блоке-try-возникло-исключение-и-выполнение-переместилось-в-блок-finally-В-блоке-finally-тоже-возникло-исключение-Какое-из-двух-исключений-выпадет-из-блока-try-finally-Что-случится-со-вторым-исключением)
28) [Перечислите исключения по названиям?](#Перечислите-исключения-по-названиям)
29) [Какое назначение класса `Throwable`? Методы класса `Throwable`?](#Какое-назначение-класса-Throwable-Методы-класса-Throwable)
30) [В каком порядке следует обрабатывать исключения в catch блоках?](#В-каком-порядке-следует-обрабатывать-исключения-в-catch-блоках)
31) [Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?](#Что-произойдет-если-исключение-будет-выброшено-из-блока-catch-после-чего-другое-исключение-будет-выброшено-из-блока-finally)
32) [Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?](#Что-произойдет-если-исключение-будет-выброшено-из-блока-catch-после-чего-другое-исключение-будет-выброшено-из-метода-close-при-использовании-try-with-resources)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)



# Theme2___SerializableAndCopy
1) [Что такое _«сериализация»_?](#Что-такое-сериализация)
2) [Опишите процесс сериализации/десериализации с использованием `Serializable`.](#Опишите-процесс-сериализациидесериализации-с-использованием-serializable)
3) [Как изменить стандартное поведение сериализации/десериализации?](#Как-изменить-стандартное-поведение-сериализациидесериализации)
4) [Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?](#Какие-поля-не-будут-сериализованы-при-сериализации-Будет-ли-сериализовано-final-поле)
5) [Что обозначает ключевое слово `transient`?](#Что-обозначает-ключевое-слово-transient)
6) [Как не допустить сериализацию?](#Как-не-допустить-сериализацию)
7) [Как создать собственный протокол сериализации?](#Как-создать-собственный-протокол-сериализации)
8) [Какая роль поля `serialVersionUID` в сериализации?](#Какая-роль-поля-serialversionuid-в-сериализации)
9) [Когда стоит изменять значение поля `serialVersionUID`?](#Когда-стоит-изменять-значение-поля-serialversionuid)
10) [В чем проблема сериализации Singleton?](#В-чем-проблема-сериализации-singleton)
11) [Какие существуют способы контроля за значениями десериализованного объекта](#Какие-существуют-способы-контроля-за-значениями-десериализованного-объекта)
12) [Расскажите про клонирование объектов.](#Расскажите-про-клонирование-объектов)
13) [В чем отличие между _поверхностным_ и _глубоким_ клонированием?](#В-чем-отличие-между-поверхностным-и-глубоким-клонированием)
14) [Какой способ клонирования предпочтительней?](#Какой-способ-клонирования-предпочтительней)
15) [Почему метод `clone()` объявлен в классе `Object`, а не в интерфейсе `Cloneable`?](#Почему-метод-clone-объявлен-в-классе-object-а-не-в-интерфейсе-cloneable)
16) [Как создать глубокую копию объекта? (2 способа)](#Как-создать-глубокую-копию-объекта-2-способа)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)










__Theme1 - Exceptions______________________________________________________________________________________________________________

## Что такое исключения?
Исключение – это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:
+ Пользователь ввел некорректные данные.
+ Файл, к которому обращается программа, не найден.
+ Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.
Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.

Каждый раз, когда при выполнении программы происходит ошибка, создается объект-исключение, содержащий информацию об ошибке, включая её тип и состояние программы на момент возникновения ошибки. После создания исключения среда выполнения пытается найти в стеке вызовов метод, который содержит код, обрабатывающий это исключение. Поиск начинается с метода, в котором произошла ошибка, и проходит через стек в обратном порядке вызова методов. Если не было найдено ни одного подходящего обработчика, выполнение программы завершается.

Исключения позволяют:
+ разделить обработку ошибок и сам алгоритм;
+ не загромождать код проверками возвращаемых значений;
+ обрабатывать ошибки на верхних уровнях, если на текущем уровне не хватает данных для обработки. Например, при написании универсального метода чтения из файла невозможно заранее предусмотреть реакцию на ошибку, так как эта реакция зависит от использующей метод программы;
+ классифицировать типы ошибок, обрабатывать похожие исключения одинаково, сопоставлять специфичным исключениям определенные обработчики.

Таким образом, механизм обработки исключений содержит следующие операции:
+ Создание объекта-исключения.
+ Заполнение stack trace'а этого исключения.
+ Stack unwinding (раскрутка стека) в поисках нужного обработчика.

+ [Thema#1 Question#1  Go to Exceptions](#Theme1___Exceptions)


## Какова иерархия исключений?
1) класс Throwable (checked)
2) от Throwable  --> Error (ошибки JVM) и Exception (checked общие)
3) от Exception 
    -- > RuntimeException (unchecked)
    -- > IOException, SQLException, ReflectiveOperationException (checked)
4) RuntimeException (unchecked):
  + ClassCastExceptiuon
  + IndexOutOfBoundException
  + AritthmeticException
  + NullPointerException

__checked__ - зависит от программиста, __unchecked__ - от программиста не зависит
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются подклассы Exception и Error.
+ Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемые и предсказуемые. Например, произошло деление на ноль в целых числах.
+ Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.

+ [Thema#1 Question#2  Go to Exceptions](#Theme1___Exceptions)

## Расскажите про обрабатываемые и необрабатываемые исключения
В Java все исключения делятся на два типа:
+ __checked (контролируемые/проверяемые исключения)__ должны обрабатываться блоком `catch` или описываться в сигнатуре метода (например, `throws IOException`). Наличие такого обработчика/модификатора сигнатуры проверяются на этапе компиляции;
+ __unchecked (неконтролируемые/непроверяемые исключения)__, к которым относятся ошибки `Error` (например, `OutOfMemoryError`), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом `RuntimeException` и его наследниками (например, `NullPointerException`), которые могут не обрабатываться блоком `catch` и не быть описанными в сигнатуре метода.

Все исключительные ситуации делятся на «проверяемые» `checked` и «непроверяемые» `unchecked`. Это свойство присуще «корневищу» `Throwable, Error, Exception, RuntimeException` и передается по наследству. Никак не видимо в исходном коде класса исключения.
В дальнейших примерах просто учтите, что— `Throwable` и `Exception` и все их наследники (за исключением наследников `Error-а` и `RuntimeException-а`) — `checked
— Error и RuntimeException` и все их наследники — `unchecked`
`checked exception` = проверяемое исключение, проверяемое компилятором.

Тема достаточно обширная для того, чтобы уместить ее в одном ответе. К примеру, можно разобрать примеры Головача: http://habrahabr.ru/company/golovachcourses/blog/225585/

И еще с quizful.net
1) Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.
2) Unchecked исключения в Java – наследованные от RuntimeException, checked – от Exception (не включая unchecked).

Checked исключения отличаются от Unchecked исключения в Java, тем что:
1) Наличие\обработка __`Checked`__ исключения проверяются __на этапе компиляции__. 
2) Наличие\обработка __`Unchecked`__ исключения происходит __на этапе выполнения__.

+ [Thema#1 Question#3  Go to Exceptions](#Theme1___Exceptions)

## Можно ли обработать необрабатываемые исключения?
Можно, чтобы в некотрых случаях программа не прекратила работу
+ [Thema#1 Question#4  Go to Exceptions](#Theme1___Exceptions)

## В чем особенность `RuntimeException`?
`public class RuntimeException extends Exception` – базовый класс для ошибок во время выполнения. Относится к необрабатываемым исключениям (uncatched\unchecked). Как сказано в описании класса – это суперкласс, исключения которого могут быть выброшены во время нормальной работы JVM.
+ [Thema#1 Question#5  Go to Exceptions](#Theme1___Exceptions)

## Можно и нужно ли обрабатывать ошибки jvm?
Обрабатывать можно, но делать этого не стоит. Разработчику не предоставлены инструменты для обработки ошибок системы и виртуальной машины.
+ [Thema#1 Question#6  Go to Exceptions](#Theme1___Exceptions)

## Может ли метод _`main()`_ выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
Может и оно будет передано в виртуальную машину Java (JVM).
+ [Thema#1 Question#7  Go to Exceptions](#Theme1___Exceptions)

## Какие существуют способы обработки исключений?
В Java есть пять ключевых слов для работы с исключениями:
+ __1 `try` –__ данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
+ __2 `catch` –__ ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
+ __3 `finally` –__ ключевое слово для отметки начала блока кода, которой является дополнительным. Этот блок помещается после последнего блока ‘catch’. Управление обычно передаётся в блок 'finally' в любом случае.
+ __4 `throw` –__ служит для генерации исключений.
+ __5 `throws` –__ ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.

+ [Подробнее с примерами-->](http://www.quizful.net/post/java-exceptions)
+ [Thema#1 Question#8  Go to Exceptions](#Theme1___Exceptions)

## О чем говорит ключевое слово `throws`?
__`throws`__ – ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.
+ [Thema#1 Question#9  Go to Exceptions](#Theme1___Exceptions)

## Какой оператор позволяет принудительно выбросить исключение?
Это оператор `throw`:

```java
throw new Exception();
```
+ [Thema#1 Question#10  Go to Exceptions](#Theme1___Exceptions)

## Опишите работу блока _`try-catch-finally`_?
`try` — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
`catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения.
`finally` — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока `catch`. Управление передаётся в блок `finally` в любом случае, было выброшено исключение или нет.

Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:

```java
try { 
    //код, который потенциально может привести к исключительной ситуации 
} 
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //код обработки исключительной ситуации
} 
finally {
    //необязательный блок, код которого выполняется в любом случае
}
```
+ [Thema#1 Question#11  Go to Exceptions](#Theme1___Exceptions)

## Что такое механизм _`try-with-resources`_?
Данная конструкция, которая появилась в Java 7, позволяет использовать блок _`try-catch`_ не заботясь о закрытии ресурсов, используемых в данном сегменте кода.
Ресурсы объявляются в скобках сразу после `try`, а компилятор уже сам неявно создаёт секцию `finally`, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс `java.lang.Autocloseable`. 

Общий вид конструкции:

```java
try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}
```
Стоит заметить, что блоки `catch` и явный `finally` выполняются уже после того, как закрываются ресурсы в неявном `finally`.
+ [Thema#1 Question#12  Go to Exceptions](#Theme1___Exceptions)

## В чем особенность блока `finally`? Всегда ли он исполняется?
Когда исключение передано, выполнение метода направляется по нелинейному пути. Это может стать источником проблем. Например, при входе метод открывает файл и закрывает при выходе. Чтобы закрытие файла не было пропущено из-за обработки исключения, был предложен механизм  __`finally`__.

Ключевое слово __`finally`__ создаёт блок кода, который будет выполнен после завершения блока __`try/catch`__, но перед кодом, следующим за ним. Блок будет выполнен, независимо от того, передано исключение или нет. Оператор __`finally`__ не обязателен, однако каждый оператор __`try`__ требует наличия либо __`catch`__, либо __`finally`__. Код в блоке __`finally`__ будет выполнен всегда.
+ [Thema#1 Question#13  Go to Exceptions](#Theme1___Exceptions)

## Существуют ли ситуации, когда блок `finally` не будет выполнен?
Да, кроме случаев завершения работы программы или JVM:
1) Finally может не выполниться в случае если в блоке try вызывает System.exit(0), 
2) Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта. 
3) В блоке try{} бесконечный цикл.
```java
try { 
    System.exit(0); 
} catch(Exception e) { 
    e.printStackTrace(); 
} finally { }
```
+ [Thema#1 Question#14  Go to Exceptions](#Theme1___Exceptions)

## Может ли не быть ни одного блока `catch` при отлавливании исключений?
Такая запись допустима, если имеется связка try{} finally {}. Но смысла в такой записи не так много, всё же лучше иметь блок catch в котором будет обрабатываться необходимое исключение.

```java
String x = "z";
try {
   x="234";
} finally {
    x = "Finally";
}
```
+ [Thema#1 Question#15  Go to Exceptions](#Theme1___Exceptions)

## Может ли один блок `catch` отлавливать сразу несколько исключений?
В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком `catch`:

```java
try {  
    //...
} catch(IOException | SQLException ex) {
    //...
}
```
+ [Thema#1 Question#16  Go to Exceptions](#Theme1___Exceptions)

## Как написать собственное («пользовательское») исключение?
Необходимо унаследоваться от базового класса требуемого типа исключений (например от `Exception` или `RuntimeException`) и переопределит методы
```java
class CustomException extends Exception {
    public CustomException() {
        super();
    }

    public CustomException(final String string) {
        super(string + " is invalid");
    }

    public CustomException(final Throwable cause) {
        super(cause);
    }
}
```
+ [Thema#1 Question#17  Go to Exceptions](#Theme1___Exceptions)

## Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?
Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в `throws` всех конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.

В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.
+ [Thema#1 Question#18  Go to Exceptions](#Theme1___Exceptions)

## Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
Если возникшее исключение - наследник `RuntimeException`:
+ для статических блоков инициализации будет выброшено `java.lang.ExceptionInInitializerError`;
+ для нестатических будет проброшено исключение-источник.

Если возникшее исключение - наследник `Error`, то в обоих случаях будет выброшено `java.lang.Error`. Исключение: `java.lang.ThreadDeath` - смерть потока. В этом случае никакое исключение выброшено не будет.
+ [Thema#1 Question#19  Go to Exceptions](#Theme1___Exceptions)

## Когда в приложении может быть выброшено исключение `ClassCastException`?
`ClassCastException` (потомок `RuntimeException`) - исключение, которое будет выброшено при ошибке приведения типа.
+ [Thema#1 Question#20  Go to Exceptions](#Theme1___Exceptions)

## Какие существуют _`unchecked exception`_?
Наиболее часто встречающиеся: 
+ `ArithmeticException`, 
+ `ClassCastException`, 
+ `ConcurrentModificationException`, 
+ `IllegalArgumentException`, 
+ `IllegalStateException`, 
+ `IndexOutOfBoundsException`, 
+ `NoSuchElementException`, 
+ `NullPointerException`, 
+ `UnsupportedOperationException`.

+ [Thema#1 Question#21  Go to Exceptions](#Theme1___Exceptions)

## Что представляет из себя ошибки класса `Error`?
Ошибки класса `Error` представляют собой наиболее серьёзные проблемы уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине. Обрабатывать такие ошибки не запрещается, но делать этого не рекомендуется.
+ [Thema#1 Question#22  Go to Exceptions](#Theme1___Exceptions)

## Что вы знаете о `OutOfMemoryError`?
`OutOfMemoryError` выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.

Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип `OutOfMemoryError` зависит от того, в какой из них не хватило места:

+ `java.lang.OutOfMemoryError: Java heap space`: Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами `-Xms` и `-Xmx`.
+ `java.lang.OutOfMemoryError: PermGen space`: (до версии Java 8) Данная ошибка возникает при нехватке места в _Permanent_ области, размер которой задается параметрами `-XX:PermSize` и `-XX:MaxPermSize`.
+ `java.lang.OutOfMemoryError: GC overhead limit exceeded`: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра `-XX:-UseGCOverheadLimit`.
+ `java.lang.OutOfMemoryError: unable to create new native thread`: Выбрасывается, когда нет возможности создавать новые потоки.

+ [Подробнее с примерами-->](http://habrahabr.ru/post/117274/)
+ [Thema#1 Question#23  Go to Exceptions](#Theme1___Exceptions)

## Предположим, есть метод, который может выбросить `IOException` и `FileNotFoundException` в какой последовательности должны идти блоки `catch`? Сколько блоков `catch` будет выполнено?

Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок `catch(Exception ex) {}`, иначе все дальнейшие блоки `catch()` уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику `catch(Exception ex)`.

Таким образом, исходя из факта, что `FileNotFoundException extends IOException` сначала нужно обработать `FileNotFoundException`, а затем уже `IOException`:

```java
void method() {
    try {
        //...
    } catch (FileNotFoundException ex) {
        //...
    } catch (IOException ex) {
        //...
    }
}
```
+ [Thema#1 Question#24  Go to Exceptions](#Theme1___Exceptions)

## Если оператор `return` содержится и в блоке `catch` и в `finally`, какой из них “главнее”?
Вернется из блока finally.
```java
    public static void main(String[] args) {
       String what =  method();
        System.out.println(what);
    }
 
    public static String method() {
        try {
            return "SomeString";
        } catch(Exception ex) {
            return "Catch message";
        } finally {
            return "Finally message";
        }
    }
//Вывод
Finally message
```
+ [Thema#1 Question#25  Go to Exceptions](#Theme1___Exceptions)

## Что вы знаете о `SQLException`? К какому типу `checked` или `unchecked` оно относится, почему?
+ SQLException предоставляет информацию об ошибках доступа к базе данных или других ошибках связанных с работой с базами данных.
+ SQLException относится к checked исключениям, а значит проверяется на этапе компиляции.
Споры об этом типе исключения идут о том, что разработчику приходится постоянно обрабатывать это исключение в коде, хотя большая часть ошибок возникает во время выполнения программы, т.е., по мнению многих, лучше бы отнести его к unchecked runtime исключениям.
```java
try {
    // make some SQL call(s)
} catch {SQLException e) { 
    // log the exception
    return; // and give up
}
```
Аргумент Joshua Bloch из Effective Java Second Edition такой: сделав SQLException проверяемым – это попытка заставить разработчиков обработать исключение и обернуть его в новом уровне абстракции.
+ [Thema#1 Question#26  Go to Exceptions](#Theme1___Exceptions)

## Предположим, есть блок `try-finally`. В блоке `try` возникло исключение и выполнение переместилось в блок `finally`. В блоке `finally` тоже возникло исключение. Какое из двух исключений “выпадет” из блока `try-finally`? Что случится со вторым исключением?
Ответ аналогичный случаю с двумя return – будет обработано в finally блоке. Если было выброшено два исключения – одно в try, второе в finally, то исключение в finally “проглотит” исключение выше (см. пример). Если до блока finally исключение было обработано, то мы можем получить информацию об исключении в блоке try и тем самым не потерять исключение, которое впоследствии может быть перезаписано в finally другим исключением.
```java
public class TestExc {

    public static void main(String[] args) {
        Exception ex = twoExceptionsMethod();
        System.out.println(ex.getClass());
 
        String s = twoExceptionsMethod2();
        System.out.println(s);
    }
 
    public static Exception twoExceptionsMethod() {
        try {
            return new IndexOutOfBoundsException();
        } finally {
            return new NullPointerException();
        }
    }
 
    public static String twoExceptionsMethod2() {
        try {
            throw new NullPointerException();
        }catch (NullPointerException ex) {
            System.out.println(ex.getMessage()+ " catchBlock");;
        }
        finally {
            Exception ex2 = new Exception();
            return ex2.getMessage() + "finallyBlock";
        }
    }
}
//Вывод
class java.lang.NullPointerException
null catchBlock
null finallyBlock
```
+ [Thema#1 Question#27  Go to Exceptions](#Theme1___Exceptions)

## Перечислите исключения по названиям?
Ниже приведен перечень подклассов непроверяемых исключений производными от класса RuntimeException и которые определены в пакете java.lang:
+ ArithmeticException – арифметическая ошибка (например, деление на ноль);
+ ArrayIndexOutOfBoundsException – индекс за пределами массива;
+ ArrayStoreException – присваивание элементу массива объекта несовместимого типа;
+ ClassCastException – неправильное приведение типов;
+ EnumConstantNotPresent – попытка воспользоваться неопределенным значением перечисления;
+ IllegalArgumentException – недопустимый аргумент при вызове метода;
+ IllegalMonitorStateException – недопустимая контрольная операция;
+ IllegalStateException – неверное состояние среды или приложения;
+ IllegalThreadStateException – несовместимость запрашиваемой операции с текущим состоянием потока выполнения;
+ IndexOutOfBoundsException – выход индекса некоторого типа за допустимые границы;
+ NegativeArraySizeException – создание массива отрицательного размера;
+ NullPointerException – неправильное использование пустой ссылки;
+ NumberFormatException – неправильное преобразование символьной строки в числовой формат;
+ SecurityException – попытка нарушения безопасности;
+ StringIndexOutOfBounds – попытка доступа по индексу за пределами символьной строки;
+ TypeNotPresentException – тип не найден;
+ UnsupportedOperationException – найдена неподдерживаемая операция.

В языке Java в пакете java.lang реализован ряд проверяемых исключений. Ниже приведен их перечень:
+ ClassNotFoundException – класс не найден;
+ CloneNotSupportedException – попытка клонировать объект из класса, который не реализует интерфейс Cloneable;
+ IllegalAccessException – запрещен доступ к классу;
+ InstantiationException – попытка создать объект абстрактного класса или интерфейса;
+ InterruptedException – один поток выполнения прерван другим потоком;
+ NoSuchFieldException – запрашиваемое поле не существует;
+ NoSuchMethodException – запрашиваемый метод не существует;
+ ReflectiveOperationException – суперкласс исключений, связанных с рефлексией.

+ [Thema#1 Question#28  Go to Exceptions](#Theme1___Exceptions)

## Какое назначение класса `Throwable`? Методы класса `Throwable`?
Класс Throwable есть базовым для всех стандартных классов исключений Java. Этот класс предоставляет ряд методов, которые можно использовать или переопределять в собственных классах обработки исключений. Эти классы должны быть унаследованы от класса Exception, который унаследован от класса Throwable (см. рисунок). Класс Exception не содержит методов.
Ниже приведен перечень методов класса Throwable.
__Методы:__
+ `final void addSuppressed(Throwable исключение)` - добавляет заданное исключение в список подавляемых исключений. Этот список связывается с вызывающим (данным) исключением. Метод используется для применения в операторе try с ресурсами.
+ `Throwable fillInStackTrace()` - возвращает объект класса Throwable, содержащий полную трассировку стека. Этот объект может быть сгенерирован повторно.
+ `Throwable getCause()` - возвращает исключение, лежащее в основе текущего исключения. Метод возвращает null в случае, если такое исключение отсутствует. Этот метод используется при создании цепочек исключений – он вызывает исключение, вызывающее текущее исключение.
+ `String getLocalizedMessage()` - возвращает локализованное описание исключения.
+ `String getMessage()` - возвращает описание исключения.
+ `StackTraceElement[] getStackTrace()` - возвращает массив, содержащий поэлементную трассировку стека в виде объектов класса StackTraceElement.
+ `final Throwable[] getSuppressed()` - получает подавленные исключения, связанные с вызывающим исключением, и возвращает массив, который содержит результат. Подавленные исключения генерируются в операторе try с ресурсами.
+ `Throwable initCause(Throwable причина_исключения)` - связывает входной параметр причина_исключения с вызывающим исключением, указывая его как причину этого вызывающего исключения. Возвращает ссылку на исключение. Метод используется при создании цепочек исключений.
+ `printStackTrace();` - выводит трассировку стека.
+ `void setStackTrace(StackTraceElement элементы[])` - устанавливает трассировку стека для заданных элементов.
+ `String toString()` - возвращает объект типа String содержащий описание исключения. Этот метод можно вызвать из метода println() при выводе объекта типа Throwable.

+ [Thema#1 Question#29  Go to Exceptions](#Theme1___Exceptions)

## В каком порядке следует обрабатывать исключения в catch блоках?
От наследника к предку.
+ [Thema#1 Question#30  Go to Exceptions](#Theme1___Exceptions)

## Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?
finally-секция может «перебить» throw/return при помощи другого throw/return.
+ [Thema#1 Question#31  Go to Exceptions](#Theme1___Exceptions)

## Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?
В `try-with-resources` добавленна возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия.
+ [Thema#1 Question#32  Go to Exceptions](#Theme1___Exceptions)

## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
+ [Название-->](Ссылка)
+ [Исключения-->](https://www.youtube.com/watch?v=DElNhj71YCk)
+ [Исключения: перехват и обработка-->](https://javarush.ru/groups/posts/1943-iskljuchenija-perekhvat-i-obrabotka)
+ [Исключения: checked, unchecked и свои собственные-->](https://javarush.ru/groups/posts/1944-iskljuchenija-checked-unchecked-i-svoi-sobstvennihe)
+ [Антипаттерны обработки исключений в Java-->](https://dev64.wordpress.com/2012/10/07/exception-handling-antipatterns/)
+ [Исправляем 7 распространенных ошибок обработки исключений в Java-->](https://habr.com/ru/post/337536/)
+ [Приемы и советы. Как избежать NullPointerException в Java приложениях-->](https://javarush.ru/groups/posts/680-priemih-i-sovetih-kak-izbezhatjh-nullpointerexception-v-java-prilozhenijakh)
+ [Основные типы исключений (Exception) в java-->](https://www.fandroid.info/osnovnye-tipy-isklyuchenij-exception-v-java/)
+ [Классы Java для обработки исключительных ситуаций из пакета java.lang. Методы класса Throwable. Примеры-->](https://www.bestprog.net/ru/2019/10/01/java-%D1%81lasses-for-handling-exceptions-from-the-java-lang-package-methods-of-throwable-class-examples-ru/)
+ [Java — исключения-->](https://coderlessons.com/tutorials/java-tekhnologii/uchit-java/java-iskliucheniia)
+ [Java Checked and Unchecked Exceptions-->](https://www.codejava.net/java-core/exception/java-checked-and-unchecked-exceptions)
+ [Обработка исключений Java: try-catch-finally-->](https://javahelp.online/collections/obrabotka-isklyucheniy-java-try-catch-finally)
+ [Полное руководство по обработке исключений в Java-->](https://javadevblog.com/polnoe-rukovodstvo-po-obrabotke-isklyuchenij-v-java.html)



__Theme2 - Serializable&Copy_________________________________________________________________________________________________________

## Что такое _«сериализация»_?
__Сериализация (Serialization)__ - процесс преобразования структуры данных в линейную последовательность байтов для дальнейшей передачи или сохранения. Сериализованные объекты можно затем восстановить (десериализовать).

В Java, согласно спецификации Java Object Serialization существует два стандартных способа сериализации: стандартная сериализация, через использование интерфейса `java.io.Serializable` и «расширенная» сериализация - `java.io.Externalizable`.

Сериализация позволяет в определенных пределах изменять класс. Вот наиболее важные изменения, с которыми спецификация Java Object Serialization может справляться автоматически:

+ добавление в класс новых полей;
+ изменение полей из статических в нестатические;
+ изменение полей из транзитных в нетранзитные.

Обратные изменения (из нестатических полей в статические и из нетранзитных в транзитные) или удаление полей требуют определенной дополнительной обработки в зависимости от того, какая степень обратной совместимости необходима.

+ [Thema#2 Question#1  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Опишите процесс сериализации/десериализации с использованием `Serializable`.
1) Класс объекта должен реализовывать интерфейс `Serializable`
2) Создать поток `ObjectOutputStream (oos)`, который записывает объект в переданный `OutputStream`.
3) Записать в поток: `oos.writeObject(Object)`;
4) Сделать `oos.flush()` и `oos.close()`

При использовании `Serializable` применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:
+ запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор `SerialVersionUID`, идентификаторы полей класса);
+ рекурсивную запись в поток описания суперклассов до класса `java.lang.Object` (не включительно);
+ запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
+ рекурсивную запись объектов, которые являются полями сериализуемого объекта.

При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками.

Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается. Однако при десериализации будет вызван конструктор без параметров родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.
+ [Вопрос#2 К оглавлению](#Сериализация)

## Как изменить стандартное поведение сериализации/десериализации?
+ Реализовать интерфейс `java.io.Externalizable`, который позволяет применение пользовательской логики сериализации. Способ сериализации и десериализации описывается в методах `writeExternal()` и `readExternal()`. Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод `readExternal`.
+ Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его, а не метод по умолчанию :
    + `writeObject()` - запись объекта в поток;
    + `readObject()` - чтение объекта из потока;
    + `writeReplace()` - позволяет заменить себя экземпляром другого класса перед записью;
    + `readResolve()` - позволяет заменить на себя другой объект после чтения.

+ [Вопрос#3 К оглавлению](#Сериализация)

## Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?
1) Добавить к полю модификатор `transient`. В таком случае после восстановления его значение будет null.
2) Сделать поле `static`. Значения статических полей автоматически не сохраняются. При использовании реализации `Externalizable` сериализовать и десериализовать статическое поле можно, но не рекомендуется этого делать, т.к. это может сопровождаться трудноуловимыми ошибками.
3) Поля с модификатором `final` сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании `Externalizable`, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в `readExternal` изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.

+ [Вопрос#4 К оглавлению](#Сериализация)

## Что обозначает ключевое слово `transient`?
Поля класса, помеченные модификатором `transient`, не сериализуются.

Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить. Другой пример такого поля - ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.
+ [Вопрос#5 К оглавлению](#Сериализация)


## Как не допустить сериализацию?
Чтобы не допустить автоматическую сериализацию можно переопределить `private` методы для создания исключительной ситуации `NotSerializableException`.

```java
private void writeObject(ObjectOutputStream out) throws IOException {
    throw new NotSerializableException();
}

private void readObject(ObjectInputStream in) throws IOException {
    throw new NotSerializableException();
}
```
Любая попытка записать или прочитать этот объект теперь приведет к возникновению исключительной ситуации.
+ [Вопрос#6 К оглавлению](#Сериализация)

## Как создать собственный протокол сериализации?
Для создания собственного протокола сериализации достаточно реализовать интерфейс `Externalizable`, который содержит два метода:
```java
public void writeExternal(ObjectOutput out) throws IOException;
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
```
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках.
+ [Вопрос#7 К оглавлению](#Сериализация)

## Какая роль поля `serialVersionUID` в сериализации?
`serialVersionUID` используется для указании версии сериализованных данных. 

Когда мы не объявляем `serialVersionUID` в нашем классе явно, среда выполнения Java делает это за нас, но этот процесс чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей, интерфейсов, которые реализованы в классе и пр. 

Рекомендуется явно объявлять `serialVersionUID` т.к. при добавлении, удалении атрибутов класса динамически сгенерированное значение может измениться и в момент выполнения будет выброшено исключение `InvalidClassException`.
```java
private static final long serialVersionUID = 20161013L;
```
+ [Вопрос#8 К оглавлению](#Сериализация)

## Когда стоит изменять значение поля `serialVersionUID`?
`serialVersionUID` нужно изменять при внесении в класс несовместимых изменений, например при удалении какого-либо его атрибута.
Вы должны изменить `serialVersionUID` только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями , например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.
+ [Вопрос#9 К оглавлению](#Сериализация)

## В чем проблема сериализации Singleton?
__Проблема__ в том что после десериализации мы получим другой объект. Таким образом, сериализация дает возможность создать Singleton еще раз, что недопустимо. Существует два способа избежать этого:
__Решение__
+ явный запрет сериализации.
+ определение метода с сигнатурой `(default/public/private/protected/) Object readResolve() throws ObjectStreamException`, назначением которого станет возврат замещающего объекта вместо объекта, на котором он вызван.

+ [Вопрос#10 К оглавлению](#Сериализация)

## Какие существуют способы контроля за значениями десериализованного объекта
Если есть необходимость выполнения контроля за значениями десериализованного объекта, то можно использовать интерфейс `ObjectInputValidation` с переопределением метода `validateObject()`.
```java
// Если вызвать метод validateObject() после десериализации объекта, то будет вызвано исключение InvalidObjectException при значении возраста за пределами 39...60.
public class Person implements java.io.Serializable,
                               java.io.ObjectInputValidation {
    ...
    @Override
    public void validateObject() throws InvalidObjectException {
        if ((age < 39) || (age > 60))
            throw new InvalidObjectException("Invalid age");
    }
}
```
Так же существуют способы подписывания и шифрования, позволяющие убедиться, что данные не были изменены:

+ с помощью описания логики в `writeObject()` и `readObject()`.
+ поместить в оберточный класс `javax.crypto.SealedObject` и/или `java.security.SignedObject`. Данные классы являются сериализуемыми, поэтому при оборачивании объекта в `SealedObject` создается подобие «подарочной упаковки» вокруг исходного объекта. Для шифрования необходимо создать симметричный ключ, управление которым должно осуществляться отдельно. Аналогично, для проверки данных можно использовать класс `SignedObject`, для работы с которым также нужен симметричный ключ, управляемый отдельно.
+ [Вопрос#11 К оглавлению](#Сериализация)

## Расскажите про клонирование объектов.
в Java, есть 3 способа клонирования объекта:
1) __С использованием интерфейса Cloneable;__
Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь о клонировании полей-объектов. Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public. Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты. 
2) __С использованием конструктора клонирования объекта;__
В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.
3) __С использованием сериализации.__
Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.


Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на объект. Таким образом, две ссылки указывают на одну и ту же область памяти, на один и тот же объект. Для создания нового объекта с таким же состоянием используется клонирование объекта. 

Класс `Object` содержит `protected` метод `clone()`, осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод `clone()` как `public` для обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию метода `super.clone()`, которая и выполняет собственно клонирование. 

Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс `Cloneable`. Интерфейс `Cloneable` не содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод `clone()` класса `Object` возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение `CloneNotSupportedException`. Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.

Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам объект поля класса.

Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс `Cloneable` и переопределяет метод `clone()`. Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений `final` для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.

Помимо встроенного механизма клонирования в Java для клонирования объекта можно использовать:

+ __Специализированный конструктор копирования__ - в классе описывается конструктор, который принимает объект этого же класса и инициализирует поля создаваемого объекта значениями полей переданного.
+ __Фабричный метод__ - (Factory method), который представляет собой статический метод, возвращающий экземпляр своего класса.
+ __Механизм сериализации__ - сохранение и последующее восстановление объекта в/из потока байтов.

+ [Вопрос#12 К оглавлению](#Сериализация)

## В чем отличие между _поверхностным_ и _глубоким_ клонированием?
__Поверхностное копирование__ копирует настолько малую часть информации об объекте, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс `Object` не знает о структуре класса, которого он копирует. Клонирование такого типа осуществляется JVM по следующим правилам: 

+ Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
+ Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.

__Глубокое копирование__ дублирует абсолютно всю информацию объекта:
+ Нет необходимости копировать отдельно примитивные данные;
+ Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для каждого такого члена при переопределении метода `clone()` должен вызываться `super.clone()`;
+ Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.

+ [Вопрос#13 К оглавлению](#Сериализация)

## Какой способ клонирования предпочтительней?
Наиболее безопасным и, следовательно, предпочтительным способом клонирования является использование специализированного конструктора копирования: 

+ Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод `clone()`);
+ Поля для клонирования указываются явно;
+ Возможность клонировать даже `final` поля.

+ [Вопрос#14 К оглавлению](#Сериализация)

## Почему метод `clone()` объявлен в классе `Object`, а не в интерфейсе `Cloneable`?
Метод `clone()` объявлен в классе `Object` с указанием модификатора `native`, чтобы обеспечить доступ к стандартному механизму поверхностного копирования объектов. Одновременно он объявлен и как `protected`, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. Непосредственно интерфейс `Cloneable` является маркерным (не содержит объявлений методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть клонированным. Вызов переопределённого метода `clone()` у не `Cloneable` объекта вызовет выбрасывание `CloneNotSupportedException`.
+ [Вопрос#15 К оглавлению](#Сериализация)

## Как создать глубокую копию объекта? (2 способа)
1) Глубокое клонирование требует выполнения следующих правил: 
+ Нет необходимости копировать отдельно примитивные данные;
+ Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться `super.clone()` при переопределении метода `clone()`;
+ Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.
2) Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс `Serializable`. Мы сохраняет объект в массив байт и потом прочитать из него.

+ [Вопрос#16 К оглавлению](#Сериализация)




## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
+ [Сериализация в Java. Не все так просто-->](https://habr.com/ru/post/431524/#:~:text=%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F)
+ [Сериализация в Java-->](https://habr.com/ru/post/60317/)
+ [Сериализация и десериализация в Java-->](https://javarush.ru/groups/posts/2022-serializacija-i-deserializacija-v-java)
+ [Сериализация как она есть-->](http://www.skipy.ru/technics/serialization.html#top)
+ [Сериализация-->](https://metanit.com/java/tutorial/6.10.php)
+ [Все, что вам нужно знать о Java-сериализации-->]( https://coderlessons.com/articles/java/vse-chto-vam-nuzhno-znat-o-java-serializatsii )
+ [Как настроить сериализацию в Java с помощью внешнего интерфейса-->]( https://translate.google.com/translate?depth=1&pto=aue&rurl=translate.google.ru&sl=en&sp=nmt4&tl=ru&u=https://dzone.com/articles/how-to-customize-serialization-in-java-using-the-e )
+ [Сериализация объектов в Java-->]( https://pro-prof.com/forums/topic/%D1%81%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-java )
+ [Сериализация в Java-->]( https://coderlessons.com/articles/java/serializatsiia-v-java )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )













