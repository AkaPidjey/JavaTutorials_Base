[Java Tutorials](README.md)

# Потоки ввода вывода
+ [Какие существуют виды потоков ввода/вывода?](#Какие-существуют-виды-потоков-ввода-вывода)
+ [Назовите основные предки потоков ввода/вывода?](#Назовите-основные-предки-потоков-ввода-вывода)
+ [Что общего и чем отличаются следующие потоки: `InputStream`, `OutputStream`, `Reader`, `Writer`?](#Что-общего-и-чем-отличаются-следующие-потоки-InputStream-OutputStream-Reader-Writer)
+ [В каких пакетах лежат классы-потоки?](#В-каких-пакетах-лежат-классы-потоки)
+ [В чём заключается разница между IO и NIO?](#В-чём-заключается-разница-между-io-и-nio)
+ [Какие особенности NIO вы знаете?](#Какие-особенности-nio-вы-знаете)
+ [Что такое _«каналы»_?](#Что-такое-каналы)
+ [Какие подклассы класса `InputStream` вы знаете, для чего они предназначены?](#Какие-подклассы-класса-inputstream-вы-знаете-для-чего-они-предназначены)
+ [Для чего используется `PushbackInputStream`?](#Для-чего-используется-pushbackinputstream)
+ [Для чего используется `SequenceInputStream`?](#Для-чего-используется-sequenceinputstream)
+ [Какой класс позволяет читать данные из входного байтового потока в формате примитивных типов данных?](#Какой-класс-позволяет-читать-данные-из-входного-байтового-потока-в-формате-примитивных-типов-данных)
+ [Какие подклассы класса `OutputStream` вы знаете, для чего они предназначены?](#Какие-подклассы-класса-outputstream-вы-знаете-для-чего-они-предназначены)
+ [Какие подклассы класса `Reader` вы знаете, для чего они предназначены?](#Какие-подклассы-класса-reader-вы-знаете-для-чего-они-предназначены)
+ [Какие подклассы класса `Writer` вы знаете, для чего они предназначены?](#Какие-подклассы-класса-writer-вы-знаете-для-чего-они-предназначены)
+ [В чем отличие класса `PrintWriter` от `PrintStream`?](#В-чем-отличие-класса-printwriter-от-printstream)
+ [Чем отличаются и что общего у `InputStream`, `OutputStream`, `Reader`, `Writer`?](#Чем-отличаются-и-что-общего-у-inputstream-outputstream-reader-writer)
+ [Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?](#Какие-классы-позволяют-преобразовать-байтовые-потоки-в-символьные-и-обратно)
+ [Какие классы позволяют ускорить чтение/запись за счет использования буфера?](#Какие-классы-позволяют-ускорить-чтениезапись-за-счет-использования-буфера)
+ [Какой класс предназначен для работы с элементами файловой системы?](#Какой-класс-предназначен-для-работы-с-элементами-файловой-системы)
+ [Какие методы класса `File` вы знаете?](#Какие-методы-класса-file-вы-знаете)
+ [Что вы знаете об интерфейсе `FileFilter`?](#Что-вы-знаете-об-интерфейсе-filefilter)
+ [Как выбрать все элементы определенного каталога по критерию (например, с определенным расширением)?](#Как-выбрать-все-элементы-определенного-каталога-по-критерию-например-с-определенным-расширением)
+ [Что вы знаете о `RandomAccessFile`?](#Что-вы-знаете-о-randomaccessfile)
+ [Какие режимы доступа к файлу есть у `RandomAccessFile`?](#Какие-режимы-доступа-к-файлу-есть-у-randomaccessfile)
+ [Какие классы поддерживают чтение и запись потоков в компрессированном формате?](#Какие-классы-поддерживают-чтение-и-запись-потоков-в-компрессированном-формате)
+ [Существует ли возможность перенаправить потоки стандартного ввода/вывода?](#Существует-ли-возможность-перенаправить-потоки-стандартного-вводавывода)
+ [Какой символ является разделителем при указании пути в файловой системе?](#Какой-символ-является-разделителем-при-указании-пути-в-файловой-системе)
+ [Что такое _«абсолютный путь»_ и _«относительный путь»_?](#Что-такое-абсолютный-путь-и-относительный-путь)
+ [Что такое _«символьная ссылка»_?](#Что-такое-символьная-ссылка)
+ [Как работает метод read?](#Как-работает-метод-read)
+ [Разница между методами _`flush()`_ и _`close()`_ ?](#Разница-между-методами-flush-close)
+ [На каких паттернах основана иерархия потоков ввода/вывода?](#На-каких-паттернах-основана-иерархия-потоков-ввода-вывода)
+ [Когда использовать `Scanner` и `BufferedReader`. Различия и сходство?](#Когда-использовать-Scanner-и-BufferedReader-Различия-и-сходство)


+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)


# Какие существуют виды потоков ввода вывода?
Разделяют два вида потоков ввода/вывода: байтовые и символьные.
Система ввода/вывода: http://developer.alexanderklimov.ru/android/java/io.php
Oracle Lesson: Basic I/O tutorial: https://docs.oracle.com/javase/tutorial/essential/io/

[к оглавлению](#потоки-ввода-вывода)

# Назовите основные предки потоков ввода вывода?
+ __Байтовые:__ `java.io.InputStream`, `java.io.OutputStream`;
+ __Символьные:__ `java.io.Reader`, `java.io.Writer`;

[к оглавлению](#потоки-ввода-вывода)

# Что общего и чем отличаются следующие потоки: InputStream, OutputStream, Reader, Writer?
Базовый класс __`InputStream`__ представляет классы, которые получают данные из различных источников:

+ – массив байтов
+ – строка (String)
+ – файл
+ – канал (pipe): данные помещаются с одного конца и извлекаются с другого
+ – последовательность различных потоков, которые можно объединить в одном потоке
+ – другие источники (например, подключение к интернету)

Класс __`OutputStream`__ – это абстрактный класс, определяющий потоковый байтовый вывод. В этой категории находятся классы, определяющие, куда направляются ваши данные: 

+ в массив байтов (но не напрямую в String; предполагается что вы сможете создать их из массива байтов), 
+ в файл или 
+ канал.

Символьные потоки имеют два основных абстрактных класса __`Reader`__ и __`Writer`__, управляющие потоками символов Unicode. Класс __`Reader`__ – абстрактный класс, определяющий символьный потоковый ввод. Класс __`Writer`__ – абстрактный класс, определяющий символьный потоковый вывод. В случае ошибок все методы класса передают исключение `IOException`.

[к оглавлению](#потоки-ввода-вывода)

# В каких пакетах лежат классы-потоки?
Классы потоков ввода\вывода лежат в `java.io`; С JDK 7 добавлен более современный способ работы с потоками – Java NIO. Классы лежат в `java.nio`. Для работы с архивами используются классы из пакета `java.util`.

[к оглавлению](#потоки-ввода-вывода)

## В чём заключается разница между IO и NIO?
+ Java IO (input-output) является потокоориентированным, а Java NIO (new/non-blocking io) – буфер-ориентированным. Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно. Данная информация нигде не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. В Java NIO данные сначала считываются в буфер, что дает больше гибкости при обработке данных.
+ Потоки ввода/вывода в Java IO являются блокирующими. Это значит, что когда в потоке выполнения вызывается `read()` или `write()` метод любого класса из пакета `java.io.*`, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого. Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим. Тоже самое справедливо и для неблокирующего вывода. Поток выполнения может запросить запись в канал некоторых данных, но не дожидаться при этом пока они не будут полностью записаны.
+ В Java NIO имеются селекторы, которые позволяют одному потоку выполнения мониторить несколько каналов ввода. Т.е. существует возможность зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.

[к оглавлению](#потоки-ввода-вывода)

## Какие особенности NIO вы знаете?
+ __Каналы и селекторы__: NIO поддерживает различные типы каналов. Канал является абстракцией объектов более низкого уровня файловой системы (например, отображенные в памяти файлы и блокировки файлов), что позволяет передавать данные с более высокой скоростью. Каналы не блокируются и поэтому Java предоставляет еще такие инструменты, как селектор, который позволяет выбрать готовый канал для передачи данных, и сокет, который является инструментом для блокировки.
+ __Буферы__: имеет буферизация для всех классов-обёрток примитивов (кроме Boolean). Появился абстрактный класс Buffer, который предоставляет такие операции, как clear, flip, mark и т.д. Его подклассы предоставляют методы для получения и установки данных.
+ __Кодировки__: появились кодеры и декодеры для отображения байт и символов Unicode.

[к оглавлению](#потоки-ввода-вывода)

## Что такое _«каналы»_?
Каналы (channels) – это логические (не физические) порталы, абстракции объектов более низкого уровня файловой системы (например, отображенные в памяти файлы и блокировки файлов), через которые осуществляется ввод/вывод данных, а буферы являются источниками или приёмниками этих переданных данных. При организации вывода, данные, которые необходимо отправить, помещаются в буфер, который затем передается в канал. При вводе, данные из канала помещаются в заранее предоставленный буфер.

Каналы напоминают трубопроводы, по которым эффективно транспортируются данные между буферами байтов и сущностями по ту сторону каналов. Каналы – это шлюзы, которые позволяют получить доступ к сервисам ввода/вывода операционной системы с минимальными накладными расходами, а буферы – внутренние конечные точки этих шлюзов, используемые для передачи и приема данных.

[к оглавлению](#потоки-ввода-вывода)

## Какие подклассы класса `InputStream` вы знаете, для чего они предназначены?
+ `InputStream` - абстрактный класс, описывающий поток ввода;
+ `BufferedInputStream` - буферизованный входной поток;
+ `ByteArrayInputStream` позволяет использовать буфер в памяти (массив байтов) в качестве источника данных для входного потока;
+ `DataInputStream` - входной поток для байтовых данных, включающий методы для чтения стандартных типов данных Java;
+ `FileInputStream` - входной поток для чтения информации из файла;
+ `FilterInputStream` - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства;
+ `ObjectInputStream` - входной поток для объектов;
+ `StringBufferInputStream` превращает строку (`String`) во входной поток данных `InputStream`;
+ `PipedInputStream` реализует понятие входного канала;
+ `PushbackInputStream` - разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом в поток, позволяет «заглянуть» во входной поток и увидеть, что оттуда поступит в следующий момент, не извлекая информации.
+ `SequenceInputStream` используется для слияния двух или более потоков `InputStream` в единый.

[к оглавлению](#потоки-ввода-вывода)

## Для чего используется `PushbackInputStream`?
Разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом в поток. Класс `PushbackInputStream` представляет механизм «заглянуть» во входной поток и увидеть, что оттуда поступит в следующий момент, не извлекая информации.

У класса есть дополнительный метод unread().

[к оглавлению](#потоки-ввода-вывода)

## Для чего используется `SequenceInputStream`?
Класс `SequenceInputStream` позволяет сливать вместе несколько экземпляров класса `InputStream`. Конструктор принимает в качестве аргумента либо пару объектов класса `InputStream`, либо интерфейс `Enumeration`.

Во время работы класс выполняет запросы на чтение из первого объекта класса `InputStream` и до конца, а затем переключается на второй. При использовании интерфейса работа продолжится по всем объектам класса `InputStream`. По достижении конца, связанный с ним поток закрывается. Закрытие потока, созданного объектом класса `SequenceInputStream`, приводит к закрытию всех открытых потоков.

[к оглавлению](#потоки-ввода-вывода)

## Какой класс позволяет читать данные из входного байтового потока в формате примитивных типов данных?
Класс `DataInputStream` представляет поток ввода и предназначен для записи данных примитивных типов, таких, как `int`, `double` и т.д. Для каждого примитивного типа определен свой метод для считывания:

+ `boolean readBoolean()`: считывает из потока булевое однобайтовое значение
+ `byte readByte()`: считывает из потока 1 байт
+ `char readChar()`: считывает из потока значение `char`
+ `double readDouble()`: считывает из потока 8-байтовое значение `double`
+ `float readFloat()`: считывает из потока 4-байтовое значение `float`
+ `int readInt()`: считывает из потока целочисленное значение `int`
+ `long readLong()`: считывает из потока значение `long`
+ `short readShort()`: считывает значение `short`
+ `String readUTF()`: считывает из потока строку в кодировке UTF-8

Для чтения байтовых данных (не строк) применяется класс DataInputStream. В этом случае необходимо использовать классы из группы InputStream.

Для преобразования строки в массив байтов, пригодный для помещения в поток ByteArrayInputStream, в классе String предусмотрен метод getBytes(). Полученный ByteArrayInputStream представляет собой поток InputStream, подходящий для передачи DataInputStream.

При побайтовом чтении символов из форматированного потока DataInputStream методом readByte() любое полученное значение будет считаться действительным, поэтому возвращаемое значение неприменимо для идентификации конца потока. Вместо этого можно использовать метод available(), который сообщает, сколько еще осталось символов.

Класс DataInputStream позволяет читать элементарные данные из потока через интерфейс DataInput, который определяет методы, преобразующие элементарные значения в форму последовательности байтов. Такие потоки облегчают сохранение в файле двоичных данных.

Конструктор: DataInputStream(InputStream stream)
Методы: readDouble(), readBoolean(), readInt()

[к оглавлению](#потоки-ввода-вывода)

## Какие подклассы класса `OutputStream` вы знаете, для чего они предназначены?
+ `OutputStream` - это абстрактный класс, определяющий потоковый байтовый вывод;
+ `BufferedOutputStream` - буферизированный выходной поток;
+ `ByteArrayOutputStream` - все данные, посылаемые в этот поток, размещаются в предварительно созданном буфере;
+ `DataOutputStream` - выходной поток байт, включающий методы для записи стандартных типов данных Java;
+ `FileOutputStream` - запись данных в файл на физическом носителе;
+ `FilterOutputStream` - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства;
+ `PrintStream` - выходной поток, включающий методы `print()` и `println()`;
+ `ObjectOutputStream` - выходной поток для записи объектов;
+ `PipedOutputStream` реализует понятие выходного канала.

[к оглавлению](#потоки-ввода-вывода)

## Какие подклассы класса `Reader` вы знаете, для чего они предназначены?
+ `Reader` - абстрактный класс, описывающий символьный ввод;
+ `BufferedReader` - буферизованный входной символьный поток;
+ `CharArrayReader` - входной поток, который читает из символьного массива;
+ `FileReader` - входной поток, читающий файл;
+ `FilterReader` - абстрактный класс, предоставляющий интерфейс для классов-надстроек;
+ `InputStreamReader`- входной поток, транслирующий байты в символы;
+ `LineNumberReader` - входной поток, подсчитывающий строки;
+ `PipedReader` - входной канал;
+ `PushbackReader` - входной поток, позволяющий возвращать символы обратно в поток;
+ `StringReader` - входной поток, читающий из строки.

[к оглавлению](#потоки-ввода-вывода)

## Какие подклассы класса `Writer` вы знаете, для чего они предназначены?
+ `Writer` - абстрактный класс, описывающий символьный вывод;
+ `BufferedWriter` - буферизованный выходной символьный поток;
+ `CharArrayWriter` - выходной поток, который пишет в символьный массив;
+ `FileWriter` - выходной поток, пишущий в файл;
+ `FilterWriter` - абстрактный класс, предоставляющий интерфейс для классов-надстроек;
+ `OutputStreamWriter` - выходной поток, транслирующий байты в символы;
+ `PipedWriter` - выходной канал;
+ `PrintWriter` - выходной поток символов, включающий методы `print()` и `println()`;
+ `StringWriter` - выходной поток, пишущий в строку;

[к оглавлению](#потоки-ввода-вывода)

## В чем отличие класса `PrintWriter` от `PrintStream`?
Прежде всего, в классе `PrintWriter` применен усовершенствованный способ работы с символами Unicode и другой механизм буферизации вывода: в классе PrintStream буфер вывода сбрасывался всякий раз, когда вызывался метод `print()` или `println()`, а при использовании класса `PrintWriter` существует возможность отказаться от автоматического сброса буферов, выполняя его явным образом при помощи метода `flush()`.

Кроме того, методы класса `PrintWriter` никогда не создают исключений. Для проверки ошибок необходимо явно вызвать метод `checkError()`.

[к оглавлению](#потоки-ввода-вывода)

## Чем отличаются и что общего у `InputStream`, `OutputStream`, `Reader`, `Writer`?
+ `InputStream` и его наследники - совокупность для получения байтовых данных из различных источников;
+ `OutputStream` и его наследники - набор классов определяющих потоковый байтовый вывод;
+ `Reader` и его наследники определяют потоковый ввод символов Unicode;
+ `Writer` и его наследники определяют потоковый вывод символов Unicode.

[к оглавлению](#потоки-ввода-вывода)

## Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?
+ `OutputStreamWriter` — «мост» между классом `OutputStream` и классом `Writer`. Символы, записанные в поток, преобразовываются в байты.
```java
OutputStream outputStream = new FileOutputStream("c:\\data\\output.txt");
Writer outputStreamWriter = new OutputStreamWriter(outputStream, "UTF-8");
outputStreamWriter.write("Hello World");
outputStreamWriter.close();
```
+ `InputStreamReader` — аналог для чтения. При помощи методов класса `Reader` читаются байты из потока `InputStream` и далее преобразуются в символы.
```java
InputStream inputStream = new FileInputStream("c:\\data\\input.txt");
Reader inputStreamReader = new InputStreamReader(inputStream, "UTF-8");
int data = inputStreamReader.read();
while(data != -1){
    char theChar = (char) data;
    data = inputStreamReader.read();
}
inputStreamReader.close();
```
[к оглавлению](#потоки-ввода-вывода)

## Какие классы позволяют ускорить чтение/запись за счет использования буфера?
+ `BufferedInputStream(InputStream in)`/`BufferedInputStream(InputStream in, int size)`,
+ `BufferedOutputStream(OutputStream out)`/`BufferedOutputStream(OutputStream out, int size)`,
+ `BufferedReader(Reader r)`/`BufferedReader(Reader in, int sz)`,
+ `BufferedWriter(Writer out)`/`BufferedWriter(Writer out, int sz)`

[к оглавлению](#потоки-ввода-вывода)

## Какой класс предназначен для работы с элементами файловой системы?
`File` работает непосредственно с файлами и каталогами. Данный класс позволяет создавать новые элементы и получать информацию существующих: размер, права доступа, время и дату создания, путь к родительскому каталогу.

[к оглавлению](#потоки-ввода-вывода)

## Какие методы класса `File` вы знаете?
Наиболее используемые методы класса `File`:
+ `boolean createNewFile()`: делает попытку создать новый файл;
+ `boolean delete()`: делает попытку удалить каталог или файл;
+ `boolean mkdir()`: делает попытку создать новый каталог;
+ `boolean renameTo(File dest)`: делает попытку переименовать файл или каталог;
+ `boolean exists()`: проверяет, существует ли файл или каталог;
+ `String getAbsolutePath()`: возвращает абсолютный путь для пути, переданного в конструктор объекта;
+ `String getName()`: возвращает краткое имя файла или каталога;
+ `String getParent()`: возвращает имя родительского каталога;
+ `boolean isDirectory()`: возвращает значение `true`, если по указанному пути располагается каталог;
+ `boolean isFile()`: возвращает значение `true`, если по указанному пути находится файл;
+ `boolean isHidden()`: возвращает значение `true`, если каталог или файл являются скрытыми;
+ `long length()`: возвращает размер файла в байтах;
+ `long lastModified()`: возвращает время последнего изменения файла или каталога;
+ `String[] list()`: возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге;
+ `File[] listFiles()`: возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге.

[к оглавлению](#потоки-ввода-вывода)

## Что вы знаете об интерфейсе `FileFilter`?
Интерфейс `FileFilter` применяется для проверки, попадает ли объект `File` под некоторое условие. Этот интерфейс содержит единственный метод `boolean accept(File pathName)`. Этот метод необходимо переопределить и реализовать. Например:

```java
public boolean accept(final File file) {
    return file.isExists() && file.isDirectory();
}
```
[к оглавлению](#потоки-ввода-вывода)

## Как выбрать все элементы определенного каталога по критерию (например, с определенным расширением)?
Метод `File.listFiles()` возвращает массив объектов `File`, содержащихся в каталоге. Метод может принимать в качестве параметра объект класса, реализующего `FileFilter`. Это позволяет включить в список только те элементы, для которых метод `accept` возвращает `true` (критерием может быть длина имени файла или его расширение).
```java
public class FileDemo {
   public static void main(String[] args) {
      File f = null;
      File[] paths;
      try{      
         // create new file
         f = new File("c:/test");
         
         // returns pathnames for files and directory
         paths = f.listFiles();
         
         // for each pathname in pathname array
         for(File path:paths)
         {
            // prints file and directory paths
            System.out.println(path);
         }
      }catch(Exception e){
         // if any error occurs
         e.printStackTrace();
      }
   }
}
```
[к оглавлению](#потоки-ввода-вывода)

## Что вы знаете о `RandomAccessFile`?
Класс `java.io.RandomAccessFile` обеспечивает чтение и запись данных в произвольном месте файла. Он не является частью иерархии `InputStream` или `OutputStream`. Это полностью отдельный класс, имеющий свои собственные (в большинстве своем _native_) методы. Объяснением этого может быть то, что `RandomAccessFile` имеет во многом отличающееся поведение по сравнению с остальными классами ввода/вывода так как позволяет, в пределах файла, перемещаться вперед и назад.

`RandomAccessFile` имеет такие специфические методы как:
+ `getFilePointer()` для определения текущего местоположения в файле;
+ `seek()` для перемещения на новую позицию в файле;
+ `length()` для выяснения размера файла;
+ `setLength()` для установки размера файла;
+ `skipBytes()` для того, чтобы попытаться пропустить определённое число байт;
+ `getChannel()` для работы с уникальным файловым каналом, ассоциированным с заданным файлом;
+ методы для выполнения обычного и форматированного вывода из файла (`read()`, `readInt()`, `readLine()`, `readUTF()` и т.п.);
+ методы для обычной или форматированной записи в файл с прямым доступом (`write()`, `writeBoolean()`, `writeByte()` и т.п.).

Так же следует отметить, что конструкторы `RandomAccessFile` требуют второй аргумент, указывающий необходимый режим доступа к файлу - только чтение (`"r"`), чтение и запись (`"rw"`) или иную их разновидность.

[к оглавлению](#потоки-ввода-вывода)

## Какие режимы доступа к файлу есть у `RandomAccessFile`?
+ `"r"` открывает файл только для чтения. Запуск любых методов записи данных приведет к выбросу исключения `IOException`.
+ `"rw"` открывает файл для чтения и записи. Если файл еще не создан, то осуществляется попытка создать его.
+ `"rws"` открывает файл для чтения и записи подобно `"rw"`, но требует от системы при каждом изменении содержимого файла или метаданных синхронно записывать эти изменения на физический носитель.
+ `"rwd"` открывает файл для чтения и записи подобно `"rws"`, но требует от системы синхронно записывать изменения на физический носитель только при каждом изменении содержимого файла. Если изменяются метаданные, синхронная запись не требуется.

[к оглавлению](#потоки-ввода-вывода)

## Какие классы поддерживают чтение и запись потоков в компрессированном формате?
+ `DeflaterOutputStream` - компрессия данных в формате deflate.
+ `Deflater` - компрессия данных в формат ZLIB
+ `ZipOutputStream` - потомок `DeflaterOutputStream` для компрессии данных в формат Zip.
+ `GZIPOutputStream` - потомок `DeflaterOutputStream` для компрессии данных в формат GZIP.
+ `InflaterInputStream` - декомпрессия данных в формате deflate.
+ `Inflater` - декомпрессия данных в формате ZLIB
+ `ZipInputStream` - потомок `InflaterInputStream` для декомпрессии данных в формате Zip.
+ `GZIPInputStream` - потомок `InflaterInputStream` для декомпрессии данных в формате GZIP.

[к оглавлению](#потоки-ввода-вывода)

## Существует ли возможность перенаправить потоки стандартного ввода/вывода?
Класс `System` позволяет вам перенаправлять стандартный ввод, вывод и поток вывода ошибок, используя простой вызов статического метода:

+ `setIn(InputStream)` - для ввода;
+ `setOut(PrintStream)` - для вывода;
+ `setErr(PrintStream)` - для вывода ошибок.

[к оглавлению](#потоки-ввода-вывода)

## Какой символ является разделителем при указании пути в файловой системе?
Для различных операционных систем символ разделителя различается. Для Windows это `\`, для Linux - `/`. 

В Java получить разделитель для текущей операционной системы можно через обращение к статическому полю `File.separator`.

[к оглавлению](#потоки-ввода-вывода)

## Что такое _«абсолютный путь»_ и _«относительный путь»_?
__Абсолютный (полный) путь__ — это путь, который указывает на одно и то же место в файловой системе, вне зависимости от текущей рабочей директории или других обстоятельств. Полный путь всегда начинается с корневого каталога. 

__Относительный путь__ представляет собой путь по отношению к текущему рабочему каталогу пользователя или активного приложения.

[к оглавлению](#потоки-ввода-вывода)

## Что такое _«символьная ссылка»_?
__Символьная (символическая) ссылка__ (также «симлинк», Symbolic link) — специальный файл в файловой системе, в котором, вместо пользовательских данных, содержится путь к файлу, который должен быть открыт при попытке обратиться к данной ссылке (файлу). Целью ссылки может быть любой объект: например, другая ссылка, файл, каталог или даже несуществующий файл (в последнем случае, при попытке открыть его, должно выдаваться сообщение об отсутствии файла).

Символьные ссылки используются для более удобной организации структуры файлов на компьютере, так как:

+ позволяют для одного файла или каталога иметь несколько имён и различных атрибутов;
+ свободны от некоторых ограничений, присущих жёстким ссылкам (последние действуют только в пределах одной файловой системы (одного раздела) и не могут ссылаться на каталоги).

[к оглавлению](#потоки-ввода-вывода)

## Как работает метод read?
+ Почему метод возвращает int а не byte?
+ Почему возвращается byte как int в диапазоне от 0 до 255?
+ Почему метод не может возвращать byte?
+ Что вернет метод если он считает -1 из входного потока?
__Почему метод read() класса InputStream возвращает int, а не byte?__
Попробуйте выполнить такой код:
```java
byte myByte = -3; // 11111101
byte[] myArray = {myByte};
InputStream in = new ByteArrayInputStream(myArray);
int myInt = in.read();
System.out.println(myInt); // 253
```
В консоль выводится 253, а не -3.
Почему так происходит?
Тип данных int в Java является дополненнным до двух целым числом и использует 32 бита вместо 8.
В 32х битном виде число 253 будет:
```java
00000000000000000000000011111101
```
т.е. метод read() возвращает не само значение byte, а его представление в 32х битном виде.
__Как хранятся значения в int и в byte ?__
```java
 число | 32 bit                           |   8 bit  |
  -----   --------------------------------   --------
|   . . |  . . . . . . . . . . . . . . . . |
|   . . |  . . . . . . . . . . . . . . . . |
|  -128 | 11111111111111111111111110000000 | 10000000 |
|  -127 | 11111111111111111111111110000001 | 10000001 |
|  -126 | 11111111111111111111111110000010 | 10000010 |
|  -125 | 11111111111111111111111110000011 | 10000011 |
|   . . |  . . . . . . . . . . . . . . . . |  . . . . |
|   . . |  . . . . . . . . . . . . . . . . |  . . . . |
|    -2 | 11111111111111111111111111111110 | 11111110 |
|    -1 | 11111111111111111111111111111111 | 11111111 |
|     0 | 00000000000000000000000000000000 | 00000000 |
|     1 | 00000000000000000000000000000001 | 00000001 |
|     2 | 00000000000000000000000000000010 | 00000010 |
|   . . |  . . . . . . . . . . . . . . . . |  . . . . |
|   . . |  . . . . . . . . . . . . . . . . |  . . . . |
|   125 | 00000000000000000000000001111101 | 01111101 |
|   126 | 00000000000000000000000001111110 | 01111110 |
|   127 | 00000000000000000000000001111111 | 01111111 |
|   . . |  . . . . . . . . . . . . . . . . |
|   . . |  . . . . . . . . . . . . . . . . |
```
Диапазон byte в Java лежит от -128 до 127, а возвращаемое значение метода read() лежит в диапазоне от 0 до 255
__Что происходит с числом byte в методе read()?__
Чтобы получить представление byte в int в методе read() используется побитовое «И» c числом 255, т.е. убираем лидирующие единицы.
```java
| число | 32 bit                           |
  -----   --------------------------------
|    -3 | 11111111111111111111111111111101 |
 И
|   255 | 00000000000000000000000011111111 |
 =
|   253 | 00000000000000000000000011111101 |
```
Чтобы из представления получить обратно значение byte в int, нужно выполнить обратную операцию побитовое «ИЛИ» c числом -256, т.е. добавляем лидирующие единицы.
```java
| число | 32 bit                           |
  -----   --------------------------------
|   253 | 00000000000000000000000011111101 |
 ИЛИ
|  -256 | 11111111111111111111111100000000 |
 =
|    -3 | 11111111111111111111111111111101 |
```
__Что происходит с числом byte == -1 в методе read()?__
То же самое: убираем лидирующие единицы.
```java
| число | 32 bit                           |
  -----   --------------------------------
|    -1 | 11111111111111111111111111111111 |
 И
|   255 | 00000000000000000000000011111111 |
 =
|   255 | 00000000000000000000000011111111 |
```
На все 4 вопроса вообще один ответ. Возвращается int потому что надо такой тип, который может вместить в себя один байт (реальные данные) плюс одно служебное значение (это тот самый -1), которое является признаком окончания чтения.

[к оглавлению](#потоки-ввода-вывода)

## Разница между методами __`flush()`__ и __`close()`__ ?
__flush()__ просто следит за тем, чтобы любые буферизованные данные записывались на диск (в данном случае - в более общем плане, сбрасывались через любой канал IO, который вы используете). После этого вы можете писать в поток (или записывать).

__close()__ очищает данные и указывает, что данных больше нет. Он закрывает любые дескрипторы файлов, сокеты или что угодно. Затем вы больше не можете писать в поток (или писатель).

Обратите внимание, что без вызовов данных `flush()` все еще могут быть записаны в соответствующий канал ввода-вывода - это просто, что некоторые данные могут быть буферизованы.

`close()`, как правило, вызывает также `flush()`, но недавно мне было сказано, что в некоторых реализациях JDK любые исключения, возникающие при промывке как части закрытия, проглатываются: (

[к оглавлению](#потоки-ввода-вывода)

## На каких паттернах основана иерархия потоков ввода вывода?
+ __Декоратор__ — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки.
+ Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные оборачиваемые объекты имеют общий интерфейс.
+ Используется: Все подклассы `java.io.InputStream`, `OutputStream`, `Reader` и `Writer` имеют конструктор, принимающий объекты этих же классов.
+ __Адаптер__ — это структурный паттерн, который позволяет подружить несовместимые объекты.
+ Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в вызовы понятные другому.
+ Используется: `java.io.InputStreamReader(InputStream)` (возвращает объект Reader) `java.io.OutputStreamWriter(OutputStream)` (возвращает объект Writer)
#### [Декоратор-->](https://refactoring.guru/ru/design-patterns/decorator/java/example)
#### [Адаптер-->](https://refactoring.guru/ru/design-patterns/adapter/java/example)

[к оглавлению](#потоки-ввода-вывода)

## Когда использовать `Scanner` и `BufferedReader`. Различия и сходство?
+ `BufferedReader` предназначен для чтения потока символов с буферизацией.
+ `Scanner` предназначен для разбора входящего набора данных (файл, поток байтов, поток символов, канал, строка) на составляющие - числа и строки, с учетом форматов, шаблонов, разных разделителей.
+ `java.util.Scanner class` — это простой текстовый сканер, который может анализировать примитивные типы и строки. Он внутренне использует регулярные выражения для чтения различных типов.
+ `Java.io.BufferedReader` читает текст из потока ввода символов, буферизуя символы, чтобы обеспечить эффективное чтение последовательности символов

В классе Scanner, если мы вызываем метод nextLine () после любого из семи методов nextXXX (), тогда nextLine () не считывает значения из консоли, и курсор не входит в консоль, он пропускает этот шаг. Методы nextXXX (): nextInt (), nextFloat (), nextByte (), nextShort (), nextDouble (), nextLong (), next ().

В классе BufferReader такой проблемы нет. Эта проблема возникает только для класса Scanner, поскольку методы nextXXX () игнорируют символ новой строки, а nextLine () читает только до первого символа новой строки. Если мы используем еще один вызов метода nextLine () между nextXXX () и nextLine (), то эта проблема не возникнет, потому что nextLine () будет использовать символ новой строки. Смотрите это для исправленной программы. Эта проблема такая же, как и scanf (), за которой следует get () в C / C ++ .
Эту проблему также можно решить, используя next () вместо nextLine () для получения ввода строк, как показано здесь .

__Другие отличия:__
+ BufferedReader работает синхронно, а Scanner — нет. BufferedReader следует использовать, если мы работаем с несколькими потоками.
+ BufferedReader имеет значительно большую буферную память, чем Scanner.
+ Сканер имеет небольшой буфер (1KB буфер символов) в отличие от BufferedReader (8KB байтовый буфер), но этого более чем достаточно.
+ BufferedReader немного быстрее по сравнению со сканером, потому что сканер выполняет синтаксический анализ входных данных, а BufferedReader просто читает последовательность символов.

#### [РАЗНИЦА МЕЖДУ СКАНЕРОМ И КЛАССОМ BUFFERREADER В JAVA-->](http://espressocode.top/difference-between-scanner-and-bufferreader-class-in-java/)

[к оглавлению](#потоки-ввода-вывода)



## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
#### [Основные отличия Java IO и Java NIO-->](https://habr.com/ru/post/235585/)
#### [Input/Output-->](https://quizlet.com/354783732/inputoutput-flash-cards/)
#### [Считывание с клавиатуры — «ридеры»-->](https://javarush.ru/groups/posts/1919-schitihvanie-s-klaviaturih--riderih)
#### [Класс Scanner-->](ttps://javarush.ru/groups/posts/klass-scanner)
#### [Система ввода/вывода-->](http://developer.alexanderklimov.ru/android/java/io.php)
#### [Класс InputStream-->](http://developer.alexanderklimov.ru/android/java/inputstream.php)
#### [BufferedReader и BufferedWriter-->](https://javarush.ru/groups/posts/593-bufferedreader-i-bufferedwritter)
#### [Ввод-вывод в Java. Классы FileInputStream, FileOutputStream, BufferedInputStream-->](https://javarush.ru/groups/posts/2020-vvod-vihvod-v-java-klassih-fileinputstream-fileoutputstream-bufferedinputstream)
#### [ГЛАВА 18. Потоки ввода/вывода-->](http://www.realcoding.net/articles/glava-18-potoki-vvodavyvoda.html)
#### [Потоки ввода, InputStream-->](http://java-online.ru/java-inputstream.xhtml)
#### [Ссылка-->](https://www.youtube.com/watch?v=DElNhj71YCk)
#### [Ссылка-->](https://www.youtube.com/watch?v=DElNhj71YCk)
#### [Ссылка-->](https://www.youtube.com/watch?v=DElNhj71YCk)


[к оглавлению](#потоки-ввода-вывода)
