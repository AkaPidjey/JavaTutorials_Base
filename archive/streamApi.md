[Java Tutorials](README.md)

# Stream API и Лямбда.

## Stream API
1) [Что такое Stream API? Для чего нужны стримы?](#Что-такое-Stream-API-Для-чего-нужны-стримы)
2) [Какие существуют способы создания стрима?](#Какие-существуют-способы-создания-стрима)
3) [Как из коллекции создать стрим?](#Как-из-коллекции-создать-стрим)
4) [В чем разница между `Collection` и `Stream`?](#В-чем-разница-между-collection-и-stream)
5) [Какие промежуточные методы работы со стримами вы знаете?](#Какие-промежуточные-методы-работы-со-стримами-вы-знаете)
6) [Какие конечные методы работы со стримами вы знаете?](#Какие-конечные-методы-работы-со-стримами-вы-знаете)
7) [Расскажите о параллельной обработке в Java 8.](#Расскажите-о-параллельной-обработке-в-Java-8)
8) [Что такое IntStream и DoubleStream?](#Что-такое-IntStream-и-DoubleStream)
9) [Для чего нужен метод `collect()` в стримах?](#Для-чего-нужен-метод-collect-в-стримах)
10) [Для чего в стримах применяются методы `forEach()` и `forEachOrdered()`?](#Для-чего-в-стримах-применяются-методы-foreach-и-foreachordered)
11) [Для чего в стримах предназначены методы `map()` и `mapToInt()`, `mapToDouble()`, `mapToLong()`?](#Для-чего-в-стримах-предназначены-методы-map-и-maptoint-maptodouble-maptolong)
12) [Какова цель метода `filter()` в стримах?](#Какова-цель-метода-filter-в-стримах)
13) [Для чего в стримах предназначен метод `limit()`?](#Для-чего-в-стримах-предназначен-метод-limit)
14) [Для чего в стримах предназначен метод `sorted()`?](#Для-чего-в-стримах-предназначен-метод-sorted)
15) [Для чего в стримах предназначены методы `flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()`?](#Для-чего-в-стримах-предназначены-методы-flatmap-flatmaptoint-flatmaptodouble-flatmaptolong)
16) [В чем разница методов `peek()` и `forEach()`?](#В-чем-разница-методов-peek-и-forEach)
17) [В чем разница методов `map()` и `flatMap()`?](#В-чем-разница-методов-map-и-flatMap)
18) [В чем разница методов `range()` и `rangeClosed()`?](#В-чем-разница-методов-range-и-rangeClosed)
19) [Можно ли конкатенировать Стримы? Если да то каким методом? Можно ли получить пустой стрим?](#Можно-ли-конкатенировать-Стримы-Если-да-то-каким-методом-Можно-ли-получить-пустой-стрим)
20) [Отличие Стримов от Итераторов?](#Отличие-Стримов-от-Итераторов)
21) [Отличие Стримов от Коллекций?](#Отличие-Стримов-от-Коллекций) 
22) [На какие группы можно поделить Стримы. Какие бывают Стримы?](#На-какие-группы-можно-поделить-Стримы-Какие-бывают-Стримы) 
23) [Что такое ленивая инициализация стрима?](#Что-такое-ленивая-инициализация-стрима)
24) [Расскажите о параллельной обработке в Java 8.](#Расскажите-о-параллельной-обработке-в-java-8)
25) [Что такое `StringJoiner`?](#Что-такое-stringjoiner)
26) [Что такое `Optional`?](#Что-такое-optional)
27) [Как вывести на экран 10 случайных чисел, используя `forEach()`?](#Как-вывести-на-экран-10-случайных-чисел-используя-foreach)
28) [Как можно вывести на экран уникальные квадраты чисел используя метод `map()`?](#Как-можно-вывести-на-экран-уникальные-квадраты-чисел-используя-метод-map)
29) [Как вывести на экран количество пустых строк с помощью метода `filter()`?](#Как-вывести-на-экран-количество-пустых-строк-с-помощью-метода-filter)
30) [Как вывести на экран 10 случайных чисел в порядке возрастания?](#Как-вывести-на-экран-10-случайных-чисел-в-порядке-возрастания)
31) [Как найти максимальное число в наборе?](#Как-найти-максимальное-число-в-наборе)
32) [Как найти минимальное число в наборе?](#Как-найти-минимальное-число-в-наборе)
33) [Как получить сумму всех чисел в наборе?](#Как-получить-сумму-всех-чисел-в-наборе)
34) [Как получить среднее значение всех чисел?](#Как-получить-среднее-значение-всех-чисел)

## Лямбда
1) [Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?](#Что-такое-лямбда-Какова-структура-и-особенности-использования-лямбда-выражения)
2) [К каким переменным есть доступ у лямбда-выражений?](#К-каким-переменным-есть-доступ-у-лямбда-выражений)
3) [Как отсортировать список строк с помощью лямбда-выражения?](#Как-отсортировать-список-строк-с-помощью-лямбда-выражения)
4) [Что такое «ссылка на метод»? Какие виды ссылок на методы вы знаете?](#Что-такое-ссылка-на-метод-Какие-виды-ссылок-на-методы-вы-знаете)
5) [Объясните выражение `System.out::println`.](#Объясните-выражение-systemoutprintln)
6) [Любой анонимный класс можно заменить на лямбду?](#Любой-анонимный-класс-можно-заменить-на-лямбду)
7) [Связь лямбда с анонимным классом?](#Связь-лямбда-с-анонимным-классом)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)
+ [к оглавлению](#Stream-API-и-Лямбда)


## Stream
## Что такое Stream API? Для чего нужны стримы?
Интерфейс `java.util.Stream` представляет собой последовательность элементов, над которой можно производить различные операции.

Операции над стримами бывают или _промежуточными (intermediate)_ или _конечными (terminal)_. Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом. 

Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными.

У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не происходит (похоже на создание объекта `Thread` или `Runnable`, без вызова `start()`).

Стримы создаются на основе источников каких-либо, например классов из `java.util.Collection`. 

Ассоциативные массивы (maps), например, `HashMap`, не поддерживаются.

Операции над стримами могут выполняться как последовательно, так и параллельно.

Потоки не могут быть использованы повторно. Как только была вызвана какая-нибудь конечная операция, поток закрывается.

Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных `int`, `long` и `double`: `IntStream`, `LongStream` и `DoubleStream`. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями: 

+ используют специализированные лямбда-выражения, например, `IntFunction` или `IntPredicate` вместо `Function` и `Predicate`; 
+ поддерживают дополнительные конечные операции `sum()`, `average()`, `mapToObj()`.

+ [Вопрос#1  К оглавлению](#Stream-API-и-Лямбда)

## Какие существуют способы создания стрима?
1) Пустой стрим: Stream.empty()
2) Стрим из List: list.stream()
3) Стрим из Map: map.entrySet().stream()
4) Стрим из массива: Arrays.stream(array)
5) Стрим из указанных элементов: Stream.of("1", "2", "3")
6) Можно получить из BufferedReader при помощи метода lines(), который вернет поток строк из потока символов.
7) Из директории на диске при помощи методов Files.list() и Files.walk()
8) Можно получить из строки методом chars(), будет IntStream с символами.
9) Можно порождать динамически, генерировать при помощи supplier.
10) Итерированием какой-то функции
11) Можно получить диапазон чисел в виде стрима range и rangeClosed
12) Конкатенацией других стримов

+ Из коллекции:
```java 
Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();
```
+ Из набора значений:
```java 
Stream<String> fromValues = Stream.of("x", "y", "z");
```
+ Из массива:
```java 
Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});
```
+ Из файла (каждая строка в файле будет отдельным элементом в стриме):
```java 
Stream<String> fromFile = Files.lines(Paths.get("input.txt"));
```
+ Из строки:
```java 
IntStream fromString = "0123456789".chars();
```
+ С помощью `Stream.builder()`:
```java 
Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();
```
+ С помощью `Stream.iterate()` (бесконечный):
```java 
Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);
```
+ С помощью `Stream.generate()` (бесконечный):
```java 
Stream<String> fromGenerate = Stream.generate(() -> "0");
```
+ [Вопрос#2  К оглавлению](#Stream-API-и-Лямбда)

## Как из коллекции создать стрим?
```java
Collection<String> collection = Arrays.asList("a1", "a2", "a3");
Stream<String> streamFromCollection = collection.stream();
```
+ [Вопрос#3  К оглавлению](#Stream-API-и-Лямбда)

## В чем разница между `Collection` и `Stream`?
Коллекции позволяют работать с элементами по-отдельности, тогда как стримы так делать не позволяют, но вместо этого предоставляют возможность выполнять функции над данными как над одним целым.

Также стоит отметить важность самой концепции сущностей: `Collection` - это прежде всего воплощение _Структуры Данных_. Например, `Set` не просто хранит в себе элементы, он реализует идею множества с уникальными элементами,
тогда как `Stream`, это прежде всего абстракция необходимая для реализации _конвеера вычислений_, собственно поэтому, результатом работы конвеера являются те или иные _Структуры Данных_ или же результаты проверок/поиска и т.п. 
+ [Вопрос#4  К оглавлению](#Stream-API-и-Лямбда)

## Какие промежуточные методы работы со стримами вы знаете?
+ `filter()` фильтрует стрим, возвращая только те элементы, что проходят по условию (Predicate)
Проверяет значение на “true” и “false”
+ `skip()` позволяет пропустить определённое количество элементов в начале;
+ `distinct()` возвращает стрим без дубликатов (для метода `equals()`);
+ `map()` Метод map() заданным образом преобразует каждый элемент стрима, потом преобразует все объекты в итоговый стрим. 
+ `peek()` возвращает тот же стрим, применяя к каждому элементу функцию; Предполагается, что `map()` получает на вход один объект, а возвращает другой. Возможно, того же типа, но другой. `peek()` - это частный случай `map()`, который возвращает тот же самый объект, который получил на входе, возможно, с изменённым внутренним состоянием. Конечно, можно использовать для этого `map()`, но есть нюансы. Во-первых, `peek()` на одну строчку короче - не нужно писать `return`, Java и так знает, что нужно возвращать. Во-вторых, вы страхуетесь от ошибок - из `peek()` невозможно вернуть не тот объект, который пришёл на вход.
+ `limit()` позволяет ограничить выборку определенным количеством первых элементов;
+ `sorted()` позволяет сортировать значения либо в натуральном порядке, либо задавая `Comparator`;
+ `mapToInt()`, `mapToDouble()`, `mapToLong()` - аналоги `map()` возвращающие стрим числовых примитивов;
+ `flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()` - похожи на `map()`, но могут создавать из одного элемента несколько.
flatMap возвращает по стриму для каждого объекта в первоначальном стриме, а затем результирующие потоки объединяются в исходный стрим.

Для числовых стримов дополнительно доступен метод `mapToObj()`, который преобразует числовой стрим обратно в объектный.
+ [Вопрос#5  К оглавлению](#Stream-API-и-Лямбда)

## Какие конечные методы работы со стримами вы знаете?
+ `findFirst()` возвращает первый элемент;
+ `findAny()` возвращает любой подходящий элемент;
+ `collect()` представление результатов в виде коллекций и других структур данных;
+ `count()` возвращает количество элементов;
+ `anyMatch()` возвращает `true`, если условие выполняется хотя бы для одного элемента;
+ `noneMatch()` возвращает `true`, если условие не выполняется ни для одного элемента;
+ `allMatch()` возвращает `true`, если условие выполняется для всех элементов;
+ `min()` возвращает минимальный элемент, используя в качестве условия `Comparator`;
+ `max()` возвращает максимальный элемент, используя в качестве условия `Comparator`;
+ `forEach()` применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);
+ `forEachOrdered()` применяет функцию к каждому объекту с сохранением порядка элементов;
+ `toArray()` возвращает массив значений;
+ `reduce()`позволяет выполнять агрегатные функции и возвращать один результат. Результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.

Для числовых стримов дополнительно доступны:
+ `sum()` возвращает сумму всех чисел;
+ `average()` возвращает среднее арифметическое всех чисел.

Терминальный метод можно вызвать только один раз.
Все оконечные методы возвращают `Optional` - оболочка ответа
(этот специальный тип ввели чтобы не возвращать null)
+ [Вопрос#6  К оглавлению](#Stream-API-и-Лямбда)

## Расскажите о параллельной обработке в Java 8.
Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта `Stream` метод `parallel()`. А обратный метод - `sequential()`. Кроме того, можно также использовать блокирующий метод `parallelStream()` интерфейса `Collection` для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.
Работает на фреймворке fork/join.
+ [Вопрос#7  К оглавлению](#Stream-API-и-Лямбда)

## Что такое IntStream и DoubleStream?
В Java 8 создание Stream-ов примитивов напрямую невозможно, из-за дженериков. Но разработчики сделали 3 Stream-а примитивов : `IntStream`, `LongStream`, `DoubleStream`. Работает быстрее, чем стрим с классами-обертками.
Поддерживают дополнительные терминальный методы `sum()`, `average()`, `mapToObj()`
+ [Вопрос#8  К оглавлению](#Stream-API-и-Лямбда)

## Для чего нужен метод `collect()` в стримах?
Метод `collect()` является конечной операцией, которая используется для представление результата в виде коллекции или какой-либо другой структуры данных.

`collect()` принимает на вход `Collector<Тип_источника, Тип_аккумулятора, Тип_результата>`, который содержит четыре этапа: _supplier_ - инициализация аккумулятора, _accumulator_ - обработка каждого элемента, _combiner_ - соединение двух аккумуляторов при параллельном выполнении, _[finisher]_ - необязательный метод последней обработки аккумулятора. В Java 8 в классе `Collectors` реализовано несколько распространённых коллекторов:

+ `toList()`, `toCollection()`, `toSet()` - представляют стрим в виде списка, коллекции или множества;
+ `toConcurrentMap()`, `toMap()` - позволяют преобразовать стрим в `Map`;
+ `averagingInt()`, `averagingDouble()`, `averagingLong()` - возвращают среднее значение;
+ `summingInt()`, `summingDouble()`, `summingLong()` - возвращает сумму;
+ `summarizingInt()`, `summarizingDouble()`, `summarizingLong()` - возвращают `SummaryStatistics` с разными агрегатными значениями;
+ `partitioningBy()` - разделяет коллекцию на две части по соответствию условию и возвращает их как `Map<Boolean, List>`;
+ `groupingBy()` - разделяет коллекцию на несколько частей и возвращает `Map<N, List<T>>`;
+ `mapping()` - дополнительные преобразования значений для сложных `Collector`-ов.

Так же существует возможность создания собственного коллектора через `Collector.of()`:

```java
Collector<String, List<String>, List<String>> toList = Collector.of(
    ArrayList::new,
    List::add,
    (l1, l2) -> { l1.addAll(l2); return l1; }
);
```
+ [Вопрос#9  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах применяются методы `forEach()` и `forEachOrdered()`?
+ `forEach()` применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется;
+ `forEachOrdered()` применяет функцию к каждому объекту стрима с сохранением порядка элементов.

+ [Вопрос#10  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах предназначены методы `map()` и `mapToInt()`, `mapToDouble()`, `mapToLong()`?
Метод `map()` является промежуточной операцией, которая заданным образом преобразует каждый элемент стрима.

`mapToInt()`, `mapToDouble()`, `mapToLong()` - аналоги `map()`, возвращающие соответствующий числовой стрим (то есть стрим из числовых примитивов):

```java
Stream
    .of("12", "22", "4", "444", "123")
    .mapToInt(Integer::parseInt)
    .toArray(); //[12, 22, 4, 444, 123]
```
+ [Вопрос#11  К оглавлению](#Stream-API-и-Лямбда)

## Какова цель метода `filter()` в стримах?
Метод `filter()` является промежуточной операцией принимающей предикат, который фильтрует все элементы, возвращая только те, что соответствуют условию.
+ [Вопрос#12  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах предназначен метод `limit()`?
Метод `limit()` является промежуточной операцией, которая позволяет ограничить выборку определенным количеством первых элементов.
+ [Вопрос#13  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах предназначен метод `sorted()`?
Метод `sorted()` является промежуточной операцией, которая позволяет сортировать значения либо в натуральном порядке, либо задавая `Comparator`.

Порядок элементов в исходной коллекции остается нетронутым - `sorted()` всего лишь создает его отсортированное представление.
+ [Вопрос#14  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах предназначены методы `flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()`?
Метод `flatMap()` похож на map, но может создавать из одного элемента несколько. Таким образом, каждый объект будет преобразован в ноль, один или несколько других объектов, поддерживаемых потоком.  Наиболее очевидный способ применения этой операции — преобразование элементов контейнера при помощи функций, которые возвращают контейнеры.
```java
Stream
    .of("H e l l o", "w o r l d !")
    .flatMap((p) -> Arrays.stream(p.split(" ")))
    .toArray(String[]::new);//["H", "e", "l", "l", "o", "w", "o", "r", "l", "d", "!"]
```
`flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()` - это аналоги `flatMap()`, возвращающие соответствующий числовой стрим.
+ [Вопрос#15  К оглавлению](#Stream-API-и-Лямбда)

## В чем разница методов `peek()` и `forEach()`?
+ __peek__ - Возвращает тот же стрим, но применяет функцию к каждому элементу стрима, промежуточный
+ __forEach__ - Применяет функцию к каждому объекту стрима, терминальный

+ [Вопрос#16  К оглавлению](#Stream-API-и-Лямбда)

## В чем разница методов `map()` и `flatMap()`?
И `map` и `flatMap` могут быть применены к стриму `Stream<T>` и оба возвращают стрим `Stream<R>`. 
Можно парсануть to Int:     String.mapToInt(Integer.parseInt())

Разница заключается в том, что операция `map` создает одно выходное значение для каждого входного значения, тогда как операция 
`flatMap` создает произвольное число(ноль или больше) значений для каждого входного значения.
+ [Вопрос#17  К оглавлению](#Stream-API-и-Лямбда)

## В чем разница методов `range()` и `rangeClosed()`?
+ int sum = IntStream.range(1, 10) диапазон не вкл.конечное значение, т.е. до 10-1
  .sum();//returns 45
+ int sum = IntStream.rangeClosed(1, 10)          включительно 10.
  .sum();//returns 55
Разница в том, что конец range () является эксклюзивным, в то время как он включен в rangeClosed () .

+ [Вопрос#18  К оглавлению](#Stream-API-и-Лямбда)

## Можно ли конкатенировать Стримы? Если да то каким методом? Можно ли получить пустой стрим?
Статический метод `concat()` объединяет элементы двух потоков, возвращая объединенный поток:
Можно получить пустой стрим `Stream.empty()` зачем, при выходе из параметра потока, избежать искл.
+ [Вопрос#19  К оглавлению](#Stream-API-и-Лямбда)

## Отличие Стримов от Итераторов?
+ 1 Разные задачи. Задачи Итератора - обойти коллекцию. Задача Стрима - обойти коллекцию.
+ 2 Стримы выигрывают при работе в парралельном режиме.
+ 3 Разные уровни абстракции и Стримов гораздо выше.
+ 4 Через итератор больше кода и стримы гораздо сложней по логике исполнения.

+ [Вопрос#20  К оглавлению](#Stream-API-и-Лямбда)

## Отличие Стримов от Коллекций?
+ 1 Принцип работы. Коллекции работают с элементами по отдельности, а Стримы с потоком в целом.
+ 2 В Коллекциях можно добавлять, удалять, вставлять элементы в середину, а в Потоках - нет.
+ 3 Разные уровни абстракции. В Потоке элементы от нас скрыты.
+ 4 Логическая задумка Коллекций. Например Сет и ЛинкетСет.
+ 5 Для Стримов возможность сразу работать со всеми данными.

+ [Вопрос#21  К оглавлению](#Stream-API-и-Лямбда)

## На какие группы можно поделить Стримы. Какие бывают Стримы?
+ __1 Конвеерные и Терминальные(Конечные и бесконечные).__
Конвейерные — возвращают другой stream, то есть работают как builder.
Терминальные — возвращают другой объект, такой как коллекция, примитивы, объекты, Optional и т.д.
+ __2 Последовательные и парралельные.__
Стримы бывают последовательными `sequential` и параллельными `parallel`. Последовательные выполняются только в текущем потоке, а вот параллельные используют общий пул `ForkJoinPool.commonPool()`. При этом элементы разбиваются (если это возможно) на несколько групп и обрабатываются в каждом потоке отдельно. Затем на нужном этапе группы объединяются в одну для предоставления конечного результата.
Чтобы получить параллельный стрим, нужно либо вызвать метод `parallelStream()` вместо `stream()`, либо превратить обычный стрим в параллельный, вызвав промежуточный оператор `parallel`.
С помощью, методов `parallel` и `sequential` можно определять какие операции могут быть параллельными, а какие только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот, то есть:
```java
collection.stream().
peek(...). // операция последовательна
parallel().
map(...). // операция может выполняться параллельно,
sequential().
reduce(...) // операция снова последовательна 
```
!!! Внимание: крайне не рекомендуется использовать параллельные стримы для сколько-нибудь долгих операций (получение данных из базы, сетевых соединений), так как все параллельные стримы работают c одним пулом `fork/join` и такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за того отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты.
+ __3 Объектные и примитивные.__
Кроме объектных стримов Stream<T>, существуют специальные стримы для примитивных типов:
  - IntStream для int,
  - LongStream для long,
  - DoubleStream для double.

+ [Вопрос#22  К оглавлению](#Stream-API-и-Лямбда)

## Что такое ленивая инициализация стрима?
+ 1.Никаких вычислений в стриме не производится, пока не будет вызвана терминальная операция
+ 2.Промежуточные и терминальные, сколько бы мы не сделали промежуточных, пока не выполним терминальный, то никаких данных мы не получим, вызываем терминальным, далее создание стримов.

+ [Вопрос#23  К оглавлению](#Stream-API-и-Лямбда)

## Расскажите о параллельной обработке в Java 8.
Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке процессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют общий `ForkJoinPool` доступный через статический `ForkJoinPool.commonPool()` метод. При этом, если окружение не является многоядерным, то поток будет выполняться как последовательный. Фактически применение параллельных стримов сводится к тому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются конечные операции.

Для создания параллельного потока из коллекции можно также использовать метод `parallelStream()` интерфейса `Collection`. 

Чтобы сделать обычный последовательный стрим параллельным, надо вызвать у объекта `Stream` метод `parallel()`. Метод `isParallel()` позволяет узнать является ли стрим параллельным. 

С помощью, методов `parallel()` и `sequential()` можно определять какие операции могут быть параллельными, а какие только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот: 
```java
collection
.stream()
.peek(...) // операция последовательна
.parallel()
.map(...) // операция может выполняться параллельно,
.sequential()
.reduce(...) // операция снова последовательна 
```
Как правило, элементы передаются в стрим в том же порядке, в котором они определены в источнике данных. При работе с параллельными стримами система сохраняет порядок следования элементов. Исключение составляет метод `forEach()`, который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод `forEachOrdered()`.

Критерии, которые могут повлиять на производительность в параллельных стримах:

+ Размер данных - чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.
+ Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.
+ Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из `ArrayList` легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа `LinkedList` - не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.
+ Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов.
+ Крайне не рекомендуется использовать параллельные стримы для скольких-нибудь долгих операций (например, сетевых соединений), так как все параллельные стримы работают c одним ForkJoinPool, то такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты;
+ Сохранение порядка в параллельных стримах увеличивает издержки при выполнении и если порядок не важен, то имеется возможность отключить его сохранение и тем самым увеличить производительность, использовав промежуточную операцию `unordered()`:

```java
collection.parallelStream()
    .sorted()
    .unordered()
    .collect(Collectors.toList());
```
+ [Вопрос#24  К оглавлению](#Stream-API-и-Лямбда)

## Что такое `StringJoiner`?
Класс `StringJoiner` используется, чтобы создать последовательность строк, разделенных разделителем с возможностью присоединить к полученной строке префикс и суффикс:

```java
StringJoiner joiner = new StringJoiner(".", "prefix-", "-suffix");
for (String s : "Hello the brave world".split(" ")) {
    joiner.add(s);
}
System.out.println(joiner); //prefix-Hello.the.brave.world-suffix
```
+ [Вопрос#25  К оглавлению](#Stream-API-и-Лямбда)

## Что такое `Optional`?
Опциональное значение `Optional` — это контейнер для объекта, который может содержать или не содержать значение `null`. Такая обёртка является удобным средством предотвращения `NullPointerException`, т.к.
имеет некоторые функции высшего порядка, избавляющие от добавления повторяющихся `if null/notNull` проверок:

```java
Optional<String> optional = Optional.of("hello");

optional.isPresent(); // true
optional.ifPresent(s -> System.out.println(s.length())); // 5
optional.get(); // "hello"
optional.orElse("ops..."); // "hello"
```
Замена null-значений, благодаря чему должна повышаться безопасность и читаемость кода.
`findFirst, findAny()`
При написании кода разработчик часто не может знать — будет ли существовать нужный объект на момент исполнения программы или нет, и в таких случаях приходится делать проверки на null. Если такими проверками пренебречь, то рано или поздно (обычно рано) Ваша программа рухнет с NullPointerException. Тесно связан со стримами и лямбдами.
```java
Optional<User> user = Optional.of(repository.findById(userId));
.isPresent() Этот метод возвращает ответ, существует ли искомый объект или нет, в виде Boolean:
.ifPresent()Метод позволяет выполнить какое-то действие, если объект не пустой.
```
+ [Вопрос#26  К оглавлению](#Stream-API-и-Лямбда)

## Как вывести на экран 10 случайных чисел, используя `forEach()`?
```java
(new Random())
    .ints()
    .limit(10)
    .forEach(System.out::println);
```
+ [Вопрос#27  К оглавлению](#Stream-API-и-Лямбда)

## Как можно вывести на экран уникальные квадраты чисел используя метод `map()`?
```java
Stream
    .of(1, 2, 3, 2, 1)
    .map(s -> s * s)
    .distinct()
    .forEach(System.out::println);
```
+ [Вопрос#28  К оглавлению](#Stream-API-и-Лямбда)

## Как вывести на экран количество пустых строк с помощью метода `filter()`?
```java
System.out.println(
    Stream
        .of("Hello", "", ", ", "world", "!")
        .filter(String::isEmpty)
        .count());
```
+ [Вопрос#29  К оглавлению](#Stream-API-и-Лямбда)

## Как вывести на экран 10 случайных чисел в порядке возрастания?
```java
(new Random())
    .ints()
    .limit(10)
    .sorted()
    .forEach(System.out::println);
```
+ [Вопрос#30  К оглавлению](#Stream-API-и-Лямбда)

## Как найти максимальное число в наборе?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt(a -> a)
    .max()
    .getAsInt(); //55
```
+ [Вопрос#31  К оглавлению](#Stream-API-и-Лямбда)

## Как найти минимальное число в наборе?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt(a -> a)
    .min()
    .getAsInt(); //2
```
+ [Вопрос#32  К оглавлению](#Stream-API-и-Лямбда)

## Как получить сумму всех чисел в наборе?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt()
    .sum(); //69
```
+ [Вопрос#33  К оглавлению](#Stream-API-и-Лямбда)

## Как получить среднее значение всех чисел?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt(a -> a)
    .average()
    .getAsDouble(); //13.8
```
+ [Вопрос#34  К оглавлению](#Stream-API-и-Лямбда)



## Лямбда
## Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?
__Лямбда__ представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.

Основу лямбда-выражения составляет _лямбда-оператор_, который представляет стрелку `->`. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

```java
interface Operationable {
    int calculate(int x, int y);
}

public static void main(String[] args) {
    Operationable operation = (x, y) -> x + y;     
    int result = operation.calculate(10, 20);
    System.out.println(result); //30
}
```

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.

+ _Отложенное выполнение (deferred execution) лямбда-выражения_- определяется один раз в одном месте программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.

+ _Параметры лямбда-выражения_ должны соответствовать по типу параметрам метода функционального интерфейса:

```java
operation = (int x, int y) -> x + y;
//При написании самого лямбда-выражения тип параметров разрешается не указывать:
(x, y) -> x + y;
//Если метод не принимает никаких параметров, то пишутся пустые скобки, например,
() -> 30 + 20;
//Если метод принимает только один параметр, то скобки можно опустить:
n -> n * n;
```

+ _Конечные лямбда-выражения_ не обязаны возвращать какое-либо значение.

```java
interface Printable {
    void print(String s);
}
 
public static void main(String[] args) {
    Printable printer = s -> System.out.println(s);
    printer.print("Hello, world");
}
```

+ _Блочные лямбда-выражения_ обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции `if`, `switch`, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор `return`:

```java
Operationable operation = (int x, int y) -> {       
    if (y == 0) {
        return 0;
    }
    else {
        return x / y;
    }
};
```

+ _Передача лямбда-выражения в качестве параметра метода_:

```java
interface Condition {
    boolean isAppropriate(int n);
}

private static int sum(int[] numbers, Condition condition) {
    int result = 0;
    for (int i : numbers) {
        if (condition.isAppropriate(i)) {
            result += i;
        }
    }
    return result;
}

public static void main(String[] args) {
    System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -> n != 0));
} 
```
+ [Вопрос#1  К оглавлению](#Stream-API-и-Лямбда)

## К каким переменным есть доступ у лямбда-выражений?
Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно ссылаться на:

+ неизменяемые (_effectively final_ - не обязательно помеченные как `final`) локальные переменные;
Либо явно финализирована, либо не переписана.
```java
final int bonus = 10;
IntUnaryOperator bonusAdder = (x) -> x + bonus;

Для обхода этого ограничения используют массив единичной длины
int[] counter = new int[1];
IntSupplier sequence1 = () -> counter[0]++;
```
+ поля класса;
+ статические переменные.
+ к параметрам лямбда-выражения, а также свободно объявлять и использовать внутри тела лямбда-выражения любые переменные ???

!!! К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.
+ [Вопрос#2  К оглавлению](#Stream-API-и-Лямбда)

## Как отсортировать список строк с помощью лямбда-выражения?
```java
public static List<String> sort(List<String> list){
    Collections.sort(list, (a, b) -> a.compareTo(b));
    return list;
}
```
+ [Вопрос#3  К оглавлению](#Stream-API-и-Лямбда)

## Что такое «ссылка на метод»? Какие виды ссылок на методы вы знаете?
Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом __method reference (ссылка на метод)__ для непосредственной передачи этого метода. Такая ссылка передается в виде:

+ `ContainingClass::staticMethodName` - Ссылка на статический метод;
+ `containingObject::instanceMethodName` - Ссылка на нестатический метод конкретного объекта;
+ `ContainingType::methodName` - Ссылка на нестатический метод любого объекта конкретного типа;
+ `ClassName::new` - Ссылка на конструктор;

Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.

```java
private interface Measurable {
    public int length(String string);
}

public static void main(String[] args) {
    Measurable a = String::length;
    System.out.println(a.length("abc"));
}
```

Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. Кроме того, они предоставляют компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.
+ [Вопрос#4  К оглавлению](#Stream-API-и-Лямбда)


## Объясните выражение `System.out::println`.
Данное выражение иллюстрирует механизм _instance method reference_: передачи ссылки на метод `println()` статического поля `out` класса `System`.
+ [Вопрос#5  К оглавлению](#Stream-API-и-Лямбда)

## Любой анонимный класс можно заменить на лямбду?
+ Ответ - нет. 
Вы можете создать анонимный класс для не финальных классов и интерфейсов. Не то же самое для лямбда-выражений. Они могут использоваться только там, где ожидается интерфейс SAM, то есть интерфейсы только с одним абстрактным методом (до Java 8 каждый интерфейсный метод был абстрактным, но поскольку интерфейсы Java 8 также могут иметь стандартные и статические методы, которые не являются абстрактными, поскольку они имеют реализацию 

**(!)Только анонимные классы, которые являются реализациями интерфейса SAM (например, Runnable, ActionListener, Comparator, Predicate), могут быть заменены лямбда-выражением. DefaultConsumer не может быть лямбда-мишенью, потому что даже не является интерфейсом.
+ [Вопрос#6  К оглавлению](#Stream-API-и-Лямбда)

## Связь лямбда с анонимным классом?
+ __Заменяют анонимные классы, синтаксический сахар, не нужно переопределять методы__.
+ __Что такое «анонимные классы»? Где они применяются?__
- Это вложенный локальный(inner class) класс, без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. 
- Нет конструктора, только тело
- Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический, либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.
Анонимные классы имеют несколько ограничений:
•	Их использование разрешено только в одном месте программы - месте его создания;
•	Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
•	Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.
Анонимные классы обычно применяются для:
•	создания объекта функции (function object), например, реализация интерфейса Comparator;
•	создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
•	в статическом методе генерации;
•	инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.
+ Анонимные классы выполняют две функции, 
1.	Описание класса

2.	Создание экземпляра(объекта) этого класса

+ __Как создать экземпляр анонимного класса (подробно)?__ 
1. Создаем локальный класс без имени, 
2. Можно объявить такой класс, который может расширить (extends) другой класс или реализовать (implements) интерфейс. Объявление такого класса выполняется одновременно с созданием его объекта посредством оператора new и экземпляр некоторого класса.
3. Не должно быть конструктора, 
```java
UnaryOperator<Integer> myOperatorWithoutName = new UnaryOperator<Integer>() {
        @Override
        public Integer apply(Integer x) {
            return x * x;
        }
    };
```
Любые аргументы, которые вы укажете в круглых скобках, стоящих за именем родительского класса в определении анонимного класса, неявно передаются конструктору родительского класса.
+ __Где применяются анонимные классы?__ 
1) Чаще всего анонимные классы применяются для расширения родительских классов простыми классами, которые не требуют аргументов конструктора, поэтому скобки в определении анонимного класса зачастую пусты.
2) Чтобы не создавать отдельный класс, если нужно встроить некоторую логику в существующий класс или связать с др.классом.
3) При обращении создается единожды, Анонимный внутренний класс может быть полезен при создании экземпляра объекта с определенными "extras", такими как переопределяющие методы, без необходимости фактически подклассировать класс.

Когда мы реализуем один единственный метод интерфейса, то нет необходимости его указывать в реализации,  
Я обычно использую его как ярлык для подключения прослушивателя событий:
```java
public void addActionListener(ActionListener listener) {listeners.add(listener)};

    button.addActionListener(new ActionListener() {
       @Override
       public void actionPerformed(ActionEvent e) { //описание структуры анонимного класса
        // do something
       }
    });
```
1.	Нет необходимости явно указывать:
- сам интерфейс, потому что на этапе компиляции он видит заголовок в параметрах метода принимающего значения, 
т.е.:
```java
public void addActionListener(ActionListener listener) {
```
- имя самого метода (поскольку это ФИ и у него единственный метод,) понятно что речь идет только о нем, 
- возвращаемое значение,
- модификаторы доступа,
2.	Чтобы разделить набор параметров, которые мы указываем в круглых скобочках и тело метода реализующего метод интерфейса, после указания аргументов, в скобочках, мы указываем в виде стрелочки, ->
3.	То, во что вырождается анонимный класс называется Лямбда-выражение
Если у метода, в интерфейсе, есть параметры, то типы этих параметров можно не писать, т.к. компилятор узнает эти типы заглянув в заголовок в интерфейсе, а об интерфейсе он узнает из метода public void addActionListener(ActionListener listener) {
4.	Если у метода интерфейса единственный параметр, то можно опустить и круглые скобки, но если их нет совсем, то они должны быть пустые.
5.	Если тело состоит из единственного оператора, фигурные скобки можно опустить, ; (точка с запятой не записывается сразу после тела,
6.	Если единственный оператор это return то он тоже опускается.

+ [Вопрос#7  К оглавлению](#Stream-API-и-Лямбда)

## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
### ---Info---
+ [Interface Stream<T>-->]( https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html )

### ---Video---
### ---Lessons---
+ [Шпаргалка Java программиста 4. Java Stream API-->]( https://habr.com/ru/company/luxoft/blog/270383/ )
+ [Stream API: универсальная промежуточная операция-->]( https://habr.com/ru/post/262139/ )
+ [Stream API-->]( https://javarush.ru/groups/posts/2203-stream-api )
+ [Полное руководство по Java 8 Stream API в картинках и примерах-->]( https://annimon.com/article/2778 )
+ [Полное руководство по Java Stream API-->]( https://hr-vector.com/java/stream-api )
+ [Введение в Stream API-->]( https://metanit.com/java/tutorial/10.1.php )

+ [Stream API и лямбда выражения в Java.-->]( https://java-master.com/stream-and-lambda-in-java/ )
+ [Использование generic wildcards для повышения удобства Java API-->]( https://habr.com/ru/post/207360/ )
+ [Используйте Stream API проще (или не используйте вообще)-->]( https://habr.com/ru/post/337350/ )
+ __Optional Class__
+ [Объект в футляре или Optional в Java 8 и Java 9. Часть 1: «Как без него прожить?»(2018)-->]( https://habr.com/ru/post/347480/ )
+ [Объект в футляре или Optional в Java 8 и Java 9. Часть 2: «Как это делается в Java 8»(2018)-->]( https://habr.com/ru/post/347576/ )
+ [Объект в футляре или Optional в Java 8 и Java 9. Часть 3: «Что добавилось в Java 9»(2018)-->]( https://habr.com/ru/post/347748/ )
+ [Объект в футляре или Optional в Java 8 и Java 9. Часть 4: «Как футляром с двойным дном закрыть дыру в Java“(2018)-->]( https://habr.com/ru/post/347836/ )
+ [Объект в футляре или Optional в Java 8 и Java 9: Часть 5: Недосказанное и постер в подарок(2018)-->]( https://habr.com/ru/post/350904/ )
+ [Optional: Кот Шрёдингера в Java 8(2018)-->]( https://habr.com/ru/post/346782/ )
+ [Разбираем класс java.util.Optional-->]( https://megahub.me/post/16 )
+ [Разбираемся с Optional в java-->]( https://java-master.com/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-optional-%D0%B2-java/ )
### ---Forum---
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )


[к оглавлению](#Stream-API-и-Лямбда)
