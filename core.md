[JavaTutorials](README.md)

# Theme1___OOP
1) [Что такое _ООП_?](#Что-такое-ООП)
2) [Назовите основные принципы _ООП_.](#Назовите-основные-принципы-ООП)
3) [Что такое _«инкапсуляция»_?](#Что-такое-инкапсуляция)
4) [Что такое _«наследование»_?](#Что-такое-наследование)
5) [Что такое _«полиморфизм»_?](#Что-такое-полиморфизм)
6) [Что такое _«абстракция»_?](#Что-такое-абстракция)
7) [Что представляет собой _«обмен сообщениями»_?](#Что-представляет-собой-обмен-сообщениями)
8) [Расскажите про основные понятия ООП: _«класс»_, _«объект»_, _«интерфейс»_.](#Расскажите-про-основные-понятия-ООП-класс-объект-интерфейс)
9) [В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?](#В-чем-заключаются-преимущества-и-недостатки-объектно-ориентированного-подхода-в-программировании)
10) [Что подразумевают в плане принципов ООП выражения _«является»_ и _«имеет»_?](#Что-подразумевают-в-плане-принципов-ООП-выражения-является-и-имеет)
11) [В чем разница между _композицией_ и _агрегацией_?](#В-чем-разница-между-композицией-и-агрегацией)
12) [Что такое _статическое_ и _динамическое связывание_?](#Что-такое-статическое-и-динамическое-связывание)
13) [Принципы проектирования SOLID?](#Принципы-проектирования-SOLID)



# Thema2___JavaLanguages
1) [Какая основная идея языка?](#Какая-основная-идея-языка)
2) [За счет чего обеспечивается кроссплатформенность?](#За-счет-чего-обеспечивается-кроссплатформенность)
3) [Какие преимущества у java?](#Какие-преимущества-у-java)
4) [Какие недостатки у Java?](#Какие-недостатки-у-Java)
5) [Что такое JDK? Что в него входит?](#Что-такое-JDK-Что-в-него-входит)
6) [Что такое JRE? что в него входит?](#Что-такое-JRE-что-в-него-входит)
7) [Что такое JVM?](#Что-такое-JVM)
8) [Что такое byte code?](#Что-такое-byte-code)
9) [Что такое загрузчик классов (classloader)?](#Что-такое-загрузчик-классов-classloader)
10) [Что такое JIT?](#Что-такое-JIT)
11) [Что такое Heap и Stack память в Java? Чем они отличаются?](#Что-такое-Heap-и-Stack-память-в-Java-Чем-они-отличаются)
12) [Виды ссылок в Java](#Виды-ссылок-в-Java)
13) [Что такое сборщик мусора? (Garbage collector)](#Что-такое-сборщик-мусора-Garbage-collector)
14) [Как работает сборщик мусора?](#Как-работает-сборщик-мусора)
15) [Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?](#Какие-разновидности-сборщиков-мусора-реализованы-в-виртуальной-машине-hotspot)
16) [Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.](#Опишите-алгоритм-работы-какого-нибудь-сборщика-мусора-реализованного-в-виртуальной-машине-hotspot)
17) [Что произойдет со сборщиком мусора, если выполнение метода `finalize()` требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?](#Что-произойдет-со-сборщиком-мусора-если-выполнение-метода-finalize-требует-ощутимо-много-времени-или-в-процессе-выполнения-будет-выброшено-исключение)
18) [Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?](#Верно-ли-утверждение-что-примитивные-типы-данных-всегда-хранятся-в-стеке-а-экземпляры-ссылочных-типов-данных-в-куче)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)



# Thema3___ProceduralJava
1) [Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?](#Сколько-ключевых-слов-зарезервировано-языком-что-это-за-слова-какие-из-них-не-используются)
2) [Из каких символов может состоять имя переменной (корректный идентификатор)?](#Из-каких-символов-может-состоять-имя-переменной-корректный-идентификатор)
3) [Какие примитивные типы данных есть в Java?](#Какие-примитивные-типы-данных-есть-в-Java)
4) [Что такое char?](#Что-такое-char)
5) [Сколько памяти занимает boolean?](#Сколько-памяти-занимает-boolean)
6) [Что такое классы-обертки (Wrapper Class)?](#Что-такое-классы-обертки-Wrapper-Class)
7) [Что такое автоупаковка и автораспаковка?](#Что-такое-автоупаковка-и-автораспаковка)
8) [Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?](#Что-такое-явное-и-неявное-приведение-типов-В-каких-случаях-в-java-нужно-использовать-явное-приведение) 
9) [Что такое пул интов?](#Что-такое-пул-интов)
10) [Какие нюансы у строк в Java?](#Какие-нюансы-у-строк-в-Java)
11) [Что такое пул строк?](#Что-такое-пул-строк)
12) [Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?](#Почему-не-рекомендуется-изменять-строки-в-цикле-Что-рекомендуется-использовать)
13) [Почему строки не рекомендуется использовать для хранения паролей?](#Почему-строки-не-рекомендуется-использовать-для-хранения-паролей)
14) [Почему `String` неизменяемый и финализированный класс?](#Почему-string-неизменяемый-и-финализированный-класс)
15) [Почему строка является популярным ключом в `HashMap` в Java?](#Почему-строка-является-популярным-ключом-в-hashmap-в-java)
16) [Что делает метод `intern()` в классе `String`?.](#Что-делает-метод-intern-в-классе-string)
17) [Можно ли использовать строки в конструкции `switch`?](#Можно-ли-использовать-строки-в-конструкции-switch)
18) [Какая основная разница между `String`, `StringBuffer`, `StringBuilder`?](#Какая-основная-разница-между-string-stringbuffer-stringbuilder)
19) [Методы класса `String`?](#Методы-класса-String)
20) [Методы класса `Character`?](#Методы-класса-Character)
21) [Существуют ли в java многомерные массивы?](#Существуют-ли-в-java-многомерные-массивы)
22) [Какими значениями инициируются переменные по умолчанию?](#Какими-значениями-инициируются-переменные-по-умолчанию)
23) [Что такое сигнатура метода?](#Что-такое-сигнатура-метода)
24) [Расскажите про метод main](#Расскажите-про-метод-main)
25) [Каким образом переменные передаются в методы, по значению или по ссылке?](#Каким-образом-переменные-передаются-в-методы-по-значению-или-по-ссылке)
26) [Для чего используется оператор `assert`?](#Для-чего-используется-оператор-assert)
27) [Какие логические операции и операторы вы знаете?](#Какие-логические-операции-и-операторы-вы-знаете)
28) [Что такое тернарный оператор выбора?](#Что-такое-тернарный-оператор-выбора)
29) [Какие побитовые операции вы знаете?](#Какие-побитовые-операции-вы-знаете)
30) [Какие унарные и бинарные арифметические операции вы знаете?](#Какие-унарные-и-бинарные-арифметические-операции-вы-знаете)
31) [Какова роль и правила написания оператора выбора (switch)?](#Какова-роль-и-правила-написания-оператора-выбора-switch)
32) [Какие циклы вы знаете, в чем их отличия?](#Какие-циклы-вы-знаете-в-чем-их-отличия)
33) [Какие операторы используются для перехода к следующей итерации и немедленной остановки цикла?](#Какие-операторы-используются-для-перехода-к-следующей-итерации-и-немедленной-остановки-цикла)



# Theme4___OOPInJava

### 1-Classes
+ 1.1) [Какие типы классов бывают в java?](#Какие-типы-классов-бывают-в-java)
+ 1.2) [Что такое _«статический класс»_?](#Что-такое-статический-класс)
+ 1.3) [Что такое _«локальный класс»_? Каковы его особенности?](#Что-такое-локальный-класс-Каковы-его-особенности)
+ 1.4) [Что такое _«анонимные классы»_? Где они применяются?](#Что-такое-анонимные-классы-Где-они-применяются)
+ 1.5) [Что такое абстрактные классы? Чем они отличаются от обычных?](#Что-такое-абстрактные-классы-Чем-они-отличаются-от-обычных)
+ 1.6) [Может ли быть абстрактный класс без абстрактных методов?](#Может-ли-быть-абстрактный-класс-без-абстрактных-методов)
+ 1.7) [Что имеет более высокий уровень абстракции - _класс_, _абстрактный класс_ или _интерфейс_?](#Что-имеет-более-высокий-уровень-абстракции---класс-абстрактный-класс-или-интерфейс)
+ 1.8) [Расскажите про вложенные классы. В каких случаях они применяются?](#Расскажите-про-вложенные-классы-В-каких-случаях-они-применяются)
+ 1.9) [Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?](#Какие-существуют-особенности-использования-вложенных-классов-статических-и-внутренних-В-чем-заключается-разница-между-ними)
+ 1.10) [Каким образом из вложенного класса получить доступ к полю внешнего класса?](#Каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса)
+ 1.11) [Что такое перечисления (enum)?](#Что-такое-перечисления-enum)
+ 1.12) [Как проблема ромбовидного наследования решена в java?](#Как-проблема-ромбовидного-наследования-решена-в-java)
+ 1.13) [Расскажите про классы-загрузчики и про динамическую загрузку классов.](#Расскажите-про-классы-загрузчики-и-про-динамическую-загрузку-классов)
+ 1.14) [Что такое _Reflection_?](#Что-такое-reflection)


### 2-Interfaces
+ 2.1) [Дайте определение понятию _«интерфейс»_. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#Дайте-определение-понятию-интерфейс-Какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
+ 2.2) [Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?](#Чем-абстрактный-класс-отличается-от-интерфейса-В-каких-случаях-следует-использовать-абстрактный-класс-а-в-каких-интерфейс)
+ 2.3) [Почему в некоторых интерфейсах вообще не определяют методов?](#Почему-в-некоторых-интерфейсах-вообще-не-определяют-методов)
+ 2.4) [Почему нельзя объявить метод интерфейса с модификатором `final`?](#Почему-нельзя-объявить-метод-интерфейса-с-модификатором-final)
+ 2.5) [Может ли один интерфейс наследоваться от другого? От двух других?](#Может-ли-один-интерфейс-наследоваться-от-другого-От-двух-других)
+ 2.6) [Что такое дефолтные методы интерфейсов? Для чего они нужны?](#Что-такое-дефолтные-методы-интерфейсов-Для-чего-они-нужны)
+ 2.7) [Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?](#Как-решается-проблема-ромбовидного-наследования-при-наследовании-интерфейсов-при-наличии-default-методов)


### 3-Constructors and initialization
+ 3.1) [Дайте определение понятию «конструктор».](#Дайте-определение-понятию-конструктор)
+ 3.2) [Что такое _«конструктор по умолчанию»_?](#Что-такое-конструктор-по-умолчанию)
+ 3.3) [Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?](#Чем-отличаются-конструктор-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами)
+ 3.4) [Где и как вы можете использовать приватный конструктор?](#Где-и-как-вы-можете-использовать-приватный-конструктор) 
+ 3.5) [Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?](#Могут-ли-быть-конструкторы-у-абстрактных-классов-Для-чего-они-нужны)
+ 3.6) [Что значит слово “инициализация”?](#Что-значит-слово-инициализация)
+ 3.7) [Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?](#Каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учётом-иерархии-классов)
+ 3.8) [Зачем нужны и какие бывают блоки инициализации?](#Зачем-нужны-и-какие-бывают-блоки-инициализации)
+ 3.9) [Где разрешена инициализация статических/нестатических полей?](#Где-разрешена-инициализация-статическихнестатических-полей)
+ 3.10) [Что произойдет, если в блоке инициализации возникнет исключительная ситуация?](#Что-произойдет-если-в-блоке-инициализации-возникнет-исключительная-ситуация)
+ 3.11) [Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?](#Какое-исключение-выбрасывается-при-возникновении-ошибки-в-блоке-инициализации-класса)


### 4-Access Modifiers
+ 4.1) [Какие существуют модификаторы доступа?](#Какие-существуют-модификаторы-доступа)
+ 4.2) [О чем говорит ключевое слово `final`?](#О-чем-говорит-ключевое-слово-final)
+ 4.3) [Где и для чего используется модификатор `abstract`?](#Где-и-для-чего-используется-модификатор-abstract)
+ 4.4) [Что означает модификатор `static`?](#Что-означает-модификатор-static)
+ 4.5) [Может ли объект получить доступ к члену класса объявленному как `private`? Если да, то каким образом?](#Может-ли-объект-получить-доступ-к-члену-класса-объявленному-как-private-Если-да-то-каким-образом)
+ 4.6) [Для чего в Java используются статические блоки инициализации?](#Для-чего-в-java-используются-статические-блоки-инициализации)
+ 4.7) [Может ли статический метод быть переопределён или перегружен?](#Может-ли-статический-метод-быть-переопределён-или-перегружен)
+ 4.8) [Могут ли нестатические методы перегрузить статические?](#Могут-ли-нестатические-методы-перегрузить-статические)
+ 4.9) [Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?](#Можно-ли-сузить-уровень-доступатип-возвращаемого-значения-при-переопределении-метода)
+ 4.10) [Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции `throws`?](#Возможно-ли-при-переопределении-метода-изменить-модификатор-доступа-возвращаемый-тип-тип-аргумента-или-их-количество-имена-аргументов-или-их-порядок-убирать-добавлять-изменять-порядок-следования-элементов-секции-throws)
+ 4.11) [Как получить доступ к переопределенным методам родительского класса?](#Как-получить-доступ-к-переопределенным-методам-родительского-класса)
+ 4.12) [Можно ли объявить метод абстрактным и статическим одновременно?](#Можно-ли-объявить-метод-абстрактным-и-статическим-одновременно)
+ 4.13) [В чем разница между членом экземпляра класса и статическим членом класса?](#В-чем-разница-между-членом-экземпляра-класса-и-статическим-членом-класса)
+ 4.14) [Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?](#Что-можно-изменить-в-сигнатуре-метода-при-переопределении-Можно-ли-менять-модификаторы-throws-и-тп)
+ 4.15) [Могут ли классы быть статическими?](#Могут-ли-классы-быть-статическими)
+ 4.16) [Что означает модификатор final? К чему он может быть применим?](#Что-означает-модификатор-final-К-чему-он-может-быть-применим)
+ 4.17) [К каким конструкциям Java применим модификатор `static`?](#К-каким-конструкциям-java-применим-модификатор-static)
+ 4.18) [Чем отличаются `final`, `finally` и `finalize()`?](#Чем-отличаются-final-finally-и-finalize)

### 5-Class Object
+ 5.1) [Что такое класс `Object`? Какие в нем есть методы?](#Что-такое-класс-object-Какие-в-нем-есть-методы)
+ 5.2) [Расскажите про equals и hashcode](#Расскажите-про-equals-и-hashcode)
+ 5.3) [Каким образом реализованы методы hashCode() и equals() в классе Object?](#Каким-образом-реализованы-методы-hashCode-и-equals-в-классе-Object)
+ 5.4) [Зачем нужен `equals()`. Чем он отличается от операции `==`?](#Зачем-нужен-equals-Чем-он-отличается-от-операции)
+ 5.5) [Правила переопределения метода `Object.equals()`.](#Правила-переопределения-метода-objectequals)
+ 5.6) [Что будет, если переопределить `equals()` не переопределяя `hashCode()`? Какие могут возникнуть проблемы?](#Что-будет-если-переопределить-equals-не-переопределяя-hashcode-Какие-могут-возникнуть-проблемы)
+ 5.7) [Для чего нужен метод `hashCode()`?](#Для-чего-нужен-метод-hashcode)
+ 5.8) [Какой контракт между `hashCode()` и `equals()`?](#Какой-контракт-между-hashCode-и-equals)
+ 5.9) [Правила переопределения метода `hashcode()`](#Правила-переопределения-метода-hashcode)
+ 5.10) [Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете `hashCode()`?](#Есть-ли-какие-либо-рекомендации-о-том-какие-поля-следует-использовать-при-подсчете-hashcode)
+ 5.11) [Могут ли у разных объектов быть одинаковые `hashCode()`?](#Могут-ли-у-разных-объектов-быть-одинаковые-hashcode)
+ 5.12) [Есть класс `Point{int x, y;}`. Почему хэш код в виде `31 * x + y` предпочтительнее чем `x + y`?](#Есть-класс-pointint-x-y-Почему-хэш-код-в-виде-31--x--y-предпочтительнее-чем-x--y)
+ 5.13) [Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?](#Почему-нельзя-реализовать-hashcode-который-будет-гарантированно-уникальным-для-каждого-объекта)
+ 5.14) [Чем a.getClass().equals(A.class) отличается от a instanceOf A.class](#Чем-a.getClass-.equals-A.class-отличается-от-a-instanceOf-A.class)
+ 5.15) [Если у класса `Point{int x, y;}` реализовать метод `equals(Object that) {(return this.x == that.x && this.y == that.y)}`, но сделать хэш код в виде `int hashCode() {return x;}`, то будут ли корректно такие точки помещаться и извлекаться из `HashSet`?](#Если-у-класса-pointint-x-y-реализовать-метод-equalsobject-that-return-thisx--thatx--thisy--thaty-но-сделать-хэш-код-в-виде-int-hashcode-return-x-то-будут-ли-корректно-такие-точки-помещаться-и-извлекаться-из-hashset)
+ 5.16) [Могут ли у разных объектов `(ref0 != ref1)` быть `ref0.equals(ref1) == true`?](#Могут-ли-у-разных-объектов-ref0--ref1-быть-ref0equalsref1--true)
+ 5.17) [Могут ли у разных ссылок на один объект `(ref0 == ref1)` быть `ref0.equals(ref1) == false`?](#Могут-ли-у-разных-ссылок-на-один-объект-ref0--ref1-быть-ref0equalsref1--false)
+ 5.18) [Можно ли так реализовать метод `equals(Object that) {return this.hashCode() == that.hashCode()}`?](#Можно-ли-так-реализовать-метод-equalsobject-that-return-thishashcode--thathashcode)
+ 5.19) [В `equals()` требуется проверять, что аргумент `equals(Object that)` такого же типа что и сам объект. В чем разница между `this.getClass() == that.getClass()` и `that instanceof MyClass`?](#В-equals-требуется-проверять-что-аргумент-equalsobject-that-такого-же-типа-что-и-сам-объект-В-чем-разница-между-thisgetclass--thatgetclass-и-that-instanceof-myclass)
+ 5.20) [Можно ли реализовать метод `equals()` класса `MyClass` вот так: `class MyClass {public boolean equals(MyClass that) {return this == that;}}`?](#Можно-ли-реализовать-метод-equals-класса-myclass-вот-так-class-myclass-public-boolean-equalsmyclass-that-return-this--that)
+ 5.21) [Что такое `finalize()`? Зачем он нужен?](#Что-такое-finalize-Зачем-он-нужен)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)



# Theme5___FunctionalInterface
1) [Что такое функциональный интерфейс и аннотация @FunctionalInterface?](#Что-такое-функциональный-интерфейс-и-аннотация-FunctionalInterface)
2) [Что такое `default` методы интрефейса?](#Что-такое-default-методы-интрефейса)
3) [Как вызывать `default` метод интерфейса в реализующем этот интерфейс классе?](#Как-вызывать-default-метод-интерфейса-в-реализующем-этот-интерфейс-классе)
4) [Что такое `static` метод интерфейса?](#Что-такое-static-метод-интерфейса)
5) [Как вызывать `static` метод интерфейса?](#Как-вызывать-static-метод-интерфейса)
6) [Зачем нужны `default` методы в функциональном интерфейсе?](#Зачем-нужны-default-методы-в-функциональном-интерфейсе)
7) [Какие есть способы инстацировать функциональные интерфейсы?](#Какие-есть-способы-инстацировать-функциональные-интерфейсы)
8) [Сколько дефолтных методов и статических методов, статических полей в интерфейсе?](#Сколько-дефолтных-методов-и-статических-методов-статических-полей-в-интерфейсе)
9) [Где находятся функциональные интерфейсы?](#Где-находятся-функциональные-интерфейсы)
10) [Что такое ссылка на метод?](#Что-такое-ссылка-на-метод)
11) [Что такое лямбда-выражение? Чем его можно заменить?](#Что-такое-лямбда-выражение-Чем-его-можно-заменить)
12) [Базовые функциональные интерфейсы Java 8?](#Базовые-функциональные-интерфейсы-Java-8)
13) [Для чего нужны функциональные интерфейсы `Function<T,R>`, `DoubleFunction<R>`, `IntFunction<R>` и `LongFunction<R>`?](#Для-чего-нужны-функциональные-интерфейсы-functiontr-doublefunctionr-intfunctionr-и-longfunctionr)
14) [Для чего нужны функциональные интерфейсы `UnaryOperator<T>`, `DoubleUnaryOperator`, `IntUnaryOperator` и `LongUnaryOperator`?](#Для-чего-нужны-функциональные-интерфейсы-unaryoperatort-doubleunaryoperator-intunaryoperator-и-longunaryoperator)
15) [Для чего нужны функциональные интерфейсы `BinaryOperator<T>`, `DoubleBinaryOperator`, `IntBinaryOperator` и `LongBinaryOperator`?](#Для-чего-нужны-функциональные-интерфейсы-binaryoperatort-doublebinaryoperator-intbinaryoperator-и-longbinaryoperator)
16) [Для чего нужны функциональные интерфейсы `Predicate<T>`, `DoublePredicate`, `IntPredicate` и `LongPredicate`?](#Для-чего-нужны-функциональные-интерфейсы-predicatet-doublepredicate-intpredicate-и-longpredicate)
17) [Для чего нужны функциональные интерфейсы `Consumer<T>`, `DoubleConsumer`, `IntConsumer` и `LongConsumer`?](#Для-чего-нужны-функциональные-интерфейсы-consumert-doubleconsumer-intconsumer-и-longconsumer)
18) [Для чего нужны функциональные интерфейсы `Supplier<T>`,  `BooleanSupplier`, `DoubleSupplier`, `IntSupplier` и `LongSupplier`?](#Для-чего-нужны-функциональные-интерфейсы-suppliert--booleansupplier-doublesupplier-intsupplier-и-longsupplier)
19) [Для чего нужен функциональный интерфейс `BiConsumer<T,U>`?](#Для-чего-нужен-функциональный-интерфейс-biconsumertu)
20) [Для чего нужен функциональный интерфейс `BiFunction<T,U,R>`?](#Для-чего-нужен-функциональный-интерфейс-bifunctiontur)
21) [Для чего нужен функциональный интерфейс `BiPredicate<T,U>`?](#Для-чего-нужен-функциональный-интерфейс-bipredicatetu)
22) [Для чего нужны функциональные интерфейсы вида `_To_Function`?](#Для-чего-нужны-функциональные-интерфейсы-вида-tofunction)
23) [Для чего нужны функциональные интерфейсы `ToDoubleBiFunction<T,U>`, `ToIntBiFunction<T,U>` и `ToLongBiFunction<T,U>`?](#Для-чего-нужны-функциональные-интерфейсы-todoublebifunctiontu-tointbifunctiontu-и-tolongbifunctiontu)
24) [Для чего нужны функциональные интерфейсы `ToDoubleFunction<T>`, `ToIntFunction<T>` и `ToLongFunction<T>`?](#Для-чего-нужны-функциональные-интерфейсы-todoublefunctiont-tointfunctiont-и-tolongfunctiont)
25) [Для чего нужны функциональные интерфейсы `ObjDoubleConsumer<T>`, `ObjIntConsumer<T>` и `ObjLongConsumer<T>`?](#Для-чего-нужны-функциональные-интерфейсы-objdoubleconsumert-objintconsumert-и-objlongconsumert)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)



# Theme6___ChangesInJava8
1) [Какие нововведения появились в java 8?](#Какие-нововведения-появились-в-java-8)
2) [Какие новые классы для работы с датами появились в java 8?](#Какие-новые-классы-для-работы-с-датами-появились-в-java-8)
3) [Расскажите про класс Optional](#Расскажите-про-класс-Optional)
4) [Что такое Nashorn?](#Что-такое-Nashorn)
5) [Что такое jjs?](#Что-такое-jjs)
6) [Какой класс появился в Java 8 для кодирования/декодирования данных?](#Какой-класс-появился-в-Java-8-для-кодирования-декодирования-данных)
7) [Как создать Base64 кодировщик и декодировщик?](#Как-создать-Base64-кодировщик-и-декодировщик)
8) [Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?](#Какие-дополнительные-методы-для-работы-с-ассоциативными-массивами-maps-появились-в-Java-8)
9) [Что такое LocalDateTime?](#Что-такое-LocalDateTime)
10) [Что такое ZonedDateTime?](#Что-такое-ZonedDateTime)















__Thema1 - OOP ______________________________________________________________________________________________

## Что такое _ООП_?
__Объектно-ориентированное программирование (ООП)__ — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. 

+ объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
+ каждый объект является экземпляром определенного класса 
+ классы образуют иерархии. 

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние. 
+ [Thema#1 Question#1  Go to OOP](#Theme1___OOP)

## Назовите основные принципы _ООП_.
+ _Инкапсуляция_ - сокрытие реализации.
+ _Наследование_ - создание новой сущности на базе уже существующей.
+ _Полиморфизм_ - возможность иметь разные формы для одной и той же сущности.
+ _Абстракция_ - набор общих характеристик.
+ _Посылка сообщений_ - форма связи, взаимодействия между сущностями.
+ _Переиспользование_- все что перечислено выше работает на повторное использование кода.

Это единственно верный порядок парадигм ООП, так как каждая последующая использует предыдущие.
+ [Thema#1 Question#2  Go to OOP](#Theme1___OOP)

## Что такое _«инкапсуляция»_?
__Инкапсуляция__ – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

>Представим на минутку, что мы оказались в конце позапрошлого века, когда Генри Форд ещё не придумал конвейер, а первые попытки создать автомобиль сталкивались с критикой властей по поводу того, что эти коптящие монстры загрязняют воздух и пугают лошадей. Представим, что для управления первым паровым автомобилем необходимо было знать, как устроен паровой котёл, постоянно подбрасывать уголь, следить за температурой, уровнем воды. При этом для поворота колёс использовать два рычага, каждый из которых поворачивает одно колесо в отдельности. Думаю, можно согласиться с тем, что вождение автомобиля того времени было весьма неудобным и трудным занятием.

>Теперь вернёмся в сегодняшний день к современным чудесам автопрома с коробкой-автоматом. На самом деле, по сути, ничего не изменилось. Бензонасос всё так же поставляет бензин в двигатель, дифференциалы обеспечивают поворот колёс на различающиеся углы, коленвал превращает поступательное движение поршня во вращательное движение колёс. Прогресс в другом. Сейчас все эти действия скрыты от пользователя и позволяют ему крутить руль и нажимать на педаль газа, не задумываясь, что в это время происходит с инжектором, дроссельной заслонкой и распредвалом. Именно сокрытие внутренних процессов, происходящих в автомобиле, позволяет эффективно его использовать даже тем, кто не является профессионалом-автомехаником с двадцатилетним стажем. Это сокрытие в ООП носит название инкапсуляции.

Пример:
```java
public class SomePhone {

    private int year;
    private String company;
    public SomePhone(int year, String company) {
        this.year = year;
        this.company = company;
    }
    private void openConnection(){
        //findComutator
        //openNewConnection...
    }
    public void call() {
        openConnection();
        System.out.println("Вызываю номер");
    }

    public void ring() {
        System.out.println("Дзынь-дзынь");
    }

}
```
Модификатор private делает доступными поля и методы класса только внутри данного класса. Это означает, что получить доступ к private полям из вне невозможно, как и нет возможности вызвать private методы.

Сокрытие доступа к методу openConnection, оставляет нам также возможность к свободному изменению внутренней реализации этого метода, так как этот метод гарантированно не используется другими объектами и не нарушит их работу.

Для работы с нашим объектом мы оставляем открытыми методы call и ring с помощью модификатора public. Предоставление открытых методов для работы с объектом также является частью механизма инкапсуляции, так как если полностью закрыть доступ к объекту – он станет бесполезным.
+ [Thema#1 Question#3  Go to OOP](#Theme1___OOP)

## Что такое _«наследование»_?
__Наследование__ – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется _предком_, _базовым_ или _родительским_. Новый класс – _потомком_, _наследником_ или _производным_ классом.

>Представим себя, на минуту, инженерами автомобильного завода. Нашей задачей является разработка современного автомобиля. У нас уже есть предыдущая модель, которая отлично зарекомендовала себя в течение многолетнего использования. Всё бы хорошо, но времена и технологии меняются, а наш современный завод должен стремиться повышать удобство и комфорт выпускаемой продукции и соответствовать современным стандартам.

>Нам необходимо выпустить целый модельный ряд автомобилей: седан, универсал и малолитражный хэтч-бэк. Очевидно, что мы не собираемся проектировать новый автомобиль с нуля, а, взяв за основу предыдущее поколение, внесём ряд конструктивных изменений. Например, добавим гидроусилитель руля и уменьшим зазоры между крыльями и крышкой капота, поставим противотуманные фонари. Кроме того, в каждой модели будет изменена форма кузова.

>Очевидно, что все три модификации будут иметь большинство свойств прежней модели (старый добрый двигатель 1970 года, непробиваемая ходовая часть, зарекомендовавшая себя отличным образом на отечественных дорогах, коробку передач и т.д.). При этом каждая из моделей будет реализовать некоторую новую функциональность или конструктивную особенность. В данном случае, мы имеем дело с наследованием.

Пример:
Рассмотрим пример создания класса смартфон с помощью наследования. Все беспроводные телефоны работают от аккумуляторных батарей, которые имеют определенный ресурс работы в часах. Поэтому добавим это свойство в класс беспроводных телефонов:
```java
public abstract class WirelessPhone extends AbstractPhone {

    private int hour;

    public WirelessPhone(int year, int hour) {
        super(year);
        this.hour = hour;
    }
}
```
Сотовые телефоны наследуют свойства беспроводного телефона, мы также добавили в этот класс реализацию методов call и ring:
```java
public class CellPhone extends WirelessPhone {
    public CellPhone(int year, int hour) {
        super(year, hour);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вызываю номер " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Вам звонит абонент " + inputNumber);
    }
}
```
И, наконец, класс смартфон, который в отличие от классических сотовых телефонов имеет полноценную операционную систему. В смартфон можно добавлять новые программы, поддерживаемые данной операционной системой, расширяя, таким образом, его функциональность. С помощью кода класс можно описать так:
```java
public class Smartphone extends CellPhone {

    private String operationSystem;

    public Smartphone(int year, int hour, String operationSystem) {
        super(year, hour);
        this.operationSystem = operationSystem;
    }
    
    public void install(String program){
        System.out.println("Устанавливаю " + program + "для" + operationSystem);
    }

}
```
Как видите, для описания класса Smartphone мы создали совсем немного нового кода, но получили новый класс с новой функциональностью. Использование этого принципа ООП java позволяет значительно уменьшить объем кода, а значит, и облегчить работу программисту.
+ [Thema#1 Question#4  Go to OOP](#Theme1___OOP)

## Что такое _«полиморфизм»_?
__Полиморфизм__ – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).

>Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, ВАЗ 2106 не мог потом водить ВАЗ 2110 или BMW X3. С другой стороны, трудно представить человека, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее педали тормоза, а вместо руля – джойстик. 

>Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструкцию, и принцип действия. Водитель точно знает, что для того, чтобы повернуть налево, он должен повернуть руль, независимо от того, есть там гидроусилитель или нет. 
Если человеку надо доехать с работы до дома, то он сядет за руль автомобиля и будет выполнять одни и те же действия, независимо от того, какой именно тип автомобиля он использует. По сути, можно сказать, что все автомобили имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает именно с этим интерфейсом. Если водителю предстоит ехать по немецкому автобану, он, вероятно выберет быстрый автомобиль с низкой посадкой, а если предстоит возвращаться из отдалённого маральника в Горном Алтае после дождя, скорее всего, будет выбран УАЗ с армейскими мостами. Но, независимо от того, каким образом будет реализовываться движение и внутреннее функционирование машины, интерфейс останется прежним.

_Полиморфная переменная_, это переменная, которая может принимать значения разных типов, а _полиморфная функция_, это функция у которой хотя бы один аргумент является полиморфной переменной.
Выделяют два вида полиморфных функций:

+ _ad hoc_, функция ведет себя по разному для разных типов аргументов (например, функция `draw()` — рисует по разному фигуры разных типов);
+ _параметрический_, функция ведет себя одинаково для аргументов разных типов (например, функция `add()` — одинаково кладет в контейнер элементы разных типов).

Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется полиморфизмом. 

Пример:

Давайте представим, что нам в программе нужно описать пользователя, который может пользоваться любыми моделями телефона, чтобы позвонить другому пользователю. Вот как можно это сделать:

```java
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public void callAnotherUser(int number, AbstractPhone phone) {
// вот он полиморфизм - использование в коде абстактного типа AbstractPhone phone!
        phone.call(number);
    }
}
```

Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:
```java
public class ThomasEdisonPhone extends AbstractPhone {

    public ThomasEdisonPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вращайте ручку");
        System.out.println("Сообщите номер абонента, сэр");
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон звонит");
    }
}
```

Обычный стационарный телефон:

```java
public class Phone extends AbstractPhone {

    public Phone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Вызываю номер" + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон звонит");
    }
}
```

И, наконец, крутой видеотелефон:

```java
public class VideoPhone extends AbstractPhone {

    public VideoPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Подключаю видеоканал для абонента " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("У вас входящий видеовызов..." + inputNumber);
    }
}
```

Создадим объекты в методе main() и протестируем метод callAnotherUser:

```java
AbstractPhone firstPhone = new ThomasEdisonPhone(1879);
AbstractPhone phone = new Phone(1984);
AbstractPhone videoPhone=new VideoPhone(2018);
User user = new User("Андрей");
user.callAnotherUser(224466,firstPhone);
// Вращайте ручку
//Сообщите номер абонента, сэр
user.callAnotherUser(224466,phone);
//Вызываю номер 224466
user.callAnotherUser(224466,videoPhone);
//Подключаю видеоканал для абонента 224466
```

Используя вызов одного и того же метода объекта user, мы получили различные результаты. Выбор конкретной реализации метода call внутри метода callAnotherUser производился динамически на основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма – выбор реализации в процессе выполнения программы.

В примерах классов телефонов, приведенных выше, мы использовали переопределение методов – прием, при котором изменяется реализация метода, определенная в базовом классе, без изменения сигнатуры метода. По сути это является заменой метода, и именно новый метод, определенный в подклассе, вызывается при выполнении программы. 

Обычно, при переопределении метода, используется аннотация @Override, которая подсказывает компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего методов.
+ [Thema#1 Question#5  Go to OOP](#Theme1___OOP)

## Что такое _«абстракция»_?
_Абстрагирование_ – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, __абстракция__ – это набор всех таких характеристик.

>Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерёнок в коробке передач или влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако, руль, педали, указатель поворота он будет использовать регулярно.

Пример:
```java
// Abstract class
abstract class Animal {
    // Abstract method (does not have a body)
    public abstract void animalSound();

    // Regular method
    public void sleep() {
        System.out.println("Zzz");
    }
}

// Subclass (inherit from Animal)
class Pig extends Animal {
    public void animalSound() {
        // The body of animalSound() is provided here
        System.out.println("The pig says: wee wee");
    }
}

class MyMainClass {
    public static void main(String[] args) {
        Pig myPig = new Pig(); // Create a Pig object
        myPig.animalSound();
        myPig.sleep();
    }
}
```
+ [Thema#1 Question#6  Go to OOP](#Theme1___OOP)

## Что представляет собой _«обмен сообщениями»_?
Объекты взаимодействуют, посылая и получая сообщения. Сообщение — это запрос на выполнение действия, дополненный набором аргументов, которые могут понадобиться при выполнении действия. В ООП посылка сообщения (вызов метода) — это единственный путь передать управление объекту. Если объект должен «отвечать» на это сообщение, то у него должна иметься соответствующий данному сообщению метод. Так же объекты, используя свои методы, могут и сами посылать сообщения другим объектам. Обмен сообщениями реализуется с помощью динамических вызовов, что приводит к чрезвычайно позднему связыванию (extreme late binding).

>Пусть требуется создать физическую модель, описывающую сталкивающиеся шары разных размеров. Традиционный подход к решению этой задачи примерно таков: определяется набор данных, описывающих каждый шар (например, его координаты, массу и ускорение); каждому шару присваивается уникальный идентификатор (например, организуется массив, значение индекса которого соответствует номеру шара), который позволит отличать каждый из шаров от всех других. Наконец, пишется подпрограмма с названием, скажем, `bounce`; эта процедура должна на основе номера шара и его начальных параметров соответствующим образом изменять данные, описывающие шар. В отличие от традиционного подхода объектно-ориентированная версия программы моделирует каждый из шаров посредством объекта. При этом объект, соответствующий конкретному шару, содержит не только его параметры, но и весь код, описывающий поведение шара при различных взаимодействиях. Так, каждый шар будет иметь собственный метод `bounce()`. Вместо того, чтобы вызывать подпрограмму `bounce` с аргументом, определяющим, скажем, шар №3, необходимо будет передать объекту «шар №3» сообщение, предписывающее ему выполнить столкновение.
+ [Thema#1 Question#7  Go to OOP](#Theme1___OOP)

## Расскажите про основные понятия ООП: _«класс»_, _«объект»_, _«интерфейс»_.
__Класс__ – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт). 

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

__Объект (экземпляр)__ – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.

__Интерфейс__ – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним. 
+ [Thema#1 Question#8  Go to OOP](#Theme1___OOP)

## В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?
Преимущества:

+ Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.
+ Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.
+ Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.
+ Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.
+ Возможность создавать расширяемые системы.
+ Использование полиморфизма оказывается полезным при:
    + Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.
    + Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.
    + Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.
    + Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.
+ Повторное использование кода:
    + Сокращается время на разработку, которое может быть отдано другим задачам.
    + Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.
    + Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.
    + Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.

Недостатки:

+ В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.
+ Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).
+ Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.
+ Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).
+ Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.

+ [Thema#1 Question#9  Go to OOP](#Theme1___OOP)

## Что подразумевают в плане принципов ООП выражения _«является»_ и _«имеет»_?
__«является»__ подразумевает наследование.
__«имеет»__ подразумевает ассоциацию (агрегацию или композицию).
+ [Thema#1 Question#10  Go to OOP](#Theme1___OOP)

## В чем разница между _композицией_ и _агрегацией_?
Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».

Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть). Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие, что экземпляр «части» может входить только в одно целое (или никуда не входить), в то время как в случае агрегации экземпляр «части» может входить в несколько целых.

>Например, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в другую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция.
В тоже время мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.
+ [Thema#1 Question#11  Go to OOP](#Theme1___OOP)

## Что такое _статическое_ и _динамическое связывание_?
Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором (компоновщиком) перед запуском программы, то оно называется _статическим_ или _ранним связыванием (early binding)_.

В свою очередь, _позднее связывание (late binding)_ это связывание, проводимое непосредственно во время выполнения программы, в зависимости от типа объекта. Позднее связывание также называют _динамическим (dynamic)_ или _связыванием на стадии выполнения (runtime binding)_. В языках, реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты должна включаться какая-то дополнительная информация.

Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как `final` (приватные методы являются `final` по умолчанию).
+ [Thema#1 Question#12  Go to OOP](#Theme1___OOP)

## Принципы проектирования SOLID
Классы — это блоки, из которых строится приложение. Так же, как кирпичи в здании. Плохо написанные классы однажды могут принести проблемы.
Чтобы понять, правильно ли написан класс, можно свериться со “стандартами качества”. В Java это так называемые принципы SOLID. О них и поговорим.  
+ Принципы SOLID в Java
__SOLID__ — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. Принципы придумал Роберт Мартин в начале двухтысячных, а аббревиатуру позже ввел в обиход Майкл Фэзерс. 

Вот что входит в принципы SOLID:
1) Single Responsibility Principle (Принцип единственной ответственности).
2) Open Closed Principle (Принцип открытости/закрытости).
3) Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
4) Interface Segregation Principle (Принцип разделения интерфейса).
5) Dependency Inversion Principle (Принцип инверсии зависимостей).

#### 1) Принцип единственной ответственности (SRP-Single Responsibility Principle)
Данный принцип гласит: никогда не должно быть больше одной причины изменить класс. 

На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс. Все сервисы класса направлены на обеспечение этой обязанности.

Такие классы всегда будет просто изменять, если это понадобится, потому что понятно, за что класс отвечает, а за что — нет. То есть можно будет вносить изменения и не бояться последствий — влияния на другие объекты. А еще подобный код гораздо проще тестировать, ведь вы покрываете тестами одну функциональность в изоляции от всех остальных.

Представьте себе модуль, который обрабатывает заказы. Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа:

```java
public class OrderProcessor {

    public void process(Order order){
        if (order.isValid() && save(order)) {
            sendConfirmationEmail(order);
        }
    }

    private boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных

        return true;
    }

    private void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();

        // Шлем письмо клиенту
    }
}
```
Такой модуль может измениться по трем причинам. Во-первых может стать другой логика обработки заказа, во-вторых, способ его сохранения (тип базы данных), в-третьих — способ отправки письма подтверждения (скажем, вместо email нужно отправлять SMS). 

Принцип единственной обязанности подразумевает, что три аспекта этой проблемы на самом деле — три разные обязанности. А значит, должны находиться в разных классах или модулях. Объединение нескольких сущностей, которые могут меняться в разное время и по разным причинам, считается плохим проектным решением.

Гораздо лучше разделить модуль на три отдельных, каждый из которых будет выполнять одну единственную функцию:

```java
public class MySQLOrderRepository {
    public boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных

        return true;
    }
}

public class ConfirmationEmailSender {
    public void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();

        // Шлем письмо клиенту
    }
}

public class OrderProcessor {
    public void process(Order order){

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
```
#### 2) Принцип открытости/закрытости (OCP-Open Closed Principle)
Этот принцип емко описывают так: программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.

Это означает, что должна быть возможность изменять внешнее поведение класса, не внося физические изменения в сам класс. Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые функции.

Поэтому система должна быть гибкой, с возможностью работы в переменных условиях без изменения исходного кода.

Продолжая наш пример с заказом, предположим, что нам нужно выполнять какие-то действия перед обработкой заказа и после отправки письма с подтверждением. Вместо того, чтобы менять сам класс `OrderProcessor`, мы расширим его и добьемся решения поставленной задачи, не нарушая принцип OCP: 
```java
public class OrderProcessorWithPreAndPostProcessing extends OrderProcessor {

    @Override
    public void process(Order order) {
        beforeProcessing();
        super.process(order);
        afterProcessing();
    }

    private void beforeProcessing() {
        // Осуществим некоторые действия перед обработкой заказа
    }

    private void afterProcessing() {
        // Осуществим некоторые действия после обработки заказа
    }
}
```
#### 3) Принцип подстановки Барбары Лисков (LSP-Liskov’s Substitution Principle)
Это вариация принципа открытости/закрытости, о котором говорилось ранее. Его можно описать так: объекты в программе можно заменить их наследниками без изменения свойств программы.

Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.

Подклассы должны переопределять методы базового класса так, чтобы не нарушалась функциональность с точки зрения клиента. Подробно это можно рассмотреть на следующем примере. 

Предположим у нас есть класс, который отвечает за валидацию заказа и проверяет, все ли из товаров заказа находятся на складе. У данного класса есть метод `isValid` который возвращает `true` или `false`:
```java
public class OrderStockValidator {

    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if (! item.isInStock()) {
                return false;
            }
        }
        return true;
    }
}
```
Также предположим, что некоторые заказы нужно валидировать иначе: проверять, все ли товары заказа находятся на складе и все ли товары упакованы. Для этого мы расширили класс `OrderStockValidator` классом `OrderStockAndPackValidator`:
```java
public class OrderStockAndPackValidator extends OrderStockValidator {

    @Override
    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if ( !item.isInStock() || !item.isPacked() ){
                throw new IllegalStateException(
                     String.format("Order %d is not valid!", order.getId())
                );
            }
        }
        return true;
    }
}
```
Однако в данном классе мы нарушили принцип LSP, так как вместо того, чтобы вернуть `false`, если заказ не прошел валидацию, наш метод бросает исключение `IllegalStateException`. Клиенты данного кода не рассчитывают на такое: они ожидают возвращения `true` или `false`. Это может привести к ошибкам в работе программы.

#### 4) Принцип разделения интерфейса (ISP-Interface Segregation Principle)
Характеризуется следующим утверждением: клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют. 

Рассмотрим пример. Разработчик Алекс создал интерфейс "отчет" и добавил два метода: `generateExcel()` и `generatedPdf()`. Теперь клиент А хочет использовать этот интерфейс, но он намерен использовать отчеты только в PDF-формате, а не в Excel. Устроит ли его такая функциональность?

Нет. Он должен будет реализовать два метода, один из которых по большому счету не нужен и существует только благодаря Алексу — дизайнеру программного обеспечения. Клиент воспользуется либо другим интерфейсом, либо оставит поле для Excel пустым.

Так в чем же решение? Оно состоит в разделении существующего интерфейса на два более мелких. Один — отчет в формате PDF, второй — отчет в формате Excel. Это даст пользователю возможность использовать только необходимый для него функционал.

#### 5) Принцип инверсии зависимостей (DIP-Dependency Inversion Principle)
Этот принцип SOLID в Java описывают так: зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с помощью абстракции. 

Классическое применение этого принципа — Spring framework. В рамках Spring framework все модули выполнены в виде отдельных компонентов, которые могут работать вместе. Они настолько автономны, что могут быть быть с такой же легкостью задействованы в других программных модулях помимо Spring framework.

Это достигнуто за счет зависимости закрытых и открытых принципов. Все модули предоставляют доступ только к абстракции, которая может использоваться в другом модуле.

Попробуем продемонстрировать это на примере. Говоря о принципе единственной ответственности, мы рассматривали некоторый `OrderProcessor`. Взглянем еще раз на код данного класса: 
```java
public class OrderProcessor {
    public void process(Order order){

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
```
В данном примере наш `OrderProcessor` зависит от двух конкретных классов `MySQLOrderRepository` и `ConfirmationEmailSender`. Приведем также код данных классов:
```java
public class MySQLOrderRepository {
    public boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных

        return true;
    }
}

public class ConfirmationEmailSender {
    public void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();

        // Шлем письмо клиенту
    }
}
```
Эти классы далеки от того, чтобы называться абстракциями. И с точки зрения принципа DIP было бы правильнее для начала создать некоторые абстракции, которые позволят нам оперировать в дальнейшем ими, а не конкретными реализациями. Создадим два интерфейса `MailSender` и `OrderRepository`, которые и станут нашими абстракциями:
```java
public interface MailSender {
    void sendConfirmationEmail(Order order);
}

public interface OrderRepository {
    boolean save(Order order);
}
```
Теперь имплементируем данные интерфейсы в уже готовых для этого классах: 
```java
public class ConfirmationEmailSender implements MailSender {

    @Override
    public void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();
        // Шлем письмо клиенту
    }
}

public class MySQLOrderRepository implements OrderRepository {

    @Override
    public boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных
        return true;
    }
}
```
Мы провели подготовительную работу, чтобы наш класс `OrderProcessor` зависит не от конкретных деталей, а от абстракций. Внесем в него изменения, внедряя наши зависимости в конструкторе класса: 
```java
public class OrderProcessor {

    private MailSender mailSender;
    private OrderRepository repository;

    public OrderProcessor(MailSender mailSender, OrderRepository repository) {
        this.mailSender = mailSender;
        this.repository = repository;
    }

    public void process(Order order){
        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
```
Теперь наш класс зависит от абстракций, а не от конкретных реализаций. Можно без труда менять его поведение, внедряя нужную зависимость в момент создания экземпляра `OrderProcessor`.
+ [Thema#1 Question#13  Go to OOP](#Theme1___OOP)

# Источники
+ [DevColibri](http://devcolibri.com/720)
+ [Хабрахабр](https://habrahabr.ru/post/87119/)
+ [Википедия](https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование)


__Thema2 - JavaLanguages ______________________________________________________________________________________________________________________________

## Какая основная идея языка?
«Написано однажды - работает везде».
Идея основывается в написании одного кода, который будет работать на любой платформе.
+ [Thema#2 Question#1  Go to JavaLanguages](#Thema2___JavaLanguages)

## За счет чего обеспечивается кроссплатформенность?
Кроссплатформенность была достигнута за счёт создания виртуальной машины Java. `Java Virtual Machine` или `JVM` - это программа, являющаяся прослойкой между операционной системой и Java программой. В среде виртуальной машины выполняются коды Java программ. Сама `JVM` реализована для разных ОС.
+ [Thema#2 Question#2  Go to JavaLanguages](#Thema2___JavaLanguages)

## Какие преимущества у java?
__1) Объектно-ориентированное программирование__   
+ структура данных становится объектом, которым можно управлять для создания отношений между различными объектами.

__2) Язык высокого уровня с простым синтаксисом и плавной кривой обучения__ 
+ синтаксис Java основан на C++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов.

__3) Стандарт для корпоративных вычислительных систем__
+ корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.

__4) Безопасность__ 
+ благодарю отсутсвию указателей и `Security Manager` (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в "песочнице").

__5) Независимость от платформы__ 
+ Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (`JVM`). Таким образом, `JVM` служит уровнем абстракции между кодом и оборудованием.

__6) Язык для распределенного программирования и комфортной удаленной совместной работы__
+ Специфическая для Java методология распределенных вычислений называется `Remote Method Invocation (RMI)`. `RMI` позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.

__7) Автоматическое управление памятью__
+ Разработчикам Java не нужно вручную писать код для управления памятью благодаря 
автоматическому управлению памятью (`AMM`).

__8) Многопоточность__
+ Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.

__9) Стабильность и сообщество__
+ Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 используют Java.
+ [Thema#2 Question#3  Go to JavaLanguages](#Thema2___JavaLanguages)

## Какие недостатки у Java?
__1) Платное коммерческое использование (с 2019)__

__2) Низкая производительность__
+ из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.

__3) Не развитые инструменты по созданию GUI приложений на чистой java.__

__4) Многословный код__
+ Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.
+ [Thema#2 Question#4  Go to JavaLanguages](#Thema2___JavaLanguages)

## Что такое JDK? Что в него входит?
__JDK (Java Development Kit) - включает `JRE` и набор инструментов разработчика приложений на языке Java:__
- компилятор Java (javac)
- стандартные библиотеки классов java
- примеры
- документацию
- различные утилиты

+ [Thema#2 Question#5  Go to JavaLanguages](#Thema2___JavaLanguages)

## Что такое JRE? что в него входит?
__JRE (java Runtime Environment)__ - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из `JVM`, `ClassLoader` и стандартного набора библиотек и классов Java
+ [Thema#2 Question#6  Go to JavaLanguages](#Thema2___JavaLanguages)

## Что такое JVM?
__JVM (Java Virtual Machine)__ - виртуальная машина Java исполняет байт-код Java, предварительно созданный из кода `JIT компилятором`, с помощью встроенного интерпретатора байткода.
`HotSpot` представляет собой реализацию концепции `JVM`.
+ [Thema#2 Question#7  Go to JavaLanguages](#Thema2___JavaLanguages)

## Что такое byte code?	
Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый `JVM`.
+ [Thema#2 Question#8  Go to JavaLanguages](#Thema2___JavaLanguages)

## Что такое загрузчик классов (classloader)?
Используется для передачи в `JVM` скомпилированного байт-кода, хранится в файлах с расширением `.class`

__При запуске `JVM`, используются три загрузчика классов:__

__1) Bootstrap ClassLoader__ - базовый загрузчик
- загружает платформенные классы JDK из архива `rt.jar`

__2) AppClassLoader__ - системный загрузчик
- загружает классы приложения, определенные в `CLASSPATH` 

__3) Extension ClassLoader__ - загрузчик расширений 
- загружает классы расширений, которые по умолчанию находятся в каталоге `jre/lib/ext`.

__ClassLoader выполняет три основных действия в строгом порядке:__

__1) Загрузка:__ находит и импортирует двоичные данные для типа.

__2) Связывание:__ выполняет проверку, подготовку и (необязательно) разрешение.
+ Проверка: обеспечивает правильность импортируемого типа.
+ Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
+ Разрешение: преобразует символические ссылки из типа в прямые ссылки.

__3) Инициализация:__ вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.

Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать
+ [Thema#2 Question#9  Go to JavaLanguages](#Thema2___JavaLanguages)

## Что такое JIT?
JIT (Just-in-time compilation) - компиляция на лету или динамическая компиляция - технология увеличения производительности программных систем, использующих байт-код, путем компиляции байт-кода в машинный код во время работы программы.
+ [Thema#2 Question#10  Go to JavaLanguages](#Thema2___JavaLanguages)

## Что такое Heap и Stack память в Java? Чем они отличаются?
__Память процесса делится на `Stack(стек)` и `Heap(куча)` :__
- `Stack` содержит `staсk frame'ы`, они делятся на три части: параметры метода, указатель на предыдущий фрейм и локальные переменные.
- Структура `Heap` зависит от выбранного сборщика мусора. Читай про GC!

`MetaSpace` - специальное пространство кучи, отделенное от кучи основной памяти. `JVM` хранит здесь весь статический контент. Это включает в себя все статические методы, примитивные переменные и ссылки на статические объекты. Кроме того, он содержит данные о байт-коде, именах и `JIT-информации` . До Java 7 `String Pool` также был частью этой памяти. 

С помощью опций `Xms` и `Xmx` можно настроить начальный и максимально допустимый размер кучи соответственно. Существуют опции для настройки величины стека.
- `Heap` - используется всем приложением, `Stack` - одним потоком исполняемой программы.
- Новый обьект создается в `heap`, в `stack` размещается ссылка на него. В стеке размещаются локальные переменные примитивных типов. 
- Обьекты в куче доступны из любого места программы, стековая память не доступна для других потоков.
- Если память стека закончилась `JRE` вызовет исключение `StackOverflowError`, если куча заполнена `OutOfMemoryError`
- Размер памяти стека, меньше памяти кучи. Стековая память быстрее памяти кучи.
- В куче есть ссылки между объектами и их классами. На этом основана рефлексия.

Обе области хранятся в RAM.
+ [Thema#2 Question#11  Go to JavaLanguages](#Thema2___JavaLanguages)

## Виды ссылок в Java

__1) StrongReference__ — это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.
        StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder.
        
__2) SoftReference__ —  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит `OutOfMemoryError`. `SoftReference` это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.
        StringBuilder builder = new StringBuilder();
        SoftReference<StringBuilder> softBuilder = new SoftReference(builder);

softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется null.
softBuilder.clear() — удалит ссылку на объект StringBuilder
То же самое работает для WeakReference.

__3) WeakReference__ — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезли strong-ссылки), то он удалит его из памяти

__4) PhantomReference__ — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.
Особенностей у этого типа ссылок две.
+ Первая это то, что метод get() всегда возвращает null. Именно из-за этого `PhantomReference` имеет смысл использовать только вместе с `ReferenceQueue`.
+ Вторая особенность – в отличие от `SoftReference` и `WeakReference`, GC добавит phantom-ссылку в `ReferenceQueue` после того как выполниться метод `finalize()`.

So in brief: Soft references try to keep the reference. Weak references don’t try to keep the reference. Phantom references don’t free the reference until cleared

__ReferenceQueue.__ Он позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. При создании `Reference` мы можем передать в конструктор `ReferenceQueue`, в который будут помещаться ссылки после удаления
+ [Thema#2 Question#12  Go to JavaLanguages](#Thema2___JavaLanguages)

## Что такое сборщик мусора? (Garbage collector)
Сборщик мусора выполняет две задачи:
+ поиск мусора;
+ очистка мусора.

Для обнаружения мусора есть два подхода:

__1) Учет ссылок (Reference counting);__
+ Учет ссылок - если обьект не имеет ссылок, он считается мусором.
Проблема - не возможность выявить циклические ссылки, когда два обьекта не имеют внешних ссылок, но ссылаются друг на друга -> утечка памяти

__2) Трассировка (Tracing). (используется в HotSpot6)__
+ Трассировка - до обьекта можно добраться из Корневых точек (GC root). 
До чего добраться нельзя - мусор.
Всё, что доступно из «живого» объекта, также является «живым».

__Типы корневых точек (GC Roots) java приложения:__
+ объекты в статических полях классов
+ объекты, доступные из стека потоков
+ объекты из JNI(java native interface) ссылок в native методах

Самое простое java приложение будет иметь корневые точки:

+ Локальные переменные внутри `main()` метода и параметры `main()` метода;
+ Поток который выполняет `main()`;
+ Статические переменные класса, внутри которого находится `main()` метод.

__Процессы сборки мусора разделяются на несколько видов:__

__1) minor GC (малая)__ - частый и быстрый, работает только с областью памяти "`young generation`";
+ приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);
+ «живые» объекты из Eden перемещаются в область памяти «To»;
+ «живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»;
+ Eden и «From» очищаются от мусора;
+ «To» и «From» меняются местами;
+ приложение возобновляет работу.

__2) major GC (старшая)__ - редкий и более длительный, затрагивает объекты старшего поколения.
В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.

__3) full GC (полная)__ -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения).

Про 4 типа сборщиков мусора читай сдесь: habr.com/ru/post/269621

Для очистки памяти от мусора существуют два основных метода:

+ _Copying collectors_
+ _Mark-and-sweep_

При __copying collectors__ подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:

+ Объекты создаются в «from-space»;
+ Когда «from-space» заполняется, приложение приостанавливается;
+ Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;
+ Когда все объекты скопированы «from-space» полностью очищается;
+ «to-space» и «from-space» меняются местами.

Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:

1. Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;
2. В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.

Алгоритм работы __mark-and-sweep__ можно описать так:

+ Объекты создаются в памяти;
+ В момент, когда нужно запустить сборщик мусора приложение приостанавливается;
+ Сборщик проходится по дереву объектов, помечая живые объекты;
+ Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;
+ Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».

Минусы этого способа:

1. Приложение не работает пока происходит сборка мусора;
2. Время остановки напрямую зависит от размеров памяти и количества объектов;
3. Если не использовать «compacting» память будет использоваться не эффективно.

Сборщики мусора HotSpot VM используют комбинированный подход __Generational Garbage Collection__, который позволяет использовать разные алгоритмы для разных этапов сборки мусора. Этот подход опирается на том, что:

+ большинство создаваемых объектов быстро становятся мусором;
+ существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.

+ [Thema#2 Question#13  Go to JavaLanguages](#Thema2___JavaLanguages)

## Как работает сборщик мусора?
Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых объектов.

Объекты создаются посредством оператора `new`, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив переменной ссылку на другой объект или значение `null`; прекратить выполнение метода, чтобы его локальные переменные завершили свое существование естественным образом. Объекты, ссылки на которые отсутствуют, принято называть мусором (_garbage_), который будет удален.

Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект, обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти. Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим посредством цепочки ссылок, начиная с корневой (_GC Root_) ссылки, т.е. ссылки, непосредственно существующей в выполняемом коде.

Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.

Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления большого количества объектов существенным образом сказывается на производительности приложений и если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора, подлежащего утилизации.
+ [Thema#2 Question#14  Go to JavaLanguages](#Thema2___JavaLanguages)

## Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?
Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:

+ __Serial (последовательный)__ — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. На данный момент используется сравнительно редко, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. Использование Serial GC включается опцией `-XX:+UseSerialGC`.
+ __Parallel (параллельный)__ — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. Параллельный сборщик включается опцией `-XX:+UseParallelGC`.
+ __Concurrent Mark Sweep (CMS)__ — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти. Использование CMS GC включается опцией `-XX:+UseConcMarkSweepGC`.
+ __Garbage-First (G1)__ — создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных. _G1_ включается опцией Java `-XX:+UseG1GC`.

+ [Thema#2 Question#15  Go to JavaLanguages](#Thema2___JavaLanguages)

## Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.
__Serial Garbage Collector (Последовательный сборщик мусора)__ был одним из первых сборщиков мусора в HotSpot VM. Во время работы этого сборщика приложения приостанавливается и продолжает работать только после прекращения сборки мусора. 

Память приложения делится на три пространства:

+ _Young generation_. Объекты создаются именно в этом участке памяти.
+ _Old generation_. В этот участок памяти перемещаются объекты, которые переживают «minor garbage collection».
+ _Permanent generation_. Тут хранятся метаданные об объектах, _Class data sharing (CDS)_, _пул строк (String pool)_. Permanent область делится на две: только для чтения и для чтения-записи. Очевидно, что в этом случае область только для чтения не чистится сборщиком мусора никогда.

Область памяти Young generation состоит из трёх областей: _Eden_ и двух меньших по размеру _Survivor spaces_ - _To space_ и _From space_. Большинство объектов создаются в области Eden, за исключением очень больших объектов, которые не могут быть размещены в ней и поэтому сразу размещаются в Old generation. В Survivor spaces перемещаются объекты, которые пережили по крайней мере одну сборку мусора, но ещё не достигли порога «старости» (_tenuring threshold_), чтобы быть перемещенными в Old generation.

Когда Young generation заполняется, то в этой области запускается процесс лёгкой сборки (_minor collection_), в отличие от процесса сборки, проводимого над всей кучей (_full collection_). Он происходит следующим образом: в начале работы одно из Survivor spaces - To space, является пустым, а другое - From space, содержит объекты, пережившие предыдущие сборки. Сборщик мусора ищет живые объекты в Eden и копирует их в To space, а затем копирует туда же и живые «молодые» (то есть не пережившие еще заданное число сборок мусора) объекты из From space. Старые объекты из From space перемещаются в Old generation. После лёгкой сборки From space и To space меняются ролями, область Eden становится пустой, а число объектов в Old generation увеличивается.

Если в процессе копирования живых объектов To space переполняется, то оставшиеся живые объекты из Eden и From space, которым не хватило места в To space, будут перемещены в Old generation, независимо от того, сколько сборок мусора они пережили.

Поскольку при использовании этого алгоритма сборщик мусора просто копирует все живые объекты из одной области памяти в другую, то такой сборщик мусора называется _copying_ (копирующий). Очевидно, что для работы копирующего сборщика мусора у приложения всегда должна быть свободная область памяти, в которую будут копироваться живые объекты, и такой алгоритм может применяться для областей памяти сравнительно небольших по отношению к общему размеру памяти приложения. Young generation как раз удовлетворяет этому условию (по умолчанию на машинах клиентского типа эта область занимает около 10% кучи (значение может варьироваться в зависимости от платформы)).

Однако, для сборки мусора в Old generation, занимающем большую часть всей памяти, используется другой алгоритм.

В Old generation сборка мусора происходит с использованием алгоритма _mark-sweep-compact_, который состоит из трёх фаз. В фазе _Mark_ (пометка) сборщик мусора помечает все живые объекты, затем, в фазе _Sweep_ (очистка) все не помеченные объекты удаляются, а в фазе _Сompact_ (уплотнение) все живые объекты перемещаются в начало Old generation, в результате чего свободная память после очистки представляет собой непрерывную область. Фаза уплотнения выполняется для того, чтобы избежать фрагментации и упростить процесс выделения памяти в Old generation.

Когда свободная память представляет собой непрерывную область, то для выделения памяти под создаваемый объект можно использовать очень быстрый (около десятка машинных инструкций) алгоритм _bump-the-pointer_: адрес начала свободной памяти хранится в специальном указателе, и когда поступает запрос на создание нового объекта, код проверяет, что для нового объекта достаточно места, и, если это так, то просто увеличивает указатель на размер объекта.

Последовательный сборщик мусора отлично подходит для большинства приложений, использующих до 200 мегабайт кучи, работающих на машинах клиентского типа и не предъявляющих жёстких требований к величине пауз, затрачиваемых на сборку мусора. В то же время модель «stop-the-world» может вызвать длительные паузы в работе приложения при использовании больших объёмов памяти. Кроме того, последовательный алгоритм работы не позволяет оптимально использовать вычислительные ресурсы компьютера, и последовательный сборщик мусора может стать узким местом при работе приложения на многопроцессорных машинах.
+ [Thema#2 Question#16  Go to JavaLanguages](#Thema2___JavaLanguages)

## Что произойдет со сборщиком мусора, если выполнение метода `finalize()` требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?
Непосредственно вызов `finalize()` происходит в отдельном потоке _Finalizer_ (`java.lang.ref.Finalizer.FinalizerThread`), который создаётся при запуске виртуальной машины (в статической секции при загрузке класса `Finalizer`). Методы `finalize()` вызываются последовательно в том порядке, в котором были добавлены в список сборщиком мусора. Соответственно, если какой-то `finalize()` зависнет, он подвесит поток _Finalizer_, но не сборщик мусора. Это в частности означает, что объекты, не имеющие метода `finalize()`, будут исправно удаляться, а вот имеющие будут добавляться в очередь, пока поток _Finalizer_ не освободится, не завершится приложение или не кончится память. 

То же самое применимо и выброшенным в процессе `finalize()` исключениям: метод `runFinalizer()` у потока _Finalizer_ игнорирует все исключения выброшенные в момент выполнения `finalize()`. Таким образом возникновение исключительной ситуации никак не скажется на работоспособности сборщика мусора.
+ [Thema#2 Question#17  Go to JavaLanguages](#Thema2___JavaLanguages)

## Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?
Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора `new`) хранится в куче.
+ [Thema#2 Question#18  Go to JavaLanguages](#Thema2___JavaLanguages)


## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ

+ [Дюк, вынеси мусор! — Часть 1(2015)-->]( https://habr.com/ru/post/269621/ )
+ [Дюк, вынеси мусор! — Часть 2(2015)-->]( https://habr.com/ru/post/269707/ )
+ [Дюк, вынеси мусор! — Часть 3(2015)-->]( https://habr.com/ru/post/269863/ )
+ [Управление памятью Java(2021)-->]( https://m.habr.com/ru/post/549176/ )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )


__Thema3 - ProceduralJava___________________________________________________________________________________________________
    
## Сколько ключевых слов зарезервировано языком, что это за слова, какие из них не используются?
50, два из них не используются: const, goto;

Для запоминания это:
+ Примитивы (byte, short, int, long, char, float, double, boolean)
+ Циклы и ветвления (if, else, switch, case, default, while, do, break, continue, for)
+ Исключения (try, catch, finally, throw, throws)
+ Области видимости (private, protected, public)
+ Объявление \ Импорт (import, package, class, interface, extends, implements, static, final, void, abstract, native)
+ Создание \ Возврат \ Вызов (new, return, this, super)
+ Многопоточность (synchronized, volatile)
+ instanceof, enum, assert, transient, strictfp, const, goto

http://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html

+ [Thema#3 Question#1  Go to ProceduralJava](#Thema3___ProceduralJava)

## Из каких символов может состоять имя переменной (корректный идентификатор)?
Имя или идентификатор переменной — это последовательность из строчных и заглавных латинских букв, цифр, а также символов «$» и «_». Имя переменной может начинаться с любого из перечисленных символов, кроме цифры.

Технически возможно начать имя переменной также с «$» или «_», однако это запрещено соглашением по оформлению кода в Java (Java Code Conventions). Кроме того, символ доллара «$», по соглашению, никогда не используется вообще. В соответствии с соглашением имя переменной должно начинаться именно с маленькой буквы (с заглавной буквы начинаются имена классов). Пробелы при именовании переменных не допускаются.
+ [Thema#3 Question#2  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какие примитивные типы данных есть в Java?
__Вещественные, целочисленные, логические, строковые__

Примитивные:
+ byte (целые числа, 1 байт, [-128, 127])
+ short (целые числа, 2 байта, [-32768, 32767])
+ int (целые числа, 4 байта, [-2147483648, 2147483647])
+ long (целые числа, 8 байт, [-9223372036854775808,9223372036854775807])
+ float (вещественные числа, 4 байта)
+ double (вещественные числа, 8 байт)
+ char (символ Unicode, 2 байта, [0, 65536])
+ boolean (значение истина/ложь, используется int, зависит от JVM)

Ссылочные. В ссылочные типы входят все классы, интерфейсы, массивы.

http://stackoverflow.com/questions/383551/what-is-the-size-of-a-boolean-variable-in-java
boolean type: http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.3.4
boolean — боремся за Java память… https://habrahabr.ru/post/76481/

+ [Thema#3 Question#3  Go to ProceduralJava](#Thema3___ProceduralJava)

## Что такое char?
16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)
+ [Thema#3 Question#4  Go to ProceduralJava](#Thema3___ProceduralJava)

## Сколько памяти занимает boolean?
Зависит от реализации JVM
В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.
Также есть библиотеки для уменьшения размера boolean: BitSet и OpenBitSet (от Apache).
Тип boolean прекрасно определяется множеством своих допустимых значений. Математически оно ограничивает минимальный размер значения одним битом.

Но использовать именно один бит (и ни битом более) эффективно далеко не всегда, поскольку на популярных архитектурах нельзя адресовать отдельные биты. А потому значения отдельных boolean'ов нельзя быстро сохранить в отдельные биты оперативной памяти — необходимо использовать комбинацию побитовых операций, что почти наверняка будет медленнее, чем запись целого отдельного регистра в оперативную память (размер которого может быть различным на разных платформах!).

Но при этом, к примеру, я вполне себе представляю, как на x86 компилятор может использовать в нативном коде в качестве какого-нибудь конкретного boolean-значения один бит регистра флагов, при условии, что это значение никогда не попадает в оперативную память (отдельно от других). Поэтому любые ограничения на размер более одного бита тоже могут потенциально мешать.

И эта свобода представления позволяет авторам виртуальных машин Java использовать любые реализации, которые они считают наиболее эффективными в каждом конкретном контексте. Как видно из примеров выше, любые ограничения будут только мешать.
+ [Thema#3 Question#5  Go to ProceduralJava](#Thema3___ProceduralJava)

## Что такое классы-обертки (Wrapper Class)?
Обертка — это специальный класс, который хранит внутри себя значение примитива.
Нужны для реализации дженериков.
Популярные методы:
+ Double.parseDouble(a);//пожалуй, самый популярный метод перевод из строки в целочисленный или дробный тип
+ System.out.println(Integer.MAX_VALUE);//константа максимального значения
+ System.out.println(Integer.bitCount(78));// в двоичном виде
+ System.out.println(Float.valueOf("80"));//возвращает целочисленный объект, содержащий значение указанного типа
Хотелось бы еще рассмотреть создание Boolean переменной:
```java
public class BooleanExample {
    public static void main(String[] args){
        Boolean b1 = new Boolean(false);//false
        Boolean b2 = new Boolean("false");//false
        Boolean b3 = new Boolean(true);//true
        Boolean b4 = new Boolean("true");//true
        Boolean b5 = new Boolean("hi there");//false
    }
}
```
+ [Thema#3 Question#6  Go to ProceduralJava](#Thema3___ProceduralJava)

## Что такое автоупаковка и автораспаковка?
__Автоупаковка__ - присвоение классу обертки значения примитивного типа;
__Автораспаковка__ - присвоение переменной примитивного типа значение класса обертки.

Для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически.

__Автоупаковка__ - это механизм неявной инициализации объектов классов-оберток (`Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`) значениями соответствующих им исходных примитивных типов (`byte`, `short`, `int`...), без явного использования конструктора класса. 

+ Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора `=`), либо при передаче примитива в параметры метода (типа класса-обертки). 

+ Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и `final`-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.

+ Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа `byte` в `Short`, без предварительного явного приведения `byte` в `short` вызовет ошибку компиляции.

+ Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:
    1) неявное расширение/сужение исходного типа примитива до типа примитива соответствующего классу-обертке (для преобразования `int` в `Byte`, сначала компилятор самостоятельно неявно сужает `int` к `byte`)
    2) автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения:
        a) присвоение примитива обертке может производится только оператором `=` (нельзя передать такой примитив в параметры метода без явного приведения типов)
        b) тип левого операнда не должен быть старше чем `Character`, тип правого не дожен старше, чем `int`: допустимо расширение/сужение `byte` в/из `short`, `byte` в/из `char`, `short` в/из `char` и только сужение `byte` из `int`, `short` из `int`, `char` из `int`. Все остальные варианты требуют явного приведения типов).

Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне `-128 ... +127` я вляется то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.
+ [Thema#3 Question#7  Go to ProceduralJava](#Thema3___ProceduralJava)

## Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?
__Неявное приведение__ – автоматическое расширение типа переменной от меньшего к большему.
__Явное приведение__ -  явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.
В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.

Преобразование может быть неявным и явным (приведение типов). Неявное преобразование может выполняться если:
типы совместимы (например – оба целочисленные)
размер “принимающего” типа больше чем у того, который преобразуется (так называемое “преобразование с расширением”)
```java
int a = 123454;
double b =  a; //неявное преобразование - преобразование с расширением
int a = 123454;
double b =  a; //неявное преобразование - преобразование с расширением

Явное преобразование имеет вид переменная_нового_типа = (новый_тип) имя переменной;
int a;
byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных
int a;
byte b = (byte) a; //b будет остатком от деления a на диапазон byte, может быть потеря данных
```
Примеры:
```java
public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0

        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }

    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127

        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56

        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }

public static void typeConverterExample() {
        long a = 100L;
        double b = 300.0;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 400.0
 
        double c = 1000.05;
        long d = 1000;
        Object cd = c+d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Double value: 2000.05
    }
 
    public static void typeNarrowing() {
        int a0 = 64;
        int a = 257;
        int a2 = 126;
        int a3 = 129;
        byte b0 = (byte) a0;
        byte b = (byte) a;
        byte b2 = (byte) a2;
        byte b3 = (byte) a3;
        System.out.println(b0+ " " + b + " " + b2 + " " + b3); //64 1 126 -127
 
        double c = 56.9876;
        int d = (int) c;
        System.out.println(d); //56
 
        long e = 1000L;
        float f = (float) e;
        System.out.println(f); //1000.0
    }
```
При повышении типа byte>short; short>int; int>long; float>double; char>int информация не потеряется. При сужении возможна потеря информации (см. пример выше byte = (byte) int).

При различных операциях может происходить повышение типов в порядке “усиления” к более информативному типу. Например складывая int и double получим тип double. Но есть и особенность, например сложив double (8 байт) и long (8 байт) Java оставит знаки после запятой (double), а не более “длинный” тип. Аналогичный пример с вещественной частью:
```java
  long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0

        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0

  long a = 100L;
        double b = a;
        Object ab = a + b;
        System.out.println(ab.getClass().getName() + " value: " + ab); //java.lang.Double value: 200.0
 
        float c = 100;
        long d = 1000;
        Object cd = c - d;
        System.out.println(cd.getClass().getName() +" value: " + cd);//java.lang.Float value: -900.0
```
Кратко можно записать такие правила:
+ byte, short, char в выражениях всегда повышаются до int
+ если в выражении участвует тип long – то именно к этому типу будет приведён результат
+ если в выражении участвует float – то результат приводится к float
+ если один из операндов имеет тип double – то к этому типу будет приведён весь результат
+ При выборе между длиной и возможностью сохранить дробную часть – будет выбрана дробная часть

+ [Thema#3 Question#8  Go to ProceduralJava](#Thema3___ProceduralJava)

## Что такое пул интов?
В Java есть пул(pool) целых чисел в промежутке [-128;127], так как это самый часто вречающийся диапазон. Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула. 
Изменить размер кэша в HotSpot вы можете, указав ключ -XX:AutoBoxCacheMax=<размер>.
+ [Thema#3 Question#9  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какие нюансы у строк в Java?
Класс `String` в Java -  неизменяемый из-за модификатора `final` и отсутствия сеттера. Это нужно для реализации пула стрингов. При редактировании будет создаваться новая строка. При копировании новая строка не создается, а создается ссылка на существующую строку.
+ Это неизменяемый (immutable) и финализированный тип данных;
+ Все объекты класса `String` JVM хранит в пуле строк;
+ Объект класса `String` можно получить, используя двойные кавычки;
+ Можно использовать оператор `+` для конкатенации строк;
+ Начиная с Java 7 строки можно использовать в конструкции `switch`.

+ [Thema#3 Question#10  Go to ProceduralJava](#Thema3___ProceduralJava)

## Что такое пул строк?
__Область памяти где хранятся обьекты строк.__ 
При создании в пуле идет поиск строки:
+ если НЕ находит -  создается строка, возращается ссылка
+ если находит - возращает ссылку найденной строки.

При этом использование оператора `new` заставляет класс `String` создать новый объект, даже если такая строка уже есть в пуле. После этого можем использовать метод `intern()`, чтобы поместить этот объект в пул строк.

Пул строк и `Integer` хранится в heap, но ссылки на объекты хранятся в `stack`.
+ [Thema#3 Question#11  Go to ProceduralJava](#Thema3___ProceduralJava)

## Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?
Т.к. строка неизменяемый класс, потребление ресурсов при редактировании, т.к. каждую итерацию при редактировании будет создаваться новый обьект строки. 
Рекомендуется использовать `StringBuilder`
+ [Thema#3 Question#12  Go to ProceduralJava](#Thema3___ProceduralJava)

## Почему строки не рекомендуется использовать для хранения паролей?
1) __Строки — неизменны__
Так как строки в Java являются неизменными, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её. И поскольку `String `используются в `String pool` для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно. 

2) __Рекомендации авторов__
Java сама по себе рекомендует использовать метод `getPassword ()` из класса `JPasswordField`, который возвращает `char []`.
В случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке.

3) __Случайная печать в логах__
С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли. В то же время в случае использования `Array`, вы не будете печатать содержимое массива, а только его расположение в памяти.

+ [Thema#3 Question#13  Go to ProceduralJava](#Thema3___ProceduralJava)

## Почему `String` неизменяемый и финализированный класс?
Есть несколько преимуществ в неизменности строк:

1) __Для возможности реализации строкового пула (`String pool`)__

Виртуальная машина имеет возможность сохранить много места в памяти (`heap space`) т.к. разные строковые переменные указывают на одну переменную в пуле. При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.

2) __Безопасность__

Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.

3) __Для многопоточности. Неизменяемые строки потокобезопасны__

Так как строка неизменяемая то, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны.

4) __Ключ для HashMap__

Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в `Map` и его обработка будет быстрее, чем других ключей `HashMap`. Поэтому строка наиболее часто используется в качестве ключа `HashMap`.

5) Строки используются `_classloader_` и неизменность обеспечивает правильность загрузки класса.

+ [Thema#3 Question#14  Go to ProceduralJava](#Thema3___ProceduralJava)

## Почему строка является популярным ключом в `HashMap` в Java?
Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не требуя повторного пересчета при дальнейшем использовании. Поэтому в качестве ключа `HashMap` они будут обрабатываться быстрее.
+ [Thema#3 Question#15  Go to ProceduralJava](#Thema3___ProceduralJava)

## Что делает метод `intern()` в классе `String`?
Метод `intern()` используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле.
+ [Thema#3 Question#16  Go to ProceduralJava](#Thema3___ProceduralJava)

## Можно ли использовать строки в конструкции `switch`?
Да, начиная с Java 7 в операторе `switch` можно использовать строки, ранние версии Java не поддерживают этого. При этом:

+ участвующие строки чувствительны к регистру;
+ используется метод `equals()` для сравнения полученного значения со значениями `case`, поэтому во избежание `NullPointerException` стоит предусмотреть проверку на `null`.
+ согласно документации, Java 7 для строк в `switch`, компилятор Java формирует более эффективный байткод для строк в конструкции `switch`, чем для сцепленных условий `if`-`else`.
+ должно присутствовать ключевое слово `default`

+ [Thema#3 Question#17  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какая основная разница между `String`, `StringBuffer`, `StringBuilder`?
Класс `String`(НЕизменяемый, потобезопасный) является неизменяемым (_immutable_) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.

Класс `StringBuffer` (изменяемый, потокобезопасный) - использовать `StringBuffer` следует тогда, когда необходимо часто модифицировать содержимое. 

Класс `StringBuilder` (изменяемый, НЕпотокобезопасный) - был добавлен в Java 5 и он во всем идентичен классу `StringBuffer` за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.

+ [Thema#3 Question#18  Go to ProceduralJava](#Thema3___ProceduralJava)

## Методы класса `String`?
+ str.length(); - возвращает длину строки
+ str.replaceAll(Character.toString(ch), ""); - для замены всех вхождений в строку другой строкой
+ toUpperCase / toLowerCase - изменение регистра строки
+ subSequence внутри вызывает метод substring и выделяет подстроку из строки
+ equals(String str) метод сравнения строк
+ compareTo(String anotherString) - сравнивает объект String с полученным аргументом String лексикографически. Если текущая строка предшествует полученной строке, метод возвращает отрицательное значение типа integer, и если строка следует за полученным аргументом, то возвращает положительное значение integer. Если метод возвращает 0, значит строка имеет то же значение, в таком случае метод equals(String str) так же вернет true
+ char c = str.charAt(1); - метод для получения символа, находящегося в указанной позиции
+ char[] chArr = str.toCharArray(); - для преобразования строки в массив символов
+ byte[] byteArr = str.getBytes(); - для преобразования строки в массив байтов
+ String[] words = line.split(" "); - для разделения строки на массив строк, используя в качестве разделителя регулярное выражение.
+ String c = b.intern(); - если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается

+ [Thema#3 Question#19  Go to ProceduralJava](#Thema3___ProceduralJava)

## Методы класса `Character`?
+ boolean isLetter (char ch) : этот метод используется для определения, является ли указанное значение char (ch) буквой или нет
+ boolean isDigit (char ch) : этот метод используется для определения, является ли указанное значение char (ch) цифрой или нет
+ boolean isWhitespace (char ch ) : определяет, является ли указанное значение char (ch) пробелом
+ boolean isUpperCase (char ch) : определяет, является ли указанное значение char (ch) заглавными или нет.
+ boolean isLowerCase (char ch) : определяет, является ли указанное значение char (ch) строчными или нет.
+ toString (char ch) : возвращает объект класса String, представляющий указанное символьное значение (ch), то есть односимвольную строку. Здесь мы не можем передать значение ASCII.
+ char charValue () : этот метод возвращает значение этого объекта Character.

+ [Thema#3 Question#20  Go to ProceduralJava](#Thema3___ProceduralJava)

## Существуют ли в java многомерные массивы?
Многомерные массивы в их классическом понимании в java не существуют.
Многомерный массив всегда прямоугольный и неразрывен в памяти. А то, что в java считается мнгомерным - в других языках ещё называют "зубчатым массивом" или массивом массивов.
+ [Thema#3 Question#21  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какими значениями инициируются переменные по умолчанию?
+ byte --> 0
+ short --> 0
+ int --> 0
+ long --> 0L
+ float --> 0.0f
+ double --> 0.0d
+ char --> '\u0000' 
+ boolean --> false
+ Обьекты --> null

Локальные (в методе) переменные не имеют значений по умолчанию, их имеют поля класса.
Не `static-поле` класса будет инициализировано после того, как будет создан объект этого класса. А `static-поле` будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.
+ [Thema#3 Question#22  Go to ProceduralJava](#Thema3___ProceduralJava)

## Что такое сигнатура метода?
__Это имя метода плюс параметры__ (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним). В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.
А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется __контрактом метода__.
+ [Thema#3 Question#23  Go to ProceduralJava](#Thema3___ProceduralJava)

## Расскажите про метод main
+ Является, как правило, точкой входа в программу и вызывается JVM. 
+ Как только заканчивается выполнение метода `main()`, так сразу же завершается работа самой программы.
+ `static` - чтобы JVM смогла загрузить его во время компиляции.
+ `public static void` и сигнатура - обязательное декларирование.
+ Мэйнов может быть много и может не быть вообще.
+ Может быть перегружен.

+ [Thema#3 Question#24  Go to ProceduralJava](#Thema3___ProceduralJava)

## Каким образом переменные передаются в методы, по значению или по ссылке?
__По значению!__ 
В случае с объектами, копируется и передается ссылка.
+ [Thema#3 Question#25  Go to ProceduralJava](#Thema3___ProceduralJava)

## Для чего используется оператор `assert`?
__Assert__ (Утверждение) — это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы. Утверждение может автоматически сигнализировать об обнаружении некорректных данных, что обычно приводит к аварийному завершению программы с указанием места обнаружения некорректных данных.

Утверждения существенно упрощают локализацию ошибок в коде. Даже проверка результатов выполнения очевидного кода может оказаться полезной при последующем рефакторинге, после которого код может стать не настолько очевидным и в него может закрасться ошибка. 

Обычно утверждения оставляют включенными во время разработки и тестирования программ, но отключают в релиз-версиях программ.

Т.к. утверждения могут быть удалены на этапе компиляции либо во время исполнения программы, они не должны менять поведение программы. Если в результате удаления утверждения поведение программы может измениться, то это явный признак неправильного использования _assert_. Таким образом, внутри _assert_ нельзя вызывать методы, изменяющие состояние программы, либо внешнего окружения программы. 

В Java проверка утверждений реализована с помощью оператора `assert`, который имеет форму:

`assert [Выражение типа boolean];` или `assert [Выражение типа boolean] : [Выражение любого типа, кроме void];`

Во время выполнения программы в том случае, если поверка утверждений включена, вычисляется значение булевского выражения, и если его результат `false`, то генерируется исключение `java.lang.AssertionError`. В случае использования второй формы оператора `assert` выражение после двоеточия задаёт детальное сообщение о произошедшей ошибке (вычисленное выражение будет преобразовано в строку и передано конструктору `AssertionError`).
+ [Thema#3 Question#26  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какие логические операции и операторы вы знаете?
+ `&`: Логическое _AND_ (И);
+ `&&`: Сокращённое _AND_;
+ `|`: Логическое _OR_ (ИЛИ);
+ `||`: Сокращённое _OR_;
+ `^`: Логическое _XOR_ (исключающее _OR_ (ИЛИ));
+ `!`: Логическое унарное _NOT_ (НЕ);
+ `&=`: _AND_ с присваиванием;
+ `|=`: _OR_ с присваиванием;
+ `^=`: _XOR_ с присваиванием;
+ `==`: Равно;
+ `!=`: Не равно;
+ `?:`: Тернарный (троичный) условный оператор.

+ [Thema#3 Question#27  Go to ProceduralJava](#Thema3___ProceduralJava)


## Что такое тернарный оператор выбора?
Тернарный условный оператор `?:` - оператор, которым можно заменить некоторые конструкции операторов `if-then-else`.

Выражение записывается в следующей форме:
>условие ? выражение1 : выражение2

Если `условие` выполняется, то вычисляется `выражение1` и его результат становится результатом выполнения всего оператора. Если же `условие` равно `false`, то вычисляется `выражение2` и его значение становится результатом работы оператора. Оба операнда `выражение1` и `выражение2` должны возвращать значение одинакового (или совместимого) типа.
+ [Thema#3 Question#28  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какие побитовые операции вы знаете?
+ `~`: Побитовый унарный оператор NOT;
+ `&`: Побитовый AND;
+ `&=`: Побитовый AND с присваиванием;
+ `|`: Побитовый OR;
+ `|=`: Побитовый OR с присваиванием;
+ `^`: Побитовый исключающее XOR;
+ `^=`: Побитовый исключающее XOR с присваиванием;
+ `>>`: Сдвиг вправо (деление на 2 в степени сдвига);
+ `>>=`: Сдвиг вправо с присваиванием;
+ `>>>`: Сдвиг вправо без учёта знака;
+ `>>>=`: Сдвиг вправо без учёта знака с присваиванием;
+ `<<`: Сдвиг влево (умножение на 2 в степени сдвига);
+ `<<=`: Сдвиг влево с присваиванием.

+ [Thema#3 Question#29  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какие унарные и бинарные арифметические операции вы знаете?
Унарные операции выполняются над одним операндом, бинарные – над двумя операндами, а также тернарные – выполняются над тремя операндами. Операндом является переменная или значение (например, число), участвующее в операции.

Пример унарных арифметических операций:
+ / ++ – постфиксный/префиксный инкремент, увеличивает значение целочисленной переменной на 1;
+ / — (двойной минус) – постфиксный/префиксный декремент, уменьшает значение целочисленной переменной на 1;
+ / + – оставляет знак числа;
+ / – – изменяет знак числа.
Слово постфиксный означает, что операция применится к операнду после вычисления всего выражения, в которое операнд входит. Аналогично префиксный означает, что операция применится до вычисления выражения.

Пример бинарных арифметических операций:
+ / + – сложение чисел или строк;
+ / –  – вычитание чисел;
+ / * – умножения чисел;
+ / / – деления чисел;
+ / % – вычисление остатка от деления чисел.
Операция вычисления остатка от деления применима как к целым числам, так и к вещественным.

+ [Thema#3 Question#30  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какова роль и правила написания оператора выбора (switch)?
Оператор switch сравнивает аргумент на равенство с предложенным значением.
```java
switch(ВыражениеДляСравнения) {
    case Совпадение1: 
	    команда;
		break;
	case Совпадение2: 
	    команда;
		break;
	case Совпадение3: 
	    команда;
		break;
	default: 
	    оператор;
	    break;
}
```
Обязательно необходимо ставить break; после завершения тело команды, иначе будет продолжаться выполнение ниже по строчкам.
Подробнее http://developer.alexanderklimov.ru/android/java/switch.php
+ [Thema#3 Question#31  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какие циклы вы знаете, в чем их отличия?
В Java используются циклы for, while, do-while.
```java
while(условие) {
    // тело цикла
}
 
do {
    // тело цикла }
while(условие-логическое выражение)
 
for(инициализация; логическое выражение (условие); шаг (итерация)) {
    // тело цикла
}
 
for(Object object : objects) {
    // тело цикла 
}
```
do-while всегда выполнится хотя бы один раз, т.к. проверка идет после тела цикла.
+ [Thema#3 Question#32  Go to ProceduralJava](#Thema3___ProceduralJava)

## Какие операторы используются для перехода к следующей итерации и немедленной остановки цикла?
+ break; – выход из цикла (не затрагивает внешний цикл).
+ continue; – заканчивает выполнение кода в этом теле цикла. Переход к следующей итерации.
```java
for (int i=0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                if (j == 2) {
                    System.out.println("#A# i: " + i + " j: " + j + " break (end j loop). Will not see #C#");
                    break;
                }
                if (j == 1) {
                    System.out.println("#B# i: " + i + " j: " + j + " continue (j++).Will not see #C#");
                    continue;
                }
                System.out.println("#C# i: " + i + " j: " + j);
            }
        }
#C# i: 0 j: 0
#B# i: 0 j: 1 continue (j++).Will not see #C#
#A# i: 0 j: 2 break (end j loop). Will not see #C#
#C# i: 1 j: 0
#B# i: 1 j: 1 continue (j++).Will not see #C#
#A# i: 1 j: 2 break (end j loop). Will not see #C#
#C# i: 2 j: 0
#B# i: 2 j: 1 continue (j++).Will not see #C#
#A# i: 2 j: 2 break (end j loop). Will not see #C#
```
+ [Thema#3 Question#33  Go to ProceduralJava](#Thema3___ProceduralJava)



__Thema4 - OOPInJava______________________________________________________________________________________________________________________________

## 1-Classes

## Какие типы классов бывают в java?
1) _Top level class_ (Обычный класс):
    + _Abstract class_ (Абстрактный класс);
    + _Final class_ (Финализированный класс).
2) _Interfaces_ (Интерфейс).
3) _Enum_ (Перечисление).
4) _Nested class_ (Вложенный класс):
    + _Static nested class_ (Статический вложенный класс);
    + _Member inner class_ (Простой внутренний класс);
    + _Local inner class_ (Локальный класс);
    + _Anonymous inner class_ (Анонимный класс).

+ [Thema#4 Question#1.1  Go to OOPInJava](#Theme4___OOPInJava)

## Что такое _«статический класс»_?
Это вложенный класс, объявленный с использованием ключевого слова `static`. К классам верхнего уровня модификатор `static` неприменим.
+ [Thema#4 Question#1.2  Go to OOPInJava](#Theme4___OOPInJava)

## Что такое _«локальный класс»_? Каковы его особенности?
__Local inner class__ (Локальный класс) - это вложенный класс, который может быть декларирован в любом блоке, в котором разрешается декларировать переменные. Как и простые внутренние классы (_Member inner class_) локальные классы имеют имена и могут использоваться многократно. Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в нестатическом контексте.
С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.

Локальные классы имеют следующие особенности:
+ Видны только в пределах блока, в котором объявлены;
+ Не могут быть объявлены как `private`/`public`/`protected` или `static`;
+ Не могут иметь внутри себя статических объявлений методов и классов, но могут иметь финальные статические поля, проинициализированные константой;
+ Имеют доступ к полям и методам обрамляющего класса;
+ Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором `final`.

+ [Thema#4 Question#1.3  Go to OOPInJava](#Theme4___OOPInJava)

## Что такое _«анонимные классы»_? Где они применяются?
Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:
+ Их использование разрешено только в одном месте программы - месте его создания;
+ Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
+ Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для: 
+ создания объекта функции (_function object_), например, реализация интерфейса `Comparator`;
+ создания объекта процесса (_process object_), такого как экземпляры классов `Thread`, `Runnable` и подобных;
+ в статическом методе генерации;
+ инициализации открытого статического поля `final`, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.

Анонимные классы всегда являются конечными классами. Каждое объявление анонимного класса уникально. Видны только внутри того метода, в котором определены. В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». 
+ [Thema#4 Question#1.4  Go to OOPInJava](#Theme4___OOPInJava)

## Что такое абстрактные классы? Чем они отличаются от обычных?
Как обычный класс, но с абстрактными методами. 
Нельзя создать объект или экземпляр абстрактного класса.
Наследниками абстрактного класса могут быть другие абстрактные классы
+ [Thema#4 Question#1.5  Go to OOPInJava](#Theme4___OOPInJava)

## Может ли быть абстрактный класс без абстрактных методов?
Да. Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор `abstract`.
+ [Thema#4 Question#1.6  Go to OOPInJava](#Theme4___OOPInJava)

## Что имеет более высокий уровень абстракции - _класс_, _абстрактный класс_ или _интерфейс_?
Интерфейс.
+ [Thema#4 Question#1.7  Go to OOPInJava](#Theme4___OOPInJava)

## Расскажите про вложенные классы. В каких случаях они применяются?
1) __Статические вложенные классы (Static nested classes)__
+ Есть возможность обращения к внутренним статическим полям и методам класса обертки.
2) __Простой внутренний класс(Member inner class)__
+ Есть возможность обращения к внутренним полям и методам класса обертки.
+ Не может иметь статических объявлений.
+ Внутри такого класса нельзя объявить перечисления.
+ Если нужно явно получить this внешнего класса — OuterClass.this
3) __Локальный класс (Local inner class)__
+ Видны только в пределах блока, в котором объявлены.
+ Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).
+ Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final)
+ Имеют доступ к полям и методам обрамляющего класса.
+ Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final.
4) __Анонимные классы (Anonymous inner class)__
+ Локальный класс без имени.

Нужны для обслуживания внешних классов
Класс называется вложенным (_Nested class_), если он определен внутри другого класса. 
Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. 
Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня. 
Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. 
Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.
Такие категории классов, за исключением первого, также называют внутренними (_Inner class_). 
Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.

Каждая из категорий имеет рекомендации по своему применению:
+ Если вложенный класс должен быть виден за пределами одного метода или он слишком длинный для того, 
чтобы его можно было удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр, 
то используется нестатический внутренний класс. 
+ В случае, если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим. 
+ Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в этом методе, то используется локальный класс. 
+ А, если к тому же применение класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий этот класс, 
то рекомендуется делать его анонимным классом.

+ [Thema#4 Question#1.8  Go to OOPInJava](#Theme4___OOPInJava)

## Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?
+ Вложенные классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным. 
+ Для создания объекта статического вложенного класса объект внешнего класса не требуется.
+ Из объекта статического вложенного класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.
+ Обычные вложенные классы не могут содержать статических методов, блоков инициализации и классов. Статические вложенные классы - могут.
+ В объекте обычного вложенного класса хранится ссылка на объект внешнего класса. Внутри статической такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание `.this` после его имени. Например: `Outer.this`.

+ [Thema#4 Question#1.9  Go to OOPInJava](#Theme4___OOPInJava)

## Каким образом из вложенного класса получить доступ к полю внешнего класса?
Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса. 

Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземляр. Например: `Outer.this.field`.
+ [Thema#4 Question#1.10  Go to OOPInJava](#Theme4___OOPInJava)

## Что такое перечисления (enum)?
__Перечисления представляют набор логически связанных констант.__ 
+ Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.
+ Перечисления, как и обычные классы, могут определять конструкторы, поля и методы. Следует отметить, что конструктор по умолчанию приватный. Также можно определять методы для отдельных констант.

Методы:
+ `__ordinal()__` возвращает порядковый номер определенной константы (нумерация начинается с 0)
+ `__values()__` возвращает массив всех констант перечисления
`Еnum` имеет ряд преимуществ при использовании в сравнении с `static final int`. 
Главным отличием является то что используя `enum` вы можете проверить тип данных.

Недостатки:
+ К ним не применимы операторы >, <, >=, <=
+ `enum` также требует больше памяти для хранения чем обычная константа.

Нужны для ограничения области допустимых значений: например, времена года, дни недели
+ [Thema#4 Question#1.11  Go to OOPInJava](#Theme4___OOPInJava)

## Как проблема ромбовидного наследования решена в java?
__В Java нет поддержки множественного наследования классов.__
Предположим, что `SuperClass` — это абстрактный класс, описывающий некоторый метод, а классы `ClassA` и `ClassB` — обычные классы наследники `SuperClass`, а класс `ClassC` наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов. Интерфейсы – это только  резервирование/описание метода, а реализация самого метода будет в конкретном классе, реализующем эти интерфейсы, таким образом исключается неопределенность при множественном наследовании интерфейсов. В случае, если вызывается default-метод из интерфейса его обязательно надо будет переопределить.  
+ [Thema#4 Question#1.12  Go to OOPInJava](#Theme4___OOPInJava)

## Расскажите про классы-загрузчики и про динамическую загрузку классов.
При запуске JVM, используются три загрузчика классов:

1) __Bootstrap ClassLoader - главный загрузчик__ - загружает платформенные классы JDK из архива rt.jar
2) __AppClassLoader - системный загрузчик__ - загружает классы приложения, определенные в CLASSPATH 
3) __Extension ClassLoader - загрузчик расширений__ - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.

Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().
Основа работы с классами в Java — классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и создания объекта класса по его имени во время работы приложения.

В начале работы программы создается 3 основных загрузчика классов:

+ __базовый загрузчик (bootstrap/primordial)__. Загружает основные системные и внутренние классы JDK (_Core API_ - пакеты `java.*` (`rt.jar` и `i18n.jar`) . Важно заметить, что базовый загрузчик является _«Изначальным»_ или _«Корневым»_ и частью JVM, вследствие чего его нельзя создать внутри кода программы.
+ __загрузчик расширений (extention)__. Загружает различные пакеты расширений, которые располагаются в директории `<JAVA_HOME>/lib/ext` или другой директории, описанной в системном параметре `java.ext.dirs`. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений реализован классом `sun.misc.Launcher$ExtClassLoader`. 
+ __системный загрузчик (system/application)__. Загружает классы, пути к которым указаны в переменной окружения `CLASSPATH` или пути, которые указаны в командной строке запуска JVM после ключей `-classpath` или `-cp`. Системный загрузчик реализован классом `sun.misc.Launcher$AppClassLoader`.

Загрузчики классов являются иерархическими: каждый из них (кроме базового) имеет родительский загрузчик и в большинстве случаев, перед тем как попробовать загрузить класс самостоятельно, он посылает вначале запрос родительскому загрузчику загрузить указанный класс. Такое делегирование позволяет загружать классы тем загрузчиком, который находится ближе всего к базовому в иерархии делегирования. Как следствие поиск классов будет происходить в источниках в порядке их доверия: сначала в библиотеке _Core API_, потом в папке расширений, потом в локальных файлах `CLASSPATH`. 

Процесс загрузки класса состоит из трех частей:

+ _Loading_ – на этой фазе происходит поиск и физическая загрузка файла класса в определенном источнике (в зависимости от загрузчика). Этот процесс определяет базовое представление класса в памяти. На этом этапе такие понятия как «методы», «поля» и т.д. пока не известны.
+ _Linking_ – процесс, который может быть разбит на 3 части:
    + _Bytecode verification_ – проверка байт-кода на соответствие требованиям, определенным в спецификации JVM.
    + _Class preparation_ – создание и инициализация необходимых структур, используемых для представления полей, методов, реализованных интерфейсов и т.п., определенных в загружаемом классе.
    + _Resolving_ – загрузка набора классов, на которые ссылается загружаемый класс.
+ _Initialization_ – вызов статических блоков инициализации и присваивание полям класса значений по умолчанию.

Динамическая загрузка классов в Java имеет ряд особенностей:

+ _отложенная (lazy) загрузка и связывание классов_. Загрузка классов производится только при необходимости, что позволяет экономить ресурсы и распределять нагрузку.
+ _проверка корректности загружаемого кода (type safeness)_. Все действия связанные с контролем использования типов производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.
+ _программируемая загрузка_. Пользовательский загрузчик полностью контролирует процесс получения запрошенного класса — самому ли искать байт-код и создавать класс или делегировать создание другому загрузчику. Дополнительно существует возможность выставлять различные атрибуты безопасности для загружаемых классов, позволяя таким образом работать с кодом из ненадежных источников.
+ _множественные пространства имен_. Каждый загрузчик имеет своё пространство имён для создаваемых классов. Соответственно, классы, загруженные двумя различными загрузчиками на основе общего байт-кода, в системе будут различаться.

Существует несколько способов инициировать загрузку требуемого класса:

+ явный: вызов `ClassLoader.loadClass()` или `Class.forName()` (по умолчанию используется загрузчик, создавший текущий класс, но есть возможность и явного указания загрузчика);
+ неявный: когда для дальнейшей работы приложения требуется ранее не использованный класс, JVM инициирует его загрузку.

+ [Thema#4 Question#1.13  Go to OOPInJava](#Theme4___OOPInJava)

## Что такое _Reflection_?
__Рефлексия (Reflection)__ - это механизм получения данных о программе во время её выполнения (runtime). В Java _Reflection_ осуществляется с помощью _Java Reflection API_, состоящего из классов пакетов `java.lang` и `java.lang.reflect`.

Возможности `Java Reflection API`: 

+ Определение класса объекта;
+ Получение информации о модификаторах класса, полях, методах, конструкторах и суперклассах;
+ Определение интерфейсов, реализуемых классом;
+ Создание экземпляра класса;
+ Получение и установка значений полей объекта;
+ Вызов методов объекта;
+ Создание нового массива.

+ [Thema#4 Question#1.14  Go to OOPInJava](#Theme4___OOPInJava)



## 2-Interfaces

## Дайте определение понятию _«интерфейс»_. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
Ключевое слово `interface` используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как публичные `public`  и абстрактными `abstract`.

Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию `default` и статических `static` методов.

Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными `public`, статическими `static` и неизменяемыми `final`.

+ [Thema#4 Question#2.1  Go to OOPInJava](#Theme4___OOPInJava)

## Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?
1) В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
2) Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
3) Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как `public abstract` или (начиная с Java 8) `default` - методами с реализацией по-умолчанию, а поля - `public static final`.
4) Интерфейсы позволяют создавать структуры типов без иерархии.
5) Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.
+ [Thema#4 Question#2.2  Go to OOPInJava](#Theme4___OOPInJava)

## Почему в некоторых интерфейсах вообще не определяют методов?
Это так называемые _маркерные интерфейсы_. Они просто указывают что класс относится к определенному типу. Примером может послужить интерфейс `Clonable`, который указывает на то, что класс поддерживает механизм клонирования.
+ [Thema#4 Question#2.3  Go to OOPInJava](#Theme4___OOPInJava)

## Почему нельзя объявить метод интерфейса с модификатором `final`?
В случае интерфейсов указание модификатора `final` бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор `final`.
+ [Thema#4 Question#2.4  Go to OOPInJava](#Theme4___OOPInJava)

## Может ли один интерфейс наследоваться от другого? От двух других?
Да, может. Используется ключевое слово extends
+ [Thema#4 Question#2.5  Go to OOPInJava](#Theme4___OOPInJava)

## Что такое дефолтные методы интерфейсов? Для чего они нужны?
В JDK 8 была добавлена такая функциональность как методы по умолчанию с модификатором `default`. И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Это нужно для обратной совместимости. 
(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.) 
+ [Thema#4 Question#2.6  Go to OOPInJava](#Theme4___OOPInJava)

## Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?
__Обязательным переопределением default-метода__
В случае, если вызывается default-метод из интерфейса его обязательно надо будет переопределить.
+ [Thema#4 Question#2.7  Go to OOPInJava](#Theme4___OOPInJava)



## 3-Constructors and initialization

## Дайте определение понятию «конструктор».
__Конструктор__ — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для его инициализации.
+ [Thema#4 Question#3.1  Go to OOPInJava](#Theme4___OOPInJava)

## Что такое _«конструктор по умолчанию»_?
+ Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый __«конструктор по умолчанию»__.
```java
public class ClassName() {}
```
+ Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.
+ В классе-наследнике при отсутствии переопределенного конструктора будет использован конструктор родителя.

+ [Thema#4 Question#3.2  Go to OOPInJava](#Theme4___OOPInJava)

## Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?
+ У конструктора по умолчанию отсутствуют какие-либо аргументы. 
+ Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона. 
+ Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).

+ [Thema#4 Question#3.3  Go to OOPInJava](#Theme4___OOPInJava)

## Где и как вы можете использовать приватный конструктор?
Приватный (помеченный ключевым словом `private`, скрытый) конструктор может использоваться публичным статическим методом генерации объектов данного класса. Также доступ к нему разрешён вложенным классам и может использоваться для их нужд.
Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.
Нужен для реализации паттернов, например singleton.
+ [Thema#4 Question#3.4  Go to OOPInJava](#Theme4___OOPInJava)

## Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?
__Да. Необходимы для наследников.__

В абстрактном классе в Java можно объявить и определить конструкторы. Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, необходимые для настройки класса.
+ [Thema#4 Question#3.5  Go to OOPInJava](#Theme4___OOPInJava)

## Что значит слово “инициализация”?
Инициализация (от англ. initialization, инициирование) — создание, активация, подготовка к работе, определение параметров. Приведение программы или устройства в состояние готовности к использованию. С точки зрения Java – выделение памяти под объект, например при создании MyClass myClass = new MyClass(). Таким образом будет выделена память под объект myClass (он будет инициализирован). Без инициализации (new MyClass()) запись MyClass myClass; просто резервирует имя (объявляется переменная myClass типа MyClass).
+ [Thema#4 Question#3.6  Go to OOPInJava](#Theme4___OOPInJava)

## Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?
1) Статические блоки от первого до последнего предка
2) Попарно динамической блок инициализации и конструктор от первого до последнего предка
Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса. 

Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.

>Parent static block(s) → Child static block(s) → Grandchild static block(s)
>
> → Parent non-static block(s) → Parent constructor →
>
> → Child non-static block(s) → Child constructor →
>
> → Grandchild non-static block(s) → Grandchild constructor

Пример 1:

```java
public class MainClass {

    public static void main(String args[]) {
        System.out.println(TestClass.v);
        new TestClass().a();
    }

}
```

```java
public class TestClass {

    public static String v = "Some val";

    {
        System.out.println("!!! Non-static initializer");
    }

    static {
        System.out.println("!!! Static initializer");
    }

    public void a() {
        System.out.println("!!! a() called");
    }

}
```

Результат выполнения:

```
!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called
```

Пример 2:

```java
public class MainClass {

    public static void main(String args[]) {        
        new TestClass().a();
    }

}
```

```java
public class TestClass {

    public static String v = "Some val";

    {
        System.out.println("!!! Non-static initializer");
    }

    static {
        System.out.println("!!! Static initializer");
    }

    public void a() {
        System.out.println("!!! a() called");
    }

}
```

Результат выполнения:

```
!!! Static initializer
!!! Non-static initializer
!!! a() called
```
+ [Thema#4 Question#3.7  Go to OOPInJava](#Theme4___OOPInJava)

## Зачем нужны и какие бывают блоки инициализации?
Существуют статические и нестатические блоки инициализации.
Используююся для выполнения кода, который должен выполняться один раз при инициализации класса.
Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов. 

+ Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора. 
+ Несколько блоков инициализации выполняются в порядке следования в коде класса. 
+ Блок инициализации способен генерировать исключения, если их объявления перечислены в `throws` всех конструкторов класса.
+ Блок инициализации возможно создать и в анонимном классе.

+ [Thema#4 Question#3.8  Go to OOPInJava](#Theme4___OOPInJava)

## Где разрешена инициализация статических/нестатических полей?
+ Статические поля можно инициализировать при объявлении, в статическом или нестатическом блоке инициализации. 
+ Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициализации или в конструкторе.

+ [Thema#4 Question#3.9  Go to OOPInJava](#Theme4___OOPInJava)

## Что произойдет, если в блоке инициализации возникнет исключительная ситуация?
+ __Для нестатических блоков инициализации__, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции. 
+ __Для статического блока__ выбрасывание исключения в явном виде, приводит к ошибке компиляции.

+ [Thema#4 Question#3.10  Go to OOPInJava](#Theme4___OOPInJava)

## Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
Если возникшее исключение - наследник RuntimeException:
+ для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;
+ для нестатических будет проброшено исключение-источник.
+ Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.
+ Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.

+ [Thema#4 Question#3.11  Go to OOPInJava](#Theme4___OOPInJava)



## 4-Access Modifiers

## Какие существуют модификаторы доступа?
1) __private__ (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово `private`.
2) __default__, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное обозначение не требуется.
3) __protected__ (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово `protected`.
4) __public__ (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово `public`.

Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.

Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия _принципу подстановки Барбары Лисков_).

Класс может быть объявлен с модификатором `public` и `default`.
+ [Thema#4 Question#4.1  Go to OOPInJava](#Theme4___OOPInJava)

## О чем говорит ключевое слово `final`?
Модификатор `final` может применяться к переменным, параметрам методов, полям и методам класса или самим классам.

+ Класс не может иметь наследников;
+ Метод не может быть переопределен в классах наследниках;
+ Поле не может изменить свое значение после инициализации;
+ Параметры методов не могут изменять своё значение внутри метода;
+ Локальные переменные не могут быть изменены после присвоения им значения.

+ [Thema#4 Question#4.2  Go to OOPInJava](#Theme4___OOPInJava)

## Где и для чего используется модификатор `abstract`?
Класс помеченный модификатором `abstract` называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.

Метод помеченный ключевым словом `abstract` - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.

Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.
+ [Thema#4 Question#4.3  Go to OOPInJava](#Theme4___OOPInJava)

## Что означает модификатор `static`?
__Статическая переменная - это переменная, принадлежащая классу, а не объекту.__ 
А статический класс- это вложенный класс, который может обращаться только к статическим полям обертывающего его класса. 
Внутри `static` метода нельзя вызвать не статический метод по имени класса.
+ [Thema#4 Question#4.4  Go to OOPInJava](#Theme4___OOPInJava)

## Может ли объект получить доступ к члену класса объявленному как `private`? Если да, то каким образом?
+ Внутри класса доступ к приватной переменной открыт без ограничений;
+ Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;
+ Доступ к приватным переменным извне может быть организован через отличные от приватных методов, которые предоставлены разработчиком класса. Например: `getX()` и `setX()`.
+ Через механизм рефлексии (Reflection API):

```java
class Victim { 
    private int field = 42;
}
//...
Victim victim = new Victim(); 
Field field = Victim.class.getDeclaredField("field"); 
field.setAccessible(true); 
int fieldValue = (int) field.get(victim);
//...
```
+ [Thema#4 Question#4.5  Go to OOPInJava](#Theme4___OOPInJava)

## Для чего в Java используются статические блоки инициализации?
Статические блоки инициализация используются __для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов__, в момент, предшествующий созданию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса `Class`).
+ [Thema#4 Question#4.6  Go to OOPInJava](#Theme4___OOPInJava)

## Может ли статический метод быть переопределён или перегружен?
__Перегружен - ДА.__ Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается. 

__Переопределён - НЕТ.__ Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.

В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.
+ [Thema#4 Question#4.7  Go to OOPInJava](#Theme4___OOPInJava)

## Могут ли нестатические методы перегрузить статические?
__ДА. В итоге получится два разных метода.__ Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.
+ [Thema#4 Question#4.8  Go to OOPInJava](#Theme4___OOPInJava)

## Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
При переопределении метода __нельзя сузить модификатор доступа к методу__ (например, с `public` до `private`), но можно расширить.
__Изменить тип возвращаемого значения нельзя,__ но можно сузить возвращаемое значение, если они совместимы. Например, если метод возвращает объект класса, а переопределенный метод возвращает класс-наследник.
+ [Thema#4 Question#4.9  Go to OOPInJava](#Theme4___OOPInJava)

## Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции `throws`?
При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.

Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:

+ Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
+ При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить _overloading_ (перегрузка) метода.
+ Секцию `throws` метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения `RuntimeException`. Порядок следования таких элементов при переопределении значения не имеет.

+ [Thema#4 Question#4.10  Go to OOPInJava](#Theme4___OOPInJava)

## Как получить доступ к переопределенным методам родительского класса?
С помощью ключевого слова `super` мы можем обратиться к любому члену родительского класса - методу или полю, если они не определены с модификатором `private`.

```java
super.method();
```
+ [Thema#4 Question#4.11  Go to OOPInJava](#Theme4___OOPInJava)

## Можно ли объявить метод абстрактным и статическим одновременно?
Нет. В таком случае компилятор выдаст ошибку: _"Illegal combination of modifiers: ‘abstract’ and ‘static’"_. Модификатор `abstract` говорит, что метод будет реализован в другом классе, а `static` наоборот указывает, что этот метод будет доступен по имени класса.
+ [Thema#4 Question#4.12  Go to OOPInJava](#Theme4___OOPInJava)

## В чем разница между членом экземпляра класса и статическим членом класса?
Модификатор `static` говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. Поля, помеченные `static` инициализируются при инициализации класса. На методы, объявленные как `static`, накладывается ряд ограничений:

+ Они могут вызывать только другие статические методы.
+ Они должны осуществлять доступ только к статическим переменным.
+ Они не могут ссылаться на члены типа `this` или `super`.

В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. Вызов метода экземпляра возможен только после предварительного создания объекта класса.

Пример:
```java
public class MainClass {

	public static void main(String args[]) {
		System.out.println(TestClass.v);
		new TestClass().a();
		System.out.println(TestClass.v);
	}

}
```

```java
public class TestClass {

	public static String v = "Initial val";

	{
		System.out.println("!!! Non-static initializer");
		v = "Val from non-static";
	}

	static {
		System.out.println("!!! Static initializer");
		v = "Some val";
	}

	public void a() {
		System.out.println("!!! a() called");
	}

}
```

Результат:

```
!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called
Val from non-static

```
+ [Thema#4 Question#4.13  Go to OOPInJava](#Theme4___OOPInJava)

## Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?
__В сигнатуре(имя + параметры) менять ничего нельзя.__
+ Возможно расширение уровня доступа.
+ Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).
+ Секцию `throws` метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.

+ [Thema#4 Question#4.14  Go to OOPInJava](#Theme4___OOPInJava)

## Могут ли классы быть статическими?
Класс можно объявить статическим за исключением классов верхнего уровня.
Такие классы известны как «вложенные статические классы» (nested static class). 
+ [Thema#4 Question#4.15  Go to OOPInJava](#Theme4___OOPInJava)

## Что означает модификатор final? К чему он может быть применим?
+ Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. 
+ Следует также отметить, что к abstract-классам нельзя применить модификатор `final`, т.к. это взаимоисключающие понятия.
+ Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено
+ Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.
+ Т.к. массив – это объект, то `final` означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.

+ [Thema#4 Question#4.16  Go to OOPInJava](#Theme4___OOPInJava)

## К каким конструкциям Java применим модификатор `static`?
+ полям;
+ методам;
+ вложенным классам;
+ членам секции `import`.

+ [Thema#4 Question#4.17  Go to OOPInJava](#Theme4___OOPInJava)

## Чем отличаются `final`, `finally` и `finalize()`?
Модификатор `final`:

+ Класс не может иметь наследников;
+ Метод не может быть переопределен в классах наследниках;
+ Поле не может изменить свое значение после инициализации;
+ Локальные переменные не могут быть изменены после присвоения им значения;
+ Параметры методов не могут изменять своё значение внутри метода.

Оператор `finally` гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке `try-catch`.

Метод `finalize()` вызывается перед тем как сборщик мусора будет проводить удаление объекта.

Пример:
```java

public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		System.out.println("result of a.a() is " + a.a());
		a = null;
		System.gc(); // Принудительно зовём сборщик мусора
		a = new TestClass();
		System.out.println("result of a.a() is " + a.a());
		System.out.println("!!! done");
	}

}
```

```java
public class TestClass {

	public int a() {
		try {
			System.out.println("!!! a() called");
			throw new Exception("");
		} catch (Exception e) {
			System.out.println("!!! Exception in a()");
			return 2;
		} finally {
			System.out.println("!!! finally in a() ");
		}
	}

	@Override
	protected void finalize() throws Throwable {
		System.out.println("!!! finalize() called");
		super.finalize();
	}
}
```

Результат выполнения:

```
!!! a() called
!!! Exception in a()
!!! finally in a() 
result of a.a() is 2
!!! a() called
!!! Exception in a()
!!! finally in a() 
!!! finalize() called
result of a.a() is 2
!!! done
```
+ [Thema#4 Question#4.18  Go to OOPInJava](#Theme4___OOPInJava)


## 5-Class Object

## Что такое класс `Object`? Какие в нем есть методы?
Все классы являются наследниками суперкласса `Object`. Это не нужно указывать явно. В результате объект `Object` может ссылаться на объект любого другого класса.

Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения.

+ `public boolean equals(Object obj)` – служит для сравнения объектов по значению;
+ `int hashCode()` – возвращает hash код для объекта;
+ `String toString()` – возвращает строковое представление объекта;
+ `Class getClass()` – возвращает класс объекта во время выполнения;
+ `protected Object clone()` – создает и возвращает копию объекта;
+ `protected void finalize()` – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.

Для многопоточки: 
+ `void notify()` – возобновляет поток, ожидающий монитор;
+ `void notifyAll()` – возобновляет все потоки, ожидающие монитор;
+ `void wait()` – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;
+ `void wait(long timeout)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта;
+ `void wait(long timeout, int nanos)` – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого объекта; Нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.

+ [Thema#4 Question#5.1  Go to OOPInJava](#Theme4___OOPInJava)

## Расскажите про equals и hashcode
1) __Хеш-код__ — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.
2) __Equals__ - это метод, определенный в `Object`, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам. При сравнении по `equals()` идет сравнение по состояниям объектов. 

Свойства equals():
+ __Симметричность:__ Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)
+ __Рефлексивность:__ Для всех ненулевых ссылок, a.equals(a)
+ __Постоянство:__ повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.
+ __Транзитивность:__ Если a.equals(b) и b.equals(c), то тогда a.equals(c)
+ __Совместимость с hashCode():__ Два тождественно равных объекта должны иметь одно и то же значение `hashCode()`

При переопределении `equals()` обязательно нужно переопределить метод `hashCode()`. Равные объекты должны возвращать одинаковые хэш коды.
+ [Thema#4 Question#5.2  Go to OOPInJava](#Theme4___OOPInJava)

## Каким образом реализованы методы hashCode() и equals() в классе Object?
1) Реализация метода `Object.equals()` сводится к проверке на равенство двух ссылок:
```java
public boolean equals(Object obj) {
  return (this == obj);
}
```
2) Реализация метода `Object.hashCode()` описана как `native`, т.е. написана не на Java. Непереопределенный `hashCode` возвращает идентификационный хеш, основанный на состоянии потока, объединённого с `xorshift` (в OpenJDK8). А вообще, функция предлагает шесть методов на базе значения переменной `hashCode`.

2.1) Случайно сгенерированное число.
2.2) Функция адреса объекта в памяти.
2.3) Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).
2.4) Последовательность.
2.5) Адрес объекта в памяти, приведённый к целочисленному значению.
2.6) Состояние потока, объединённое с xorshift (https://en.wikipedia.org/wiki/Xorshift)
```java
public native int hashCode();
```
+ [Thema#4 Question#5.3  Go to OOPInJava](#Theme4___OOPInJava)

## Зачем нужен `equals()`. Чем он отличается от операции `==`?
Метод `equals()` - определяет отношение эквивалентности объектов.
+ При сравнении объектов с помощью `==` сравнение происходит лишь между ссылками. 
+ При сравнении по переопределённому разработчиком `equals()` - по внутреннему состоянию объектов.

+ [Thema#4 Question#5.4  Go to OOPInJava](#Theme4___OOPInJava)

## Правила переопределения метода `Object.equals()`.
1) Проверить на равенство ссылки объектов `this` и параметра метода o.
```java
if (this == o) return true;
```
2) Проверить, определена ли ссылка o, т. е. является ли она `null`.
Если в дальнейшем при сравнении типов объектов будет использоваться оператор `instanceof`, этот пункт можно пропустить, т. к. этот параметр возвращает `false` в данном случае `null instanceof Object`.
3) Сравнить типы объектов `this` и o с помощью оператора `instanceof` или метода `getClass()`, руководствуясь описанием выше и собственным чутьем.
4) Если метод `equals` переопределяется в подклассе, не забудьте сделать вызов `super.equals(o)`
5) Выполнить преобразование типа параметра o к требуемому классу.
6) Выполнить сравнение всех значимых полей объектов:
+ для примитивных типов (кроме `float` и `double`), используя оператор ==
+ для ссылочных полей необходимо вызвать их метод `equals`
+ для массивов можно воспользоваться перебором по циклу, либо методом `Arrays.equals()`
+ для типов `float` и `double` необходимо использовать методы сравнения соответствующих оберточных классов `Float.compare()` и `Double.compare()`

+ [Thema#4 Question#5.5  Go to OOPInJava](#Theme4___OOPInJava)

## Что будет, если переопределить `equals()` не переопределяя `hashCode()`? Какие могут возникнуть проблемы?
Классы и методы, которые используют правила этого контракта могут работать некорректно. Так для `HashMap` это может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.
+ [Thema#4 Question#5.6  Go to OOPInJava](#Theme4___OOPInJava)

## Для чего нужен метод `hashCode()`?
Метод `hashCode()` необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число, в более широком смыле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java множество возможных хэш кодов ограничено типом `int`, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:

+ если хэш коды разные, то и объекты гарантированно разные;
+ если хэш коды равны, то объекты не обязательно равны.

+ [Thema#4 Question#5.7  Go to OOPInJava](#Theme4___OOPInJava)

## Какой контракт между hashCode() и equals()?
1) Если два объекта возвращают разные значения `hashcode()`, то они не могут быть равны
2) Если `equals` объектов true, то и хэшкоды должны быть равны.  
3) Переопределив `equals`, всегда нужно переопределять и `hashcode`.
+ [Thema#4 Question#5.8  Go to OOPInJava](#Theme4___OOPInJava)

## Правила переопределения метода hashcode().
1) Если хеш-коды разные, то и входные объекты гарантированно разные.
2) Если хеш-коды равны, то входные объекты не всегда равны.
3) При вычислении хэш-кода следует использовать те же поля, которые сравниваются в `equals` и которые не вычисляются на основе других значений.
+ [Thema#4 Question#5.9  Go to OOPInJava](#Theme4___OOPInJava)

## Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете `hashCode()`?
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например, такие как `id`, `uuid`. При этом нужно следовать правилу, если поля задействованы при вычислении `hashCode()`, то они должны быть задействованы и при выполнении `equals()`.
+ [Thema#4 Question#5.10  Go to OOPInJava](#Theme4___OOPInJava)

## Могут ли у разных объектов быть одинаковые `hashCode()`?
Да, могут. Метод `hashCode()` не гарантирует уникальность возвращаемого значения. Ситуация, когда у разных объектов одинаковые хэш коды называется __коллизией__. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш кода.
+ [Thema#4 Question#5.11  Go to OOPInJava](#Theme4___OOPInJava)

## Есть класс `Point{int x, y;}`. Почему хэш код в виде `31 * x + y` предпочтительнее чем `x + y`?
Множитель создает зависимость значения хэш кода от очередности обработки полей, что в итоге порождает лучшую хэш функцию.
+ [Thema#4 Question#5.12  Go to OOPInJava](#Theme4___OOPInJava)

## Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?
В Java множество возможных хэш кодов ограничено типом `int`, а множество объектов ничем не ограничено.
Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть
+ [Thema#4 Question#5.13  Go to OOPInJava](#Theme4___OOPInJava)

## Чем a.getClass().equals(A.class) отличается от a instanceOf A.class
+ `getClass()` получает только класс
+ оператор `instanceof` проверяет является ли объект экземпляром класса или его потомком
+ [Thema#4 Question#5.14  Go to OOPInJava](#Theme4___OOPInJava)

## Если у класса `Point{int x, y;}` реализовать метод `equals(Object that) {(return this.x == that.x && this.y == that.y)}`, но сделать хэш код в виде `int hashCode() {return x;}`, то будут ли корректно такие точки помещаться и извлекаться из `HashSet`?
`HashSet` использует `HashMap` для хранения элементов. При добавлении элемента в `HashMap` вычисляется хэш код, по которому определяется позиция в массиве, куда будет вставлен новый элемент. У всех экземпляров класса `Point` хэш код будет одинаковым для всех объектов с одинаковым `x`, что приведёт к вырождению хэш таблицы в список. 

При возникновении коллизии в `HashMap` осуществляется проверка на наличие элемента в списке: `e.hash == hash && ((k = e.key) == key || key.equals(k))`. Если элемент найден, то его значение перезаписывается. В нашем случае для разных объектов метод `equals()` будет возвращать `false`. Соответственно новый элемент будет успешно добавлен в `HashSet`. Извлечение элемента также будет осуществляться успешно. Но производительность такого кода будет невысокой и преимущества хэш таблиц использоваться не будут.
+ [Thema#4 Question#5.15  Go to OOPInJava](#Theme4___OOPInJava)

## Могут ли у разных объектов `(ref0 != ref1)` быть `ref0.equals(ref1) == true`?
Да, могут. Для этого в классе этих объектов должен быть переопределен метод `equals()`.

Если используется метод `Object.equals()`, то для двух ссылок `x` и `y` метод вернет `true` тогда и только тогда, когда обе ссылки указывают на один и тот же объект (т.е. `x == y` возвращает `true`).
+ [Thema#4 Question#5.16  Go to OOPInJava](#Theme4___OOPInJava)

## Могут ли у разных ссылок на один объект `(ref0 == ref1)` быть `ref0.equals(ref1) == false`?
В общем случае - могут, если метод `equals()` реализован некорректно и не выполняет свойство рефлексивности: для любых ненулевых ссылок `x` метод `x.equals(x)` должен возвращать `true`.
+ [Thema#4 Question#5.17  Go to OOPInJava](#Theme4___OOPInJava)

## Можно ли так реализовать метод `equals(Object that) {return this.hashCode() == that.hashCode()}`?
Строго говоря нельзя, поскольку метод `hashCode()` не гарантирует уникальность значения для каждого объекта. Однако для сравнения экземпляров класса `Object` такой код допустим, т.к. метод `hashCode()` в классе `Object` возвращает уникальные значения для разных объектов (его вычисление основано на использовании адреса объекта в памяти).
+ [Thema#4 Question#5.18  Go to OOPInJava](#Theme4___OOPInJava)

## В `equals()` требуется проверять, что аргумент `equals(Object that)` такого же типа что и сам объект. В чем разница между `this.getClass() == that.getClass()` и `that instanceof MyClass`?
Оператор `instanceof` сравнивает объект и указанный тип. Его можно использовать для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.

`this.getClass() == that.getClass()` проверяет два класса на идентичность, поэтому для корректной реализации контракта метода `equals()` необходимо использовать точное сравнение с помощью метода `getClass()`.
+ [Thema#4 Question#5.19  Go to OOPInJava](#Theme4___OOPInJava)

## Можно ли реализовать метод `equals()` класса `MyClass` вот так: `class MyClass {public boolean equals(MyClass that) {return this == that;}}`?
Реализовать можно, но данный метод не переопределяет метод `equals()` класса `Object`, а перегружает его.
+ [Thema#4 Question#5.20  Go to OOPInJava](#Theme4___OOPInJava)

## Что такое `finalize()`? Зачем он нужен?
Через вызов метода `finalize()` (который наследуется от Java.lang.Object) JVM реализуется функциональность аналогичная функциональности деструкторов в С++, используемых для очистки памяти перед возвращением управления операционной системе. Данный метод вызывается при уничтожении объекта сборщиком мусора (_garbage collector_) и переопределяя `finalize()` можно запрограммировать действия необходимые для корректного удаления экземпляра класса - например, закрытие сетевых соединений, соединений с базой данных, снятие блокировок на файлы и т.д. 

После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это считается серьезной проблемой метода `finalize()` т.к. он мешает сборщику мусора освобождать память). Вызов этого метода не гарантируется, т.к. приложение может быть завершено до того, как будет запущена сборка мусора.

Объект не обязательно будет доступен для сборки сразу же - метод `finalize()` может сохранить куда-нибудь ссылку на объект. Подобная ситуация называется «возрождением» объекта и считается антипаттерном. Главная проблема такого трюка - в том, что «возродить» объект можно только 1 раз.

Пример:
```java
public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		a.a();
		a = null;
		a = new TestClass();
		a.a();
		System.out.println("!!! done");
	}
}
```
```java

public class TestClass {

	public void a() {
		System.out.println("!!! a() called");
	}

	@Override
	protected void finalize() throws Throwable {
		System.out.println("!!! finalize() called");
		super.finalize();
	}
}
```
Так как в данном случае сборщик мусора может и не быть вызван (в силу простоты приложения), то результат выполнения программы с большой вероятностью будет следующий:
```
!!! a() called
!!! a() called
!!! done
```
Теперь несколько усложним программу, добавив принудительный вызов Garbage Collector:
```java
public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		a.a();
		a = null;
		System.gc(); // Принудительно зовём сборщик мусора
		a = new TestClass();
		a.a();
		System.out.println("!!! done");
	}

}
```
Как и было сказано ранее, Garbage Collector может в разное время отработать, поэтому результат выполнения может разниться от запуска к запуску:
Вариант а:
```
!!! a() called
!!! a() called
!!! done
!!! finalize() called
```
Вариант б:
```
!!! a() called
!!! a() called
!!! finalize() called
!!! done
```
+ [Thema#4 Question#5.21  Go to OOPInJava](#Theme4___OOPInJava)


## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ

+ [История эволюции интерфейсов в Java (2019)-->]( https://habr.com/ru/post/482498/ )
+ [Как сгенерировать hashCode в Java-->]( http://www.seostella.com/ru/article/2012/10/04/kak-sgenerirovat-hashcode-v-java.html )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )

	
	
__Theme5 - FunctionalInterface_______________________________________________________________________________________________________

## Что такое функциональный интерфейс и аннотация @FunctionalInterface?
__Функциональный интерфейс__ - это интерфейс, который определяет только один абстрактный метод. 

Чтобы точно определить интерфейс как функциональный, добавлена аннотация `@FunctionalInterface`, работающая по принципу `@Override`. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.

Интерфейс может включать сколько угодно `default` методов и при этом оставаться функциональным, потому что `default` методы - не абстрактные.
+ [Thema#5 Question#1  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Что такое `default` методы интрефейса?
Java 8 позволяет добавлять неабстрактные реализации методов в интерфейс, используя ключевое слово `default`:

```java
interface Example {
    int process(int a);
    default void show() {
        System.out.println("default show()");
    }
}
```
+ Если класс реализует интерфейс, он может, но не обязан, реализовать методы по-умолчанию, уже реализованные в интерфейсе. Класс наследует реализацию по умолчанию.
+ Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно. Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод является абстрактным - никакой реализации по умолчанию классом не наследуется.
+ Метод по умолчанию не может переопределить метод класса `java.lang.Object`.
+ Помогают реализовывать интерфейсы без страха нарушить работу других классов.
+ Позволяют избежать создания служебных классов, так как все необходимые методы могут быть представлены в самих интерфейсах.
+ Дают свободу классам выбрать метод, который нужно переопределить.
+ Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8 использовать лямбда-выражения.
+ Переменные интерфейса являются public static final по умолчанию и эти модификаторы необязательны при их объявлении.

+ [Thema#5 Question#2  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Как вызывать `default` метод интерфейса в реализующем этот интерфейс классе?
Используя ключевое слово `super` вместе с именем интерфейса:
```java
interface Paper {
    default void show() {
        System.out.println("default show()");
    }
}

class Licence implements Paper {
    public void show() {
        Paper.super.show();
    }
}
```
+ [Thema#5 Question#3  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Что такое `static` метод интерфейса?
Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что для них отсутствует возможность переопределения в классах, реализующих интерфейс.

+ Статические методы в интерфейсе являются частью интерфейса без возможности использовать их для объектов класса реализации;
+ Методы класса `java.lang.Object` нельзя переопределить как статические;
+ Статические методы в интерфейсе используются для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д.

+ [Thema#5 Question#4  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Как вызывать `static` метод интерфейса?
Используя имя интерфейса:
```java
interface Paper {
    static void show() {
        System.out.println("static show()");
    }
}

class Licence {
    public void showPaper() {
        Paper.show();
    }
}
```
+ [Thema#5 Question#5  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Зачем нужны `default` методы в функциональном интерфейсе?
Тут про обратную совместимость.  Вот почему не обязательно модифицировать классы при изменении интерфейса, который они реализуют.
+ [Thema#5 Question#6  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Какие есть способы инстацировать функциональные интерфейсы?
+ Ссылка на метод.(Ссылка на метод - это сокращенный синтаксис выражения лямбда, который выполняет только один метод.)
+ Лямбда-выражение. 
+ Через анонимный класс. 
+ Через обычную имплементацию в классе. 

+ [Thema#5 Question#7  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Сколько дефолтных методов и статических методов, статических полей в интерфейсе?
Любое количество методов по умолчанию (default) или статических методов.
+ [Thema#5 Question#8  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Где находятся функциональные интерфейсы?
+ _`java.util.function`_

Куда же применить все эти лямбды и ссылки на методы, счастье было бы не полным, если каждому программисту теперь пришлось бы писать библиотечку вспомогательных классов и работающих. Вы можете писать код со своими функциональными интерфейсами, но в стандартную библиотеку, был добавлен механизм `STREAM API`.
+ [Thema#5 Question#9  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Что такое ссылка на метод?
+ Ссылка на статический метод - `ContainingClass::staticMethodName`
+ Ссылка на нестатический метод конкретного объекта - `containingObject::instanceMethodName`
+ Ссылка на конструктор - `ClassName::new`
+ Ссылка на метод - это сокращенный синтаксис выражения лямбда, который выполняет только один метод. Это позволяет нам ссылаться на конструкторы или методы, не выполняя их.

+ [Thema#5 Question#10  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Что такое лямбда-выражение? Чем его можно заменить?
Лямбда-выражение - упрощённая запись анонимного класса, реализующего функциональный интерфейс
+ [Thema#5 Question#11  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Базовые функциональные интерфейсы Java 8?
1) __Predicate<T>__ - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean
2) __Consumer<T>__ (с англ. — “потребитель”) - реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает
3) __Function<T,R>__ - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R
4) __Supplier<T>__ (с англ. — поставщик)- реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T
5) __UnaryOperator<T>__ - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T
6) __BinaryOperator<T, Т>__ - реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T

+ [Thema#5 Question#12  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы `Function<T,R>`, `DoubleFunction<R>`, `IntFunction<R>` и `LongFunction<R>`?
__`Function<T, R>`__ - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса `T` и возвращающая на выходе экземпляр класса `R`.

Методы по умолчанию могут использоваться для построения цепочек вызовов (`compose`, `andThen`).

```java
Function<String, Integer> toInteger = Integer::valueOf;
Function<String, String> backToString = toInteger.andThen(String::valueOf);
backToString.apply("123");     // "123"
```

+ `DoubleFunction<R>` - функция, получающая на вход `Double` и возвращающая на выходе экземпляр класса `R`;
+ `IntFunction<R>` - функция, получающая на вход `Integer` и возвращающая на выходе экземпляр класса `R`;
+ `LongFunction<R>` - функция, получающая на вход `Long` и возвращающая на выходе экземпляр класса `R`.

+ [Thema#5 Question#13  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы `UnaryOperator<T>`, `DoubleUnaryOperator`, `IntUnaryOperator` и `LongUnaryOperator`?
__`UnaryOperator<T>` (унарный оператор)__ принимает в качестве параметра объект типа `T`, выполняет над ними операции и возвращает результат операций в виде объекта типа `T`:

```java
UnaryOperator<Integer> operator = x -> x * x;
System.out.println(operator.apply(5)); // 25
```

+ `DoubleUnaryOperator` - унарный оператор, получающий на вход `Double`;
+ `IntUnaryOperator` - унарный оператор, получающий на вход `Integer`;
+ `LongUnaryOperator` - унарный оператор, получающий на вход `Long`.

+ [Thema#5 Question#14  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы `BinaryOperator<T>`, `DoubleBinaryOperator`, `IntBinaryOperator` и `LongBinaryOperator`?
__`BinaryOperator<T>` (бинарный оператор)__ - интерфейс, с помощью которого реализуется функция, получающая на вход два экземпляра класса `T` и возвращающая на выходе экземпляр класса `T`.
```java
BinaryOperator<Integer> operator = (a, b) -> a + b;
System.out.println(operator.apply(1, 2)); // 3
```

+ `DoubleBinaryOperator` - бинарный оператор, получающий на вход `Double`;
+ `IntBinaryOperator` - бинарный оператор, получающий на вход `Integer`;
+ `LongBinaryOperator` - бинарный оператор, получающий на вход `Long`.

+ [Thema#5 Question#15  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы `Predicate<T>`, `DoublePredicate`, `IntPredicate` и `LongPredicate`?
__`Predicate<T>` (предикат)__ - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса `T` и возвращающая на выходе значение типа `boolean`. 

Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (`and`, `or`, `negate`).

```java
Predicate<String> predicate = (s) -> s.length() > 0;
predicate.test("foo"); // true
predicate.negate().test("foo"); // false
```

+ `DoublePredicate` - предикат, получающий на вход `Double`;
+ `IntPredicate` - предикат, получающий на вход `Integer`;
+ `LongPredicate` - предикат, получающий на вход `Long`.

+ [Thema#5 Question#16  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы `Consumer<T>`, `DoubleConsumer`, `IntConsumer` и `LongConsumer`?
__`Consumer<T>` (потребитель)__ - интерфейс, с помощью которого реализуется функция, которая получает на вход экземпляр класса `T`, производит с ним некоторое действие и ничего не возвращает.

```java
Consumer<String> hello = (name) -> System.out.println("Hello, " + name);
hello.accept("world");
```

+ `DoubleConsumer` - потребитель, получающий на вход `Double`;
+ `IntConsumer` - потребитель, получающий на вход `Integer`;
+ `LongConsumer` - потребитель, получающий на вход `Long`.

+ [Thema#5 Question#17  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы `Supplier<T>`,  `BooleanSupplier`, `DoubleSupplier`, `IntSupplier` и `LongSupplier`?
__`Supplier<T>` (поставщик)__ - интерфейс, с помощью которого реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса `T`;

```java
Supplier<LocalDateTime> now = LocalDateTime::now;
now.get();
```

+ `DoubleSupplier` - поставщик, возвращающий `Double`;
+ `IntSupplier` - поставщик, возвращающий `Integer`;
+ `LongSupplier` - поставщик, возвращающий `Long`.

+ [Thema#5 Question#18  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужен функциональный интерфейс `BiConsumer<T,U>`?
__`BiConsumer<T,U>`__ представляет собой операцию, которая принимает два аргумента классов `T` и `U` производит с ними некоторое действие и ничего не возвращает.
+ [Thema#5 Question#19  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужен функциональный интерфейс `BiFunction<T,U,R>`?
__`BiFunction<T,U,R>`__ представляет собой операцию, которая принимает два аргумента классов `T` и `U` и возвращающая результат класса `R`.
+ [Thema#5 Question#20  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужен функциональный интерфейс `BiPredicate<T,U>`?
__`BiPredicate<T,U>`__ представляет собой операцию, которая принимает два аргумента классов `T` и `U` и возвращающая результат типа `boolean`. 
+ [Thema#5 Question#21  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы вида `_To_Function`?
+ `DoubleToIntFunction` - операция принимающая аргумент класса `Double` и возвращающая результат типа `Integer`;
+ `DoubleToLongFunction` - операция принимающая аргумент класса `Double` и возвращающая результат типа `Long`;
+ `IntToDoubleFunction` - операция принимающая аргумент класса `Integer` и возвращающая результат типа `Double`; 
+ `IntToLongFunction` - операция принимающая аргумент класса `Integer` и возвращающая результат типа `Long`;
+ `LongToDoubleFunction` - операция принимающая аргумент класса `Long` и возвращающая результат типа `Double`;
+ `LongToIntFunction` - операция принимающая аргумент класса `Long` и возвращающая результат типа `Integer`.

+ [Thema#5 Question#22  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы `ToDoubleBiFunction<T,U>`, `ToIntBiFunction<T,U>` и `ToLongBiFunction<T,U>`?
+ `ToDoubleBiFunction<T,U>` - операция принимающая два аргумента классов `T` и `U` и возвращающая результат типа `Double`;
+ `ToLongBiFunction<T,U>` - операция принимающая два аргумента классов `T` и `U` и возвращающая результат типа `Long`;
+ `ToIntBiFunction<T,U>`  - операция принимающая два аргумента классов `T` и `U` и возвращающая результат типа `Integer`.

+ [Thema#5 Question#23  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы `ToDoubleFunction<T>`, `ToIntFunction<T>` и `ToLongFunction<T>`?
+ `ToDoubleFunction<T>` - операция принимающая аргумент класса `T` и возвращающая результат типа `Double`;
+ `ToLongFunction<T>` - операция принимающая аргумент класса `T` и возвращающая результат типа `Long`;
+ `ToIntFunction<T>` - операция принимающая аргумент класса `T` и возвращающая результат типа `Integer`.

+ [Thema#5 Question#24  Go to FunctionalInterface](#Theme5___FunctionalInterface)

## Для чего нужны функциональные интерфейсы `ObjDoubleConsumer<T>`, `ObjIntConsumer<T>` и `ObjLongConsumer<T>`?
+ `ObjDoubleConsumer<T>` - операция, которая принимает два аргумента классов `T` и `Double`, производит с ними некоторое действие и ничего не возвращает;
+ `ObjLongConsumer<T>` - операция, которая принимает два аргумента классов `T` и `Long`, производит с ними некоторое действие и ничего не возвращает;
+ `ObjIntConsumer<T>` - операция, которая принимает два аргумента классов `T` и `Integer`, производит с ними некоторое действие и ничего не возвращает.

+ [Thema#5 Question#25  Go to FunctionalInterface](#Theme5___FunctionalInterface)



## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
+ [Java 8 Predicate Examples-->]( https://mkyong.com/java8/java-8-predicate-examples/ )
+ [Функциональные интерфейсы в Java-->]( https://javarush.ru/groups/posts/2866-funkcionaljhnihe-interfeysih-v-java )
+ [Функциональный интерфейс-->]( https://www.examclouds.com/ru/java/java-core-russian/functional-interface-russian )
+ [Название-->]( Ссылка )


	
__Theme6 - ChangesInJava8_______________________________________________________________________________________________________	
	
## Какие нововведения появились в java 8?
1) Полноценная поддержка лямбда-вражений
2) Ссылки на методы ::
3) Функциональные интерфейсы 
4) default методы в интефейсах 
5) Потоки для работы с коллекциями
6) Новое api для работы с датами 
7) Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle.
8) Кодировщик/декодировщик.
9) Новые методы для Map - `PutIfAbsent()`, `СomputeIfAbsent()\СomputeIfPresent()`, `Remove()`, `GetOrDefault()`, `Merge()`
10) Metaspace заменил PermGen
+ [Thema#6 Question#1  Go to ChangesInJava8](#Theme6___ChangesInJava8)

## Какие новые классы для работы с датами появились в java 8?
+ LocalDate , 
+ LocalTime, 
+ LocalDateTime, 
+ ZonedDateTime, 
+ Period, 
+ Duration

+ [Thema#6 Question#2  Go to ChangesInJava8](#Theme6___ChangesInJava8)

## Расскажите про класс Optional
__Optional__ - новый класс в пакете `java.util`, является контейнером (оберткой) для значений которая также может безопасно содержать `null`. Благодаря опциональным типам можно забыть про проверки на `null` и `NullPointerException`.
+ [Thema#6 Question#3  Go to ChangesInJava8](#Theme6___ChangesInJava8)

## Что такое Nashorn?
В Java 8, `Nashorn`, представлен значительно улучшенный движок `javascript` для замены существующего `Rhino`. `Nashorn` обеспечивает в 2-10 раз лучшую производительность, так как он напрямую компилирует код в памяти и передает байт-код в JVM. `Nashorn` использует функцию динамического вызова, представленную в Java 7, для повышения производительности.
* Nashorn — немецкое слово (насхорн)
+ [Thema#6 Question#4  Go to ChangesInJava8](#Theme6___ChangesInJava8)

## Что такое jjs?
Инструмент командной строки для выполнения `JavaScript-кодов` на консоли.
+ [Thema#6 Question#5  Go to ChangesInJava8](#Theme6___ChangesInJava8)

## Какой класс появился в Java 8 для кодирования/декодирования данных?
+ __public static class Base64.Encoder__ 
+ __public static class Base64.Decoder__

+ [Thema#6 Question#6  Go to ChangesInJava8](#Theme6___ChangesInJava8)

## Как создать Base64 кодировщик и декодировщик?
Используя метод `getDecoder()` класса Base64 он возвращает декодировщик `Base64.Decoder`, который декодирует данные с помощью схемы кодирования base64.
+ [Thema#6 Question#7  Go to ChangesInJava8](#Theme6___ChangesInJava8)

## Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?
+ __putIfAbsent()__ - добавляет пару «ключ-значение», только если ключ отсутствовал:
 map.putIfAbsent("a", "Aa");
+ __forEach()__ - принимает функцию, которая производит операцию над каждым элементом:
 map.forEach((k, v) -> System.out.println(v));
+ __compute()__ - создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):
 map.compute("a", (k, v) -> String.valueOf(k).concat(v)); //["a", "aAa"]
+ __computeIfPresent()__ - если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):
 map.computeIfPresent("a", (k, v) -> k.concat(v));
+ __computeIfAbsent()__ если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ):
 map.computeIfAbsent("a", k -> "A".concat(k)); //["a","Aa"]
+ __getOrDefault()__ в случае отсутствия ключа, возвращает переданное значение по-умолчанию:
 map.getOrDefault("a", "not found");
+ __merge()__ принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключем значение отсутствует, то записывает туда передаваемое значение.

+ [Thema#6 Question#8  Go to ChangesInJava8](#Theme6___ChangesInJava8)

## Что такое LocalDateTime?
__LocalDateTime__ объединяет вместе `LocaleDate` и `LocalTime`, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как `plusMinutes()`, `plusHours()`, `isAfter()`, `toSecondOfDay()` и т.д.
+ [Thema#6 Question#9  Go to ChangesInJava8](#Theme6___ChangesInJava8)

## Что такое ZonedDateTime?
__java.time.ZonedDateTime__ — аналог `java.util.Calendar`, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает объект `ZoneId` - временную зону(в ZoneId 599 зон), поэтому все операции с временными сдвигами этот класс проводит с её учётом.
+ [Thema#6 Question#10  Go to ChangesInJava8](#Theme6___ChangesInJava8)

