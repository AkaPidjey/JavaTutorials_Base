[Java Tutorials](README.md)

# Функциональные интерфейсы
1) [Что такое функциональный интерфейс и аннотация @FunctionalInterface?](#Что-такое-функциональный-интерфейс-и-аннотация-FunctionalInterface)
2) [Что такое `default` методы интрефейса?](#Что-такое-default-методы-интрефейса)
3) [Как вызывать `default` метод интерфейса в реализующем этот интерфейс классе?](#Как-вызывать-default-метод-интерфейса-в-реализующем-этот-интерфейс-классе)
4) [Что такое `static` метод интерфейса?](#Что-такое-static-метод-интерфейса)
5) [Как вызывать `static` метод интерфейса?](#Как-вызывать-static-метод-интерфейса)
6) [Зачем нужны `default` методы в функциональном интерфейсе?](#Зачем-нужны-default-методы-в-функциональном-интерфейсе)
7) [Какие есть способы инстацировать функциональные интерфейсы?](#Какие-есть-способы-инстацировать-функциональные-интерфейсы)
8) [Сколько дефолтных методов и статических методов, статических полей в интерфейсе?](#Сколько-дефолтных-методов-и-статических-методов-статических-полей-в-интерфейсе)
9) [Где находятся функциональные интерфейсы?](#Где-находятся-функциональные-интерфейсы)
10) [Что такое ссылка на метод?](#Что-такое-ссылка-на-метод)
11) [Что такое лямбда-выражение? Чем его можно заменить?](#Что-такое-лямбда-выражение-Чем-его-можно-заменить)
12) [Базовые функциональные интерфейсы Java 8?](#Базовые-функциональные-интерфейсы-Java-8)
13) [Для чего нужны функциональные интерфейсы `Function<T,R>`, `DoubleFunction<R>`, `IntFunction<R>` и `LongFunction<R>`?](#Для-чего-нужны-функциональные-интерфейсы-functiontr-doublefunctionr-intfunctionr-и-longfunctionr)
14) [Для чего нужны функциональные интерфейсы `UnaryOperator<T>`, `DoubleUnaryOperator`, `IntUnaryOperator` и `LongUnaryOperator`?](#Для-чего-нужны-функциональные-интерфейсы-unaryoperatort-doubleunaryoperator-intunaryoperator-и-longunaryoperator)
15) [Для чего нужны функциональные интерфейсы `BinaryOperator<T>`, `DoubleBinaryOperator`, `IntBinaryOperator` и `LongBinaryOperator`?](#Для-чего-нужны-функциональные-интерфейсы-binaryoperatort-doublebinaryoperator-intbinaryoperator-и-longbinaryoperator)
16) [Для чего нужны функциональные интерфейсы `Predicate<T>`, `DoublePredicate`, `IntPredicate` и `LongPredicate`?](#Для-чего-нужны-функциональные-интерфейсы-predicatet-doublepredicate-intpredicate-и-longpredicate)
17) [Для чего нужны функциональные интерфейсы `Consumer<T>`, `DoubleConsumer`, `IntConsumer` и `LongConsumer`?](#Для-чего-нужны-функциональные-интерфейсы-consumert-doubleconsumer-intconsumer-и-longconsumer)
18) [Для чего нужны функциональные интерфейсы `Supplier<T>`,  `BooleanSupplier`, `DoubleSupplier`, `IntSupplier` и `LongSupplier`?](#Для-чего-нужны-функциональные-интерфейсы-suppliert--booleansupplier-doublesupplier-intsupplier-и-longsupplier)
19) [Для чего нужен функциональный интерфейс `BiConsumer<T,U>`?](#Для-чего-нужен-функциональный-интерфейс-biconsumertu)
20) [Для чего нужен функциональный интерфейс `BiFunction<T,U,R>`?](#Для-чего-нужен-функциональный-интерфейс-bifunctiontur)
21) [Для чего нужен функциональный интерфейс `BiPredicate<T,U>`?](#Для-чего-нужен-функциональный-интерфейс-bipredicatetu)
22) [Для чего нужны функциональные интерфейсы вида `_To_Function`?](#Для-чего-нужны-функциональные-интерфейсы-вида-tofunction)
23) [Для чего нужны функциональные интерфейсы `ToDoubleBiFunction<T,U>`, `ToIntBiFunction<T,U>` и `ToLongBiFunction<T,U>`?](#Для-чего-нужны-функциональные-интерфейсы-todoublebifunctiontu-tointbifunctiontu-и-tolongbifunctiontu)
24) [Для чего нужны функциональные интерфейсы `ToDoubleFunction<T>`, `ToIntFunction<T>` и `ToLongFunction<T>`?](#Для-чего-нужны-функциональные-интерфейсы-todoublefunctiont-tointfunctiont-и-tolongfunctiont)
25) [Для чего нужны функциональные интерфейсы `ObjDoubleConsumer<T>`, `ObjIntConsumer<T>` и `ObjLongConsumer<T>`?](#Для-чего-нужны-функциональные-интерфейсы-objdoubleconsumert-objintconsumert-и-objlongconsumert)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)
+ [к оглавлению](#Функциональные-интерфейсы)

## Что такое функциональный интерфейс и аннотация @FunctionalInterface?
__Функциональный интерфейс__ - это интерфейс, который определяет только один абстрактный метод. 

Чтобы точно определить интерфейс как функциональный, добавлена аннотация `@FunctionalInterface`, работающая по принципу `@Override`. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.

Интерфейс может включать сколько угодно `default` методов и при этом оставаться функциональным, потому что `default` методы - не абстрактные.
+ [Вопрос#1  К оглавлению](#Функциональные-интерфейсы)

## Что такое `default` методы интрефейса?
Java 8 позволяет добавлять неабстрактные реализации методов в интерфейс, используя ключевое слово `default`:

```java
interface Example {
    int process(int a);
    default void show() {
        System.out.println("default show()");
    }
}
```
+ Если класс реализует интерфейс, он может, но не обязан, реализовать методы по-умолчанию, уже реализованные в интерфейсе. Класс наследует реализацию по умолчанию.
+ Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно. Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод является абстрактным - никакой реализации по умолчанию классом не наследуется.
+ Метод по умолчанию не может переопределить метод класса `java.lang.Object`.
+ Помогают реализовывать интерфейсы без страха нарушить работу других классов.
+ Позволяют избежать создания служебных классов, так как все необходимые методы могут быть представлены в самих интерфейсах.
+ Дают свободу классам выбрать метод, который нужно переопределить.
+ Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8 использовать лямбда-выражения.
+ Переменные интерфейса являются public static final по умолчанию и эти модификаторы необязательны при их объявлении.

+ [Вопрос#2  К оглавлению](#Функциональные-интерфейсы)

## Как вызывать `default` метод интерфейса в реализующем этот интерфейс классе?
Используя ключевое слово `super` вместе с именем интерфейса:
```java
interface Paper {
    default void show() {
        System.out.println("default show()");
    }
}

class Licence implements Paper {
    public void show() {
        Paper.super.show();
    }
}
```
+ [Вопрос#3  К оглавлению](#Функциональные-интерфейсы)

## Что такое `static` метод интерфейса?
Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что для них отсутствует возможность переопределения в классах, реализующих интерфейс.

+ Статические методы в интерфейсе являются частью интерфейса без возможности использовать их для объектов класса реализации;
+ Методы класса `java.lang.Object` нельзя переопределить как статические;
+ Статические методы в интерфейсе используются для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д.

+ [Вопрос#4  К оглавлению](#Функциональные-интерфейсы)

## Как вызывать `static` метод интерфейса?
Используя имя интерфейса:
```java
interface Paper {
    static void show() {
        System.out.println("static show()");
    }
}

class Licence {
    public void showPaper() {
        Paper.show();
    }
}
```
+ [Вопрос#5  К оглавлению](#Функциональные-интерфейсы)

## Зачем нужны `default` методы в функциональном интерфейсе?
Тут про обратную совместимость.  Вот почему не обязательно модифицировать классы при изменении интерфейса, который они реализуют.
+ [Вопрос#6  К оглавлению](#Функциональные-интерфейсы)

## Какие есть способы инстацировать функциональные интерфейсы?
+ Ссылка на метод.(Ссылка на метод - это сокращенный синтаксис выражения лямбда, который выполняет только один метод.)
+ Лямбда-выражение. 
+ Через анонимный класс. 
+ Через обычную имплементацию в классе. 

+ [Вопрос#7  К оглавлению](#Функциональные-интерфейсы)

## Сколько дефолтных методов и статических методов, статических полей в интерфейсе?
Любое количество методов по умолчанию (default) или статических методов.
+ [Вопрос#8  К оглавлению](#Функциональные-интерфейсы)

## Где находятся функциональные интерфейсы?
+ _`java.util.function`_

Куда же применить все эти лямбды и ссылки на методы, счастье было бы не полным, если каждому программисту теперь пришлось бы писать библиотечку вспомогательных классов и работающих. Вы можете писать код со своими функциональными интерфейсами, но в стандартную библиотеку, был добавлен механизм `STREAM API`.
+ [Вопрос#9  К оглавлению](#Функциональные-интерфейсы)

## Что такое ссылка на метод?
+ Ссылка на статический метод - `ContainingClass::staticMethodName`
+ Ссылка на нестатический метод конкретного объекта - `containingObject::instanceMethodName`
+ Ссылка на конструктор - `ClassName::new`
+ Ссылка на метод - это сокращенный синтаксис выражения лямбда, который выполняет только один метод. Это позволяет нам ссылаться на конструкторы или методы, не выполняя их.

+ [Вопрос#10  К оглавлению](#Функциональные-интерфейсы)

## Что такое лямбда-выражение? Чем его можно заменить?
Лямбда-выражение - упрощённая запись анонимного класса, реализующего функциональный интерфейс
+ [Вопрос#11  К оглавлению](#Функциональные-интерфейсы)

## Базовые функциональные интерфейсы Java 8?
1) __Predicate<T>__ - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean
2) __Consumer<T>__ (с англ. — “потребитель”) - реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает
3) __Function<T,R>__ - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R
4) __Supplier<T>__ (с англ. — поставщик)- реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T
5) __UnaryOperator<T>__ - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T
6) __BinaryOperator<T, Т>__ - реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T

+ [Вопрос#12  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы `Function<T,R>`, `DoubleFunction<R>`, `IntFunction<R>` и `LongFunction<R>`?
__`Function<T, R>`__ - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса `T` и возвращающая на выходе экземпляр класса `R`.

Методы по умолчанию могут использоваться для построения цепочек вызовов (`compose`, `andThen`).

```java
Function<String, Integer> toInteger = Integer::valueOf;
Function<String, String> backToString = toInteger.andThen(String::valueOf);
backToString.apply("123");     // "123"
```

+ `DoubleFunction<R>` - функция, получающая на вход `Double` и возвращающая на выходе экземпляр класса `R`;
+ `IntFunction<R>` - функция, получающая на вход `Integer` и возвращающая на выходе экземпляр класса `R`;
+ `LongFunction<R>` - функция, получающая на вход `Long` и возвращающая на выходе экземпляр класса `R`.

+ [Вопрос#13  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы `UnaryOperator<T>`, `DoubleUnaryOperator`, `IntUnaryOperator` и `LongUnaryOperator`?
__`UnaryOperator<T>` (унарный оператор)__ принимает в качестве параметра объект типа `T`, выполняет над ними операции и возвращает результат операций в виде объекта типа `T`:

```java
UnaryOperator<Integer> operator = x -> x * x;
System.out.println(operator.apply(5)); // 25
```

+ `DoubleUnaryOperator` - унарный оператор, получающий на вход `Double`;
+ `IntUnaryOperator` - унарный оператор, получающий на вход `Integer`;
+ `LongUnaryOperator` - унарный оператор, получающий на вход `Long`.

+ [Вопрос#14  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы `BinaryOperator<T>`, `DoubleBinaryOperator`, `IntBinaryOperator` и `LongBinaryOperator`?
__`BinaryOperator<T>` (бинарный оператор)__ - интерфейс, с помощью которого реализуется функция, получающая на вход два экземпляра класса `T` и возвращающая на выходе экземпляр класса `T`.
```java
BinaryOperator<Integer> operator = (a, b) -> a + b;
System.out.println(operator.apply(1, 2)); // 3
```

+ `DoubleBinaryOperator` - бинарный оператор, получающий на вход `Double`;
+ `IntBinaryOperator` - бинарный оператор, получающий на вход `Integer`;
+ `LongBinaryOperator` - бинарный оператор, получающий на вход `Long`.

+ [Вопрос#15  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы `Predicate<T>`, `DoublePredicate`, `IntPredicate` и `LongPredicate`?
__`Predicate<T>` (предикат)__ - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса `T` и возвращающая на выходе значение типа `boolean`. 

Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (`and`, `or`, `negate`).

```java
Predicate<String> predicate = (s) -> s.length() > 0;
predicate.test("foo"); // true
predicate.negate().test("foo"); // false
```

+ `DoublePredicate` - предикат, получающий на вход `Double`;
+ `IntPredicate` - предикат, получающий на вход `Integer`;
+ `LongPredicate` - предикат, получающий на вход `Long`.

+ [Вопрос#16  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы `Consumer<T>`, `DoubleConsumer`, `IntConsumer` и `LongConsumer`?
__`Consumer<T>` (потребитель)__ - интерфейс, с помощью которого реализуется функция, которая получает на вход экземпляр класса `T`, производит с ним некоторое действие и ничего не возвращает.

```java
Consumer<String> hello = (name) -> System.out.println("Hello, " + name);
hello.accept("world");
```

+ `DoubleConsumer` - потребитель, получающий на вход `Double`;
+ `IntConsumer` - потребитель, получающий на вход `Integer`;
+ `LongConsumer` - потребитель, получающий на вход `Long`.

+ [Вопрос#17  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы `Supplier<T>`,  `BooleanSupplier`, `DoubleSupplier`, `IntSupplier` и `LongSupplier`?
__`Supplier<T>` (поставщик)__ - интерфейс, с помощью которого реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса `T`;

```java
Supplier<LocalDateTime> now = LocalDateTime::now;
now.get();
```

+ `DoubleSupplier` - поставщик, возвращающий `Double`;
+ `IntSupplier` - поставщик, возвращающий `Integer`;
+ `LongSupplier` - поставщик, возвращающий `Long`.

+ [Вопрос#18  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужен функциональный интерфейс `BiConsumer<T,U>`?
__`BiConsumer<T,U>`__ представляет собой операцию, которая принимает два аргумента классов `T` и `U` производит с ними некоторое действие и ничего не возвращает.
+ [Вопрос#19  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужен функциональный интерфейс `BiFunction<T,U,R>`?
__`BiFunction<T,U,R>`__ представляет собой операцию, которая принимает два аргумента классов `T` и `U` и возвращающая результат класса `R`.
+ [Вопрос#20  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужен функциональный интерфейс `BiPredicate<T,U>`?
__`BiPredicate<T,U>`__ представляет собой операцию, которая принимает два аргумента классов `T` и `U` и возвращающая результат типа `boolean`. 
+ [Вопрос#21  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы вида `_To_Function`?
+ `DoubleToIntFunction` - операция принимающая аргумент класса `Double` и возвращающая результат типа `Integer`;
+ `DoubleToLongFunction` - операция принимающая аргумент класса `Double` и возвращающая результат типа `Long`;
+ `IntToDoubleFunction` - операция принимающая аргумент класса `Integer` и возвращающая результат типа `Double`; 
+ `IntToLongFunction` - операция принимающая аргумент класса `Integer` и возвращающая результат типа `Long`;
+ `LongToDoubleFunction` - операция принимающая аргумент класса `Long` и возвращающая результат типа `Double`;
+ `LongToIntFunction` - операция принимающая аргумент класса `Long` и возвращающая результат типа `Integer`.

+ [Вопрос#22  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы `ToDoubleBiFunction<T,U>`, `ToIntBiFunction<T,U>` и `ToLongBiFunction<T,U>`?
+ `ToDoubleBiFunction<T,U>` - операция принимающая два аргумента классов `T` и `U` и возвращающая результат типа `Double`;
+ `ToLongBiFunction<T,U>` - операция принимающая два аргумента классов `T` и `U` и возвращающая результат типа `Long`;
+ `ToIntBiFunction<T,U>`  - операция принимающая два аргумента классов `T` и `U` и возвращающая результат типа `Integer`.

+ [Вопрос#23  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы `ToDoubleFunction<T>`, `ToIntFunction<T>` и `ToLongFunction<T>`?
+ `ToDoubleFunction<T>` - операция принимающая аргумент класса `T` и возвращающая результат типа `Double`;
+ `ToLongFunction<T>` - операция принимающая аргумент класса `T` и возвращающая результат типа `Long`;
+ `ToIntFunction<T>` - операция принимающая аргумент класса `T` и возвращающая результат типа `Integer`.

+ [Вопрос#24  К оглавлению](#Функциональные-интерфейсы)

## Для чего нужны функциональные интерфейсы `ObjDoubleConsumer<T>`, `ObjIntConsumer<T>` и `ObjLongConsumer<T>`?
+ `ObjDoubleConsumer<T>` - операция, которая принимает два аргумента классов `T` и `Double`, производит с ними некоторое действие и ничего не возвращает;
+ `ObjLongConsumer<T>` - операция, которая принимает два аргумента классов `T` и `Long`, производит с ними некоторое действие и ничего не возвращает;
+ `ObjIntConsumer<T>` - операция, которая принимает два аргумента классов `T` и `Integer`, производит с ними некоторое действие и ничего не возвращает.

+ [Вопрос#25  К оглавлению](#Функциональные-интерфейсы)



## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
+ [Java 8 Predicate Examples-->]( https://mkyong.com/java8/java-8-predicate-examples/ )
+ [Функциональные интерфейсы в Java-->]( https://javarush.ru/groups/posts/2866-funkcionaljhnihe-interfeysih-v-java )
+ [Функциональный интерфейс-->]( https://www.examclouds.com/ru/java/java-core-russian/functional-interface-russian )
+ [Название-->]( Ссылка )


[к оглавлению](#Функциональные-интерфейсы)
