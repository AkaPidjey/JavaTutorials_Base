[Java Tutorials](README.md)

# Обобщения
+ [Что такое параметр общего типа?](#Что-такое-параметр-общего-типа)
+ [Каковы некоторые преимущества использования универсальных типов?](#Каковы-некоторые-преимущества-использования-универсальных-типов)
+ [Что такое стирание типа?](#Что-такое-стирание-типа)
+ [Если при создании объекта не указан универсальный тип, будет ли код по-прежнему компилироваться?](#Если-при-создании-объекта-не-указан-универсальный-тип-будет-ли-код-по-прежнему-компилироваться)
+ [Чем универсальный метод отличается от универсального типа?](#Чем-универсальный-метод-отличается-от-универсального-типа)
+ [Что такое вывод типа?](#Что-такое-вывод-типа)
+ [Что такое параметр ограниченного типа?](#Что-такое-параметр-ограниченного-типа)
+ [Можно ли объявить параметр с несколькими ограниченными типами?](#Можно-ли-объявить-параметр-с-несколькими-ограниченными-типами)
+ [Что такое подстановочный тип?](#Что-такое-подстановочный-тип)
+ [Что такое верхний ограниченный шаблон?](#Что-такое-верхний-ограниченный-шаблон)
+ [Что такое неограниченный шаблон?](#Что-такое-неограниченный-шаблон)
+ [Что такое подстановочный знак снизу?](#Что-такое-подстановочный-знак-снизу)
+ [Когда бы вы выбрали использование ограниченного снизу типа по сравнению с ограниченным сверху?](#Когда-бы-вы-выбрали-использование-ограниченного-снизу-типа-по-сравнению-с-ограниченным-сверху)
+ [Существуют ли ситуации, когда информация общего типа доступна во время выполнения?](#Существуют-ли-ситуации-когда-информация-общего-типа-доступна-во-время-выполнения)



+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)



[к оглавлению](#Обобщения)

## Что такое параметр общего типа?
Type - это имя class или interface . Как следует из названия, параметр общего типа - это когда type может использоваться в качестве параметра в объявлении класса, метода или интерфейса.

Давайте начнем с простого примера, без обобщений, чтобы продемонстрировать это:
```java
public interface Consumer {
    public void consume(String parameter)
}
```
В этом случае тип параметра метода для метода consume () - String. Он не параметризован и не настраивается.

Теперь давайте заменим наш тип String универсальным типом, который мы назовем T. Он назван так по соглашению
```java
public interface Consumer<T> {
    public void consume(T parameter)
}
```
Когда мы реализуем нашего потребителя, мы можем предоставить type , который мы хотим использовать в качестве аргумента. Это параметр общего типа:
```java
public class IntegerConsumer implements Consumer<Integer> {
    public void consume(Integer parameter)
}
```
В этом случае теперь мы можем использовать целые числа. Мы можем поменять этот type на то, что нам нужно.

[к оглавлению](#Обобщения)

## Каковы некоторые преимущества использования универсальных типов?
Одним из преимуществ использования дженериков является избежание затрат и обеспечение безопасности типов Это особенно полезно при работе с коллекциями.

Давайте продемонстрируем это:
```java
List list = new ArrayList();
list.add("foo");
Object o = list.get(1);
String foo = (String) foo;
```
В нашем примере тип элемента в нашем списке неизвестен компилятору.
Это означает, что единственное, что может быть гарантировано, это то, что это объект. Поэтому, когда мы получаем наш элемент, объект - это то, что мы получаем обратно.
Как авторы кода, мы знаем, что это String, , но мы должны привести наш объект к одному для явного решения проблемы. Это производит много шума и шаблон.
Далее, если мы начнем думать о комнате для ручной ошибки, проблема с кастингом станет еще хуже. Что если бы в нашем списке случайно было целое число?
```java
list.add(1)
Object o = list.get(1);
String foo = (String) foo;
```
В этом случае мы получили бы ClassCastException во время выполнения, поскольку Integer не может быть приведен к String.

Теперь давайте попробуем повториться, на этот раз используя дженерики:
```java
List<String> list = new ArrayList<>();
list.add("foo");
String o = list.get(1);   //No cast
Integer foo = list.get(1);//Compilation error
```
Как мы видим, ** с помощью обобщений у нас есть проверка типа компиляции, которая предотвращает ClassCastExceptions и устраняет необходимость в приведении.

+ Другое преимущество заключается в том, чтобы избежать дублирования кода ** . Без дженериков мы должны копировать и вставлять один и тот же код, но для разных типов. С дженериками мы не обязаны это делать. Мы даже можем реализовать алгоритмы, которые применяются к универсальным типам.

[к оглавлению](#Обобщения)

## Что такое стирание типа?
Важно понимать, что информация об общем типе доступна только компилятору, а не JVM. Другими словами , стирание типа означает, что общая информация о типе не доступна JVM во время выполнения, только во время компиляции .

Причина выбора основной реализации проста - сохранение обратной совместимости со старыми версиями Java. Когда универсальный код компилируется в байт-код, это будет так, как если бы универсальный тип никогда не существовал. Это означает, что компиляция будет:
+ Заменить универсальные типы объектами
+ Замените ограниченные типы (подробнее об этом в следующем вопросе) на первый связанный класс , Вставьте эквивалент приведений при получении общих объектов.

Важно понимать стирание типов. В противном случае разработчик может запутаться и подумать, что он сможет получить тип во время выполнения:
```java
public foo(Consumer<T> consumer) {
   Type type = consumer.getGenericTypeParameter()
}
```
Приведенный выше пример является псевдокодовым эквивалентом того, что может выглядеть без стирания типа, но, к сожалению, это невозможно. Еще раз, информация об общем типе не доступна во время выполнения.

[к оглавлению](#Обобщения)

## Если при создании объекта не указан универсальный тип, будет ли код по-прежнему компилироваться?
Поскольку дженерики не существовали до Java 5, их можно вообще не использовать. Например, дженерики были модифицированы для большинства стандартных классов Java, таких как коллекции. Если мы посмотрим на наш список из первого вопроса, то увидим, что у нас уже есть пример пропуска универсального типа:
```java
List list = new ArrayList();
```
Несмотря на возможность компиляции, вполне вероятно, что от компилятора будет предупреждение. Это потому, что мы теряем дополнительную проверку времени компиляции, которую мы получаем от использования обобщений.
Следует помнить, что хотя обратная совместимость и стирание типов позволяют исключать универсальные типы, это плохая практика.

[к оглавлению](#Обобщения)

## Чем универсальный метод отличается от универсального типа?
+ Универсальный метод - это когда параметр типа вводится в метод, живущий в рамках этого метода. ** Давайте попробуем это на примере:
```java
public static <T> T returnType(T argument) {
    return argument;
}
```
Мы использовали статический метод, но могли бы использовать и нестатический, если бы захотели. Используя вывод типа (рассмотренный в следующем вопросе), мы можем вызывать это, как любой обычный метод, без необходимости указывать аргументы типа при этом.

[к оглавлению](#Обобщения)

## Что такое вывод типа?
Вывод типа - это когда компилятор может посмотреть тип аргумента метода, чтобы вывести обобщенный тип. Например, если мы передали T методу, который возвращает T, , тогда компилятор может выяснить тип возвращаемого значения. Давайте попробуем это, используя наш общий метод из предыдущего вопроса:
```java
Integer inferredInteger = returnType(1);
String inferredString = returnType("String");
```
Как мы видим, нет необходимости в приведении, и нет необходимости передавать какой-либо аргумент общего типа. Тип аргумента выводит только тип возвращаемого значения.

[к оглавлению](#Обобщения)

## Что такое параметр ограниченного типа?
До сих пор все наши вопросы охватывали аргументы обобщенных типов, которые не ограничены. Это означает, что наши аргументы универсального типа могут быть любого типа, который мы хотим.

Когда мы используем ограниченные параметры, мы ограничиваем типы, которые можно использовать в качестве аргументов универсального типа. **
В качестве примера, допустим, мы хотим, чтобы наш универсальный тип всегда был подклассом животных:
```java
public abstract class Cage<T extends Animal> {
    abstract void addAnimal(T animal)
}
```
Используя extends _, , мы заставляем T быть подклассом животного . _ Тогда мы могли бы иметь клетку с кошками:
```java
Cage<Cat> catCage;
```
Но у нас не могло быть клетки объектов, поскольку объект не является подклассом животного:
```java
Cage<Object> objectCage;//Compilation error
```
Одним из преимуществ этого является то, что все методы животных доступны для компилятора. Мы знаем, что наш тип расширяет его, поэтому мы могли бы написать общий алгоритм, который работает с любым животным. Это означает, что нам не нужно воспроизводить наш метод для разных подклассов животных:
```java
public void firstAnimalJump() {
    T animal = animals.get(0);
    animal.jump();
}
```
[к оглавлению](#Обобщения)

## Можно ли объявить параметр с несколькими ограниченными типами?
Объявление нескольких границ для наших универсальных типов возможно. В нашем предыдущем примере мы указали одну границу, но мы могли бы также указать больше, если мы хотим:
```java
public abstract class Cage<T extends Animal & Comparable>
```
В нашем примере животное - это класс, а сопоставимый - это интерфейс.

Теперь наш тип должен уважать обе эти верхние границы. Если бы наш тип был подклассом animal, но не реализовал сопоставимый, то код не скомпилировался бы. Также стоит помнить, что если одна из верхних границ является классом, это должен быть первый аргумент.

[к оглавлению](#Обобщения)

## Что такое подстановочный тип?
Тип подстановочного знака представляет неизвестный type ** . Это взорвано с вопросительным знаком следующим образом:
```java
public static consumeListOfWildcardType(List<?> list)
```
Здесь мы указываем список, который может иметь любой type . Мы могли бы передать список чего угодно в этот метод.

[к оглавлению](#Обобщения)

## Что такое верхний ограниченный шаблон?
Верхний ограниченный подстановочный знак - это когда подстановочный тип наследуется от конкретного типа ** . Это особенно полезно при работе с коллекциями и наследованием.

Давайте попробуем продемонстрировать это с классом фермы, который будет хранить животных, сначала без подстановочного типа:
```java
public class Farm {
  private List<Animal> animals;

  public void addAnimals(Collection<Animal> newAnimals) {
    animals.addAll(newAnimals);
  }
}
```
Если бы у нас было несколько подклассов животных _, , таких как кошка и собака , _ , мы могли бы ошибочно предположить, что мы можем добавить их всех в нашу ферму:
```java
farm.addAnimals(cats);//Compilation error
farm.addAnimals(dogs);//Compilation error
```
Это связано с тем, что компилятор ожидает коллекцию конкретного типа animal _, _ , а не подклассов.

Теперь давайте введем ограниченный сверху символ подстановки для нашего метода добавления животных:
```java
public void addAnimals(Collection<? extends Animal> newAnimals)
```
Теперь, если мы попробуем снова, наш код скомпилируется. Это потому, что сейчас мы говорим компилятору принять коллекцию любого подтипа животных.

[к оглавлению](#Обобщения)

## Что такое неограниченный шаблон?
Неограниченный подстановочный знак - это подстановочный знак без верхней или нижней границы, который может представлять любой тип. **

Также важно знать, что подстановочный тип не является синонимом объекта. Это связано с тем, что подстановочный знак может быть любого типа, тогда как тип объекта является конкретно объектом (и не может быть подклассом объекта).

Давайте продемонстрируем это на примере:
```java
List<?> wildcardList = new ArrayList<String>();
List<Object> objectList = new ArrayList<String>();//Compilation error
```
Опять же, причина, по которой вторая строка не компилируется, состоит в том, что требуется список объектов, а не список строк. Первая строка компилируется, потому что список любого неизвестного типа является приемлемым.

[к оглавлению](#Обобщения)

## Что такое подстановочный знак снизу?
Нижний ограниченный подстановочный знак - когда вместо предоставления верхней границы мы предоставляем нижнюю границу, используя ключевое слово super . Другими словами, ограниченный снизу подстановочный знак означает, что мы заставляем тип быть суперклассом нашего ограниченного типа . Давайте попробуем это на примере:
```java
public static void addDogs(List<? super Animal> list) {
   list.add(new Dog("tom"))
}
```
Используя super, мы можем вызвать addDogs для списка объектов:
```java
ArrayList<Object> objects = new ArrayList<>();
addDogs(objects);
```
Это имеет смысл, поскольку объект является суперклассом животного. Если бы мы не использовали подстановочный знак, ограниченный снизу, код не скомпилировался бы, поскольку список объектов не является списком животных.

Если мы подумаем об этом, мы не сможем добавить собаку в список любого подкласса животных, таких как кошки или даже собаки. Только суперкласс животного. Например, это не скомпилирует:
``` java
ArrayList<Cat> objects = new ArrayList<>();
addDogs(objects);
```
[к оглавлению](#Обобщения)

## Когда бы вы выбрали использование ограниченного снизу типа по сравнению с ограниченным сверху?
При работе с коллекциями общим правилом выбора между подстановочными знаками с верхним или нижним ограничением является PECS. PECS расшифровывается как производитель расширяет, потребитель супер.

Это можно легко продемонстрировать с помощью использования некоторых стандартных интерфейсов и классов Java.
+ `Producer extends` просто означает, что если вы создаете производителя универсального типа, используйте ключевое слово extends . Давайте попробуем применить этот принцип к коллекции, чтобы понять, почему он имеет смысл:
```java
public static void makeLotsOfNoise(List<? extends Animal> animals) {
    animals.forEach(Animal::makeNoise);
}
```
Здесь мы хотим вызвать `makeNoise()` для каждого животного в нашей коллекции.

Это означает, что наша коллекция является производителем _, , так как все, что мы делаем с ней, это заставляет ее возвращать животных, чтобы мы могли выполнить нашу операцию. Если мы избавимся от `extends` , мы не сможем перейти в списки кошек , _ собак или любых других подклассов животных. Применяя принцип продления производителя, мы получаем максимально возможную гибкость.
+ `Consumer super` означает противоположность producer extends. Все это означает, что если мы имеем дело с чем-то, что потребляет элементы, то мы должны использовать ключевое слово `super__`. Мы можем продемонстрировать это, повторив наш предыдущий пример:
```java
public static void addCats(List<? super Animal> animals) {
    animals.add(new Cat());
}
```
Мы только добавляем в наш список животных, поэтому наш список животных является потребителем. Вот почему мы используем ключевое слово super . Это означает, что мы можем передать список любого суперкласса животных, но не подкласса. Например, если мы попытаемся передать список собак или кошек, код не скомпилируется.

Последнее, что нужно учитывать, - это что делать, если коллекция является одновременно потребителем и производителем. Примером этого может быть коллекция, в которой элементы добавляются и удаляются. В этом случае следует использовать неограниченный подстановочный знак.

[к оглавлению](#Обобщения)

## Существуют ли ситуации, когда информация общего типа доступна во время выполнения?
Существует одна ситуация, когда универсальный тип доступен во время выполнения.

Это когда универсальный тип является частью сигнатуры класса следующим образом:
```java
public class CatCage implements Cage<Cat>
```
Используя отражение, мы получаем этот параметр типа:
```java
(Class<T>) ((ParameterizedType) getClass()
  .getGenericSuperclass()).getActualTypeArguments()[0];
```
Этот код несколько хрупкий. Например, это зависит от параметра типа, который определяется в непосредственном суперклассе. Но это демонстрирует, что JVM имеет эту информацию о типе.

[к оглавлению](#Обобщения)




## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
#### [Lesson: Generics (Updated)-->]( https://docs.oracle.com/javase/tutorial/java/generics/index.html )
#### [Теория дженериков в Java или как на практике ставить скобки-->]( https://javarush.ru/groups/posts/2004-teorija-dzhenerikov-v-java-ili-gde-na-praktike-stavitjh-skobki )
#### [Стирание типов-->]( https://javarush.ru/groups/posts/2315-stiranie-tipov )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
#### [Название-->]( Ссылка )
