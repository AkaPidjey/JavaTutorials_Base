[JavaTutorials](README.md)

# Theme1___Exceptions
1) [Что такое исключения?](#Что-такое-исключения)
2) [Какова иерархия исключений?](#Какова-иерархия-исключений)
3) [Расскажите про обрабатываемые и необрабатываемые исключения](#Расскажите-про-обрабатываемые-и-необрабатываемые-исключения)
4) [Можно ли обработать необрабатываемые исключения?](#Можно-ли-обработать-необрабатываемые-исключения)
5) [В чем особенность `RuntimeException`?](#В-чем-особенность-RuntimeException)
6) [Можно и нужно ли обрабатывать ошибки `jvm`?](#Можно-и-нужно-ли-обрабатывать-ошибки-jvm)
7) [Может ли метод _`main()`_ выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?](#Может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения)
8) [Какие существуют способы обработки исключений?](#Какие-существуют-способы-обработки-исключений)
9) [О чем говорит ключевое слово `throws`?](#О-чем-говорит-ключевое-слово-throws)
10) [Какой оператор позволяет принудительно выбросить исключение?](#Какой-оператор-позволяет-принудительно-выбросить-исключение)
11) [Опишите работу блока _`try-catch-finally`_?](#Опишите-работу-блока-try-catch-finally)
12) [Что такое механизм _`try-with-resources`_?](#Что-такое-механизм-try-with-resources)
13) [В чем особенность блока `finally`? Всегда ли он исполняется?](#В-чем-особенность-блока-finally-Всегда-ли-он-исполняется)
14) [Существуют ли ситуации, когда блок `finally` не будет выполнен?](#Существуют-ли-ситуации-когда-блок-finally-не-будет-выполнен)
15) [Может ли не быть ни одного блока `catch` при отлавливании исключений?](#Может-ли-не-быть-ни-одного-блока-catch-при-отлавливании-исключений)
16) [Может ли один блок `catch` отлавливать сразу несколько исключений?](#Может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений)
17) [Как написать собственное («пользовательское») исключение?](#Как-написать-собственное-пользовательское-исключение)
18) [Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?](#Что-произойдёт-если-в-блоке-инициализации-возникнет-исключительная-ситуация)
19) [Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?](#Какое-исключение-выбрасывается-при-возникновении-ошибки-в-блоке-инициализации-класса)
20) [Когда в приложении может быть выброшено исключение `ClassCastException`?](#Когда-в-приложении-может-быть-выброшено-исключение-ClassCastException)
21) [Какие существуют _`unchecked exception`_?](#Какие-существуют-unchecked-exception)
22) [Что представляет из себя ошибки класса `Error`?](#Что-представляет-из-себя-ошибки-класса-Error)
23) [Что вы знаете о `OutOfMemoryError`?](#Что-вы-знаете-о-OutOfMemoryError)
24) [Предположим, есть метод, который может выбросить `IOException` и `FileNotFoundException` в какой последовательности должны идти блоки `catch`? Сколько блоков `catch` будет выполнено?](#Предположим-есть-метод-который-может-выбросить-IOException-и-FileNotFoundException-в-какой-последовательности-должны-идти-блоки-catch-Сколько-блоков-catch-будет-выполнено)
25) [Если оператор `return` содержится и в блоке `catch` и в `finally`, какой из них “главнее”?](#Если-оператор-return-содержится-и-в-блоке-catch-и-в-finally-какой-из-них-главнее)
26) [Что вы знаете о `SQLException`? К какому типу `checked` или `unchecked` оно относится, почему?](#Что-вы-знаете-о-SQLException-К-какому-типу-checked-или-unchecked-оно-относится-почему)
27) [Предположим, есть блок `try-finally`. В блоке `try` возникло исключение и выполнение переместилось в блок `finally`. В блоке `finally` тоже возникло исключение. Какое из двух исключений “выпадет” из блока `try-finally`? Что случится со вторым исключением?](#Предположим-есть-блок-try-finally-В-блоке-try-возникло-исключение-и-выполнение-переместилось-в-блок-finally-В-блоке-finally-тоже-возникло-исключение-Какое-из-двух-исключений-выпадет-из-блока-try-finally-Что-случится-со-вторым-исключением)
28) [Перечислите исключения по названиям?](#Перечислите-исключения-по-названиям)
29) [Какое назначение класса `Throwable`? Методы класса `Throwable`?](#Какое-назначение-класса-Throwable-Методы-класса-Throwable)
30) [В каком порядке следует обрабатывать исключения в catch блоках?](#В-каком-порядке-следует-обрабатывать-исключения-в-catch-блоках)
31) [Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?](#Что-произойдет-если-исключение-будет-выброшено-из-блока-catch-после-чего-другое-исключение-будет-выброшено-из-блока-finally)
32) [Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?](#Что-произойдет-если-исключение-будет-выброшено-из-блока-catch-после-чего-другое-исключение-будет-выброшено-из-метода-close-при-использовании-try-with-resources)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)



# Theme2___SerializableAndCopy
1) [Что такое _«сериализация»_?](#Что-такое-сериализация)
2) [Опишите процесс сериализации/десериализации с использованием `Serializable`.](#Опишите-процесс-сериализациидесериализации-с-использованием-serializable)
3) [Как изменить стандартное поведение сериализации/десериализации?](#Как-изменить-стандартное-поведение-сериализациидесериализации)
4) [Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?](#Какие-поля-не-будут-сериализованы-при-сериализации-Будет-ли-сериализовано-final-поле)
5) [Что обозначает ключевое слово `transient`?](#Что-обозначает-ключевое-слово-transient)
6) [Как не допустить сериализацию?](#Как-не-допустить-сериализацию)
7) [Как создать собственный протокол сериализации?](#Как-создать-собственный-протокол-сериализации)
8) [Какая роль поля `serialVersionUID` в сериализации?](#Какая-роль-поля-serialversionuid-в-сериализации)
9) [Когда стоит изменять значение поля `serialVersionUID`?](#Когда-стоит-изменять-значение-поля-serialversionuid)
10) [В чем проблема сериализации Singleton?](#В-чем-проблема-сериализации-singleton)
11) [Какие существуют способы контроля за значениями десериализованного объекта](#Какие-существуют-способы-контроля-за-значениями-десериализованного-объекта)
12) [Расскажите про клонирование объектов.](#Расскажите-про-клонирование-объектов)
13) [В чем отличие между _поверхностным_ и _глубоким_ клонированием?](#В-чем-отличие-между-поверхностным-и-глубоким-клонированием)
14) [Какой способ клонирования предпочтительней?](#Какой-способ-клонирования-предпочтительней)
15) [Почему метод `clone()` объявлен в классе `Object`, а не в интерфейсе `Cloneable`?](#Почему-метод-clone-объявлен-в-классе-object-а-не-в-интерфейсе-cloneable)
16) [Как создать глубокую копию объекта? (2 способа)](#Как-создать-глубокую-копию-объекта-2-способа)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)



# Theme3___Generics
1) [Что такое дженерики?](#Что-такое-дженерики)
2) [Для чего нужны дженерики?](#Для-чего-нужны-дженерики)
3) [Что такое сырые типы (raw type)?](#Что-такое-сырые-типы-raw-type)
4) [Что такое параметр общего типа?](#Что-такое-параметр-общего-типа)
5) [Каковы некоторые преимущества использования универсальных типов?](#Каковы-некоторые-преимущества-использования-универсальных-типов)
6) [Что такое стирание типа?](#Что-такое-стирание-типа)
7) [Если при создании объекта не указан универсальный тип, будет ли код по-прежнему компилироваться?](#Если-при-создании-объекта-не-указан-универсальный-тип-будет-ли-код-по-прежнему-компилироваться)
8) [Чем универсальный метод отличается от универсального типа?](#Чем-универсальный-метод-отличается-от-универсального-типа)
9) [Что такое вывод типа?](#Что-такое-вывод-типа)
10) [Что такое параметр ограниченного типа?](#Что-такое-параметр-ограниченного-типа)
11) [Можно ли объявить параметр с несколькими ограниченными типами?](#Можно-ли-объявить-параметр-с-несколькими-ограниченными-типами)
12) [Что такое подстановочный тип?](#Что-такое-подстановочный-тип)
13) [Что такое верхний ограниченный шаблон?](#Что-такое-верхний-ограниченный-шаблон)
14) [Что такое неограниченный шаблон?](#Что-такое-неограниченный-шаблон)
15) [Что такое подстановочный знак снизу?](#Что-такое-подстановочный-знак-снизу)
16) [Когда бы вы выбрали использование ограниченного снизу типа по сравнению с ограниченным сверху?](#Когда-бы-вы-выбрали-использование-ограниченного-снизу-типа-по-сравнению-с-ограниченным-сверху)
17) [Существуют ли ситуации, когда информация общего типа доступна во время выполнения?](#Существуют-ли-ситуации-когда-информация-общего-типа-доступна-во-время-выполнения)
18) [Что такое __`Wildcards`__?](#Что-такое-Wildcards)
19) [Что такое `The Get and Put Principle` или __PECS__ (`Producer Extends Consumer Super`)?](#Что-такое-The-Get-and-Put-Principle-или-PECS-Producer-Extends-Consumer-Super)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)



# Theme4___StreamAPIAndLambda

1) [Что такое Stream API? Для чего нужны стримы?](#Что-такое-Stream-API-Для-чего-нужны-стримы)
2) [Какие существуют способы создания стрима?](#Какие-существуют-способы-создания-стрима)
3) [Как из коллекции создать стрим?](#Как-из-коллекции-создать-стрим)
4) [В чем разница между `Collection` и `Stream`?](#В-чем-разница-между-collection-и-stream)
5) [Какие промежуточные методы работы со стримами вы знаете?](#Какие-промежуточные-методы-работы-со-стримами-вы-знаете)
6) [Какие конечные методы работы со стримами вы знаете?](#Какие-конечные-методы-работы-со-стримами-вы-знаете)
7) [Расскажите о параллельной обработке в Java 8.](#Расскажите-о-параллельной-обработке-в-Java-8)
8) [Что такое IntStream и DoubleStream?](#Что-такое-IntStream-и-DoubleStream)
9) [Для чего нужен метод `collect()` в стримах?](#Для-чего-нужен-метод-collect-в-стримах)
10) [Для чего в стримах применяются методы `forEach()` и `forEachOrdered()`?](#Для-чего-в-стримах-применяются-методы-foreach-и-foreachordered)
11) [Для чего в стримах предназначены методы `map()` и `mapToInt()`, `mapToDouble()`, `mapToLong()`?](#Для-чего-в-стримах-предназначены-методы-map-и-maptoint-maptodouble-maptolong)
12) [Какова цель метода `filter()` в стримах?](#Какова-цель-метода-filter-в-стримах)
13) [Для чего в стримах предназначен метод `limit()`?](#Для-чего-в-стримах-предназначен-метод-limit)
14) [Для чего в стримах предназначен метод `sorted()`?](#Для-чего-в-стримах-предназначен-метод-sorted)
15) [Для чего в стримах предназначены методы `flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()`?](#Для-чего-в-стримах-предназначены-методы-flatmap-flatmaptoint-flatmaptodouble-flatmaptolong)
16) [В чем разница методов `peek()` и `forEach()`?](#В-чем-разница-методов-peek-и-forEach)
17) [В чем разница методов `map()` и `flatMap()`?](#В-чем-разница-методов-map-и-flatMap)
18) [В чем разница методов `range()` и `rangeClosed()`?](#В-чем-разница-методов-range-и-rangeClosed)
19) [Можно ли конкатенировать Стримы? Если да то каким методом? Можно ли получить пустой стрим?](#Можно-ли-конкатенировать-Стримы-Если-да-то-каким-методом-Можно-ли-получить-пустой-стрим)
20) [Отличие Стримов от Итераторов?](#Отличие-Стримов-от-Итераторов)
21) [Отличие Стримов от Коллекций?](#Отличие-Стримов-от-Коллекций) 
22) [На какие группы можно поделить Стримы. Какие бывают Стримы?](#На-какие-группы-можно-поделить-Стримы-Какие-бывают-Стримы) 
23) [Что такое ленивая инициализация стрима?](#Что-такое-ленивая-инициализация-стрима)
24) [Расскажите о параллельной обработке в Java 8.](#Расскажите-о-параллельной-обработке-в-java-8)
25) [Что такое `StringJoiner`?](#Что-такое-stringjoiner)
26) [Что такое `Optional`?](#Что-такое-optional)
27) [Как вывести на экран 10 случайных чисел, используя `forEach()`?](#Как-вывести-на-экран-10-случайных-чисел-используя-foreach)
28) [Как можно вывести на экран уникальные квадраты чисел используя метод `map()`?](#Как-можно-вывести-на-экран-уникальные-квадраты-чисел-используя-метод-map)
29) [Как вывести на экран количество пустых строк с помощью метода `filter()`?](#Как-вывести-на-экран-количество-пустых-строк-с-помощью-метода-filter)
30) [Как вывести на экран 10 случайных чисел в порядке возрастания?](#Как-вывести-на-экран-10-случайных-чисел-в-порядке-возрастания)
31) [Как найти максимальное число в наборе?](#Как-найти-максимальное-число-в-наборе)
32) [Как найти минимальное число в наборе?](#Как-найти-минимальное-число-в-наборе)
33) [Как получить сумму всех чисел в наборе?](#Как-получить-сумму-всех-чисел-в-наборе)
34) [Как получить среднее значение всех чисел?](#Как-получить-среднее-значение-всех-чисел)
35) [Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?](#Что-такое-лямбда-Какова-структура-и-особенности-использования-лямбда-выражения)
36) [К каким переменным есть доступ у лямбда-выражений?](#К-каким-переменным-есть-доступ-у-лямбда-выражений)
37) [Как отсортировать список строк с помощью лямбда-выражения?](#Как-отсортировать-список-строк-с-помощью-лямбда-выражения)
38) [Что такое «ссылка на метод»? Какие виды ссылок на методы вы знаете?](#Что-такое-ссылка-на-метод-Какие-виды-ссылок-на-методы-вы-знаете)
39) [Объясните выражение `System.out::println`.](#Объясните-выражение-systemoutprintln)
40) [Любой анонимный класс можно заменить на лямбду?](#Любой-анонимный-класс-можно-заменить-на-лямбду)
41) [Связь лямбда с анонимным классом?](#Связь-лямбда-с-анонимным-классом)
+ [ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ](#ССЫЛКИ-НА-ДОПОЛНИТЕЛЬНУЮ-ИНФУ)







__Theme1 - Exceptions______________________________________________________________________________________________________________

## Что такое исключения?
Исключение – это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:
+ Пользователь ввел некорректные данные.
+ Файл, к которому обращается программа, не найден.
+ Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.
Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.

Каждый раз, когда при выполнении программы происходит ошибка, создается объект-исключение, содержащий информацию об ошибке, включая её тип и состояние программы на момент возникновения ошибки. После создания исключения среда выполнения пытается найти в стеке вызовов метод, который содержит код, обрабатывающий это исключение. Поиск начинается с метода, в котором произошла ошибка, и проходит через стек в обратном порядке вызова методов. Если не было найдено ни одного подходящего обработчика, выполнение программы завершается.

Исключения позволяют:
+ разделить обработку ошибок и сам алгоритм;
+ не загромождать код проверками возвращаемых значений;
+ обрабатывать ошибки на верхних уровнях, если на текущем уровне не хватает данных для обработки. Например, при написании универсального метода чтения из файла невозможно заранее предусмотреть реакцию на ошибку, так как эта реакция зависит от использующей метод программы;
+ классифицировать типы ошибок, обрабатывать похожие исключения одинаково, сопоставлять специфичным исключениям определенные обработчики.

Таким образом, механизм обработки исключений содержит следующие операции:
+ Создание объекта-исключения.
+ Заполнение stack trace'а этого исключения.
+ Stack unwinding (раскрутка стека) в поисках нужного обработчика.

+ [Thema#1 Question#1  Go to Exceptions](#Theme1___Exceptions)


## Какова иерархия исключений?
1) класс Throwable (checked)
2) от Throwable  --> Error (ошибки JVM) и Exception (checked общие)
3) от Exception 
    -- > RuntimeException (unchecked)
    -- > IOException, SQLException, ReflectiveOperationException (checked)
4) RuntimeException (unchecked):
  + ClassCastExceptiuon
  + IndexOutOfBoundException
  + AritthmeticException
  + NullPointerException

__checked__ - зависит от программиста, __unchecked__ - от программиста не зависит
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются подклассы Exception и Error.
+ Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемые и предсказуемые. Например, произошло деление на ноль в целых числах.
+ Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.

+ [Thema#1 Question#2  Go to Exceptions](#Theme1___Exceptions)

## Расскажите про обрабатываемые и необрабатываемые исключения
В Java все исключения делятся на два типа:
+ __checked (контролируемые/проверяемые исключения)__ должны обрабатываться блоком `catch` или описываться в сигнатуре метода (например, `throws IOException`). Наличие такого обработчика/модификатора сигнатуры проверяются на этапе компиляции;
+ __unchecked (неконтролируемые/непроверяемые исключения)__, к которым относятся ошибки `Error` (например, `OutOfMemoryError`), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом `RuntimeException` и его наследниками (например, `NullPointerException`), которые могут не обрабатываться блоком `catch` и не быть описанными в сигнатуре метода.

Все исключительные ситуации делятся на «проверяемые» `checked` и «непроверяемые» `unchecked`. Это свойство присуще «корневищу» `Throwable, Error, Exception, RuntimeException` и передается по наследству. Никак не видимо в исходном коде класса исключения.
В дальнейших примерах просто учтите, что— `Throwable` и `Exception` и все их наследники (за исключением наследников `Error-а` и `RuntimeException-а`) — `checked
— Error и RuntimeException` и все их наследники — `unchecked`
`checked exception` = проверяемое исключение, проверяемое компилятором.

Тема достаточно обширная для того, чтобы уместить ее в одном ответе. К примеру, можно разобрать примеры Головача: http://habrahabr.ru/company/golovachcourses/blog/225585/

И еще с quizful.net
1) Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.
2) Unchecked исключения в Java – наследованные от RuntimeException, checked – от Exception (не включая unchecked).

Checked исключения отличаются от Unchecked исключения в Java, тем что:
1) Наличие\обработка __`Checked`__ исключения проверяются __на этапе компиляции__. 
2) Наличие\обработка __`Unchecked`__ исключения происходит __на этапе выполнения__.

+ [Thema#1 Question#3  Go to Exceptions](#Theme1___Exceptions)

## Можно ли обработать необрабатываемые исключения?
Можно, чтобы в некотрых случаях программа не прекратила работу
+ [Thema#1 Question#4  Go to Exceptions](#Theme1___Exceptions)

## В чем особенность `RuntimeException`?
`public class RuntimeException extends Exception` – базовый класс для ошибок во время выполнения. Относится к необрабатываемым исключениям (uncatched\unchecked). Как сказано в описании класса – это суперкласс, исключения которого могут быть выброшены во время нормальной работы JVM.
+ [Thema#1 Question#5  Go to Exceptions](#Theme1___Exceptions)

## Можно и нужно ли обрабатывать ошибки jvm?
Обрабатывать можно, но делать этого не стоит. Разработчику не предоставлены инструменты для обработки ошибок системы и виртуальной машины.
+ [Thema#1 Question#6  Go to Exceptions](#Theme1___Exceptions)

## Может ли метод _`main()`_ выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
Может и оно будет передано в виртуальную машину Java (JVM).
+ [Thema#1 Question#7  Go to Exceptions](#Theme1___Exceptions)

## Какие существуют способы обработки исключений?
В Java есть пять ключевых слов для работы с исключениями:
+ __1 `try` –__ данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
+ __2 `catch` –__ ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
+ __3 `finally` –__ ключевое слово для отметки начала блока кода, которой является дополнительным. Этот блок помещается после последнего блока ‘catch’. Управление обычно передаётся в блок 'finally' в любом случае.
+ __4 `throw` –__ служит для генерации исключений.
+ __5 `throws` –__ ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.

+ [Подробнее с примерами-->](http://www.quizful.net/post/java-exceptions)
+ [Thema#1 Question#8  Go to Exceptions](#Theme1___Exceptions)

## О чем говорит ключевое слово `throws`?
__`throws`__ – ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.
+ [Thema#1 Question#9  Go to Exceptions](#Theme1___Exceptions)

## Какой оператор позволяет принудительно выбросить исключение?
Это оператор `throw`:

```java
throw new Exception();
```
+ [Thema#1 Question#10  Go to Exceptions](#Theme1___Exceptions)

## Опишите работу блока _`try-catch-finally`_?
`try` — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
`catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения.
`finally` — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока `catch`. Управление передаётся в блок `finally` в любом случае, было выброшено исключение или нет.

Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:

```java
try { 
    //код, который потенциально может привести к исключительной ситуации 
} 
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //код обработки исключительной ситуации
} 
finally {
    //необязательный блок, код которого выполняется в любом случае
}
```
+ [Thema#1 Question#11  Go to Exceptions](#Theme1___Exceptions)

## Что такое механизм _`try-with-resources`_?
Данная конструкция, которая появилась в Java 7, позволяет использовать блок _`try-catch`_ не заботясь о закрытии ресурсов, используемых в данном сегменте кода.
Ресурсы объявляются в скобках сразу после `try`, а компилятор уже сам неявно создаёт секцию `finally`, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс `java.lang.Autocloseable`. 

Общий вид конструкции:

```java
try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}
```
Стоит заметить, что блоки `catch` и явный `finally` выполняются уже после того, как закрываются ресурсы в неявном `finally`.
+ [Thema#1 Question#12  Go to Exceptions](#Theme1___Exceptions)

## В чем особенность блока `finally`? Всегда ли он исполняется?
Когда исключение передано, выполнение метода направляется по нелинейному пути. Это может стать источником проблем. Например, при входе метод открывает файл и закрывает при выходе. Чтобы закрытие файла не было пропущено из-за обработки исключения, был предложен механизм  __`finally`__.

Ключевое слово __`finally`__ создаёт блок кода, который будет выполнен после завершения блока __`try/catch`__, но перед кодом, следующим за ним. Блок будет выполнен, независимо от того, передано исключение или нет. Оператор __`finally`__ не обязателен, однако каждый оператор __`try`__ требует наличия либо __`catch`__, либо __`finally`__. Код в блоке __`finally`__ будет выполнен всегда.
+ [Thema#1 Question#13  Go to Exceptions](#Theme1___Exceptions)

## Существуют ли ситуации, когда блок `finally` не будет выполнен?
Да, кроме случаев завершения работы программы или JVM:
1) Finally может не выполниться в случае если в блоке try вызывает System.exit(0), 
2) Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта. 
3) В блоке try{} бесконечный цикл.
```java
try { 
    System.exit(0); 
} catch(Exception e) { 
    e.printStackTrace(); 
} finally { }
```
+ [Thema#1 Question#14  Go to Exceptions](#Theme1___Exceptions)

## Может ли не быть ни одного блока `catch` при отлавливании исключений?
Такая запись допустима, если имеется связка try{} finally {}. Но смысла в такой записи не так много, всё же лучше иметь блок catch в котором будет обрабатываться необходимое исключение.

```java
String x = "z";
try {
   x="234";
} finally {
    x = "Finally";
}
```
+ [Thema#1 Question#15  Go to Exceptions](#Theme1___Exceptions)

## Может ли один блок `catch` отлавливать сразу несколько исключений?
В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком `catch`:

```java
try {  
    //...
} catch(IOException | SQLException ex) {
    //...
}
```
+ [Thema#1 Question#16  Go to Exceptions](#Theme1___Exceptions)

## Как написать собственное («пользовательское») исключение?
Необходимо унаследоваться от базового класса требуемого типа исключений (например от `Exception` или `RuntimeException`) и переопределит методы
```java
class CustomException extends Exception {
    public CustomException() {
        super();
    }

    public CustomException(final String string) {
        super(string + " is invalid");
    }

    public CustomException(final Throwable cause) {
        super(cause);
    }
}
```
+ [Thema#1 Question#17  Go to Exceptions](#Theme1___Exceptions)

## Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?
Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в `throws` всех конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.

В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.
+ [Thema#1 Question#18  Go to Exceptions](#Theme1___Exceptions)

## Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
Если возникшее исключение - наследник `RuntimeException`:
+ для статических блоков инициализации будет выброшено `java.lang.ExceptionInInitializerError`;
+ для нестатических будет проброшено исключение-источник.

Если возникшее исключение - наследник `Error`, то в обоих случаях будет выброшено `java.lang.Error`. Исключение: `java.lang.ThreadDeath` - смерть потока. В этом случае никакое исключение выброшено не будет.
+ [Thema#1 Question#19  Go to Exceptions](#Theme1___Exceptions)

## Когда в приложении может быть выброшено исключение `ClassCastException`?
`ClassCastException` (потомок `RuntimeException`) - исключение, которое будет выброшено при ошибке приведения типа.
+ [Thema#1 Question#20  Go to Exceptions](#Theme1___Exceptions)

## Какие существуют _`unchecked exception`_?
Наиболее часто встречающиеся: 
+ `ArithmeticException`, 
+ `ClassCastException`, 
+ `ConcurrentModificationException`, 
+ `IllegalArgumentException`, 
+ `IllegalStateException`, 
+ `IndexOutOfBoundsException`, 
+ `NoSuchElementException`, 
+ `NullPointerException`, 
+ `UnsupportedOperationException`.

+ [Thema#1 Question#21  Go to Exceptions](#Theme1___Exceptions)

## Что представляет из себя ошибки класса `Error`?
Ошибки класса `Error` представляют собой наиболее серьёзные проблемы уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине. Обрабатывать такие ошибки не запрещается, но делать этого не рекомендуется.
+ [Thema#1 Question#22  Go to Exceptions](#Theme1___Exceptions)

## Что вы знаете о `OutOfMemoryError`?
`OutOfMemoryError` выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.

Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип `OutOfMemoryError` зависит от того, в какой из них не хватило места:

+ `java.lang.OutOfMemoryError: Java heap space`: Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами `-Xms` и `-Xmx`.
+ `java.lang.OutOfMemoryError: PermGen space`: (до версии Java 8) Данная ошибка возникает при нехватке места в _Permanent_ области, размер которой задается параметрами `-XX:PermSize` и `-XX:MaxPermSize`.
+ `java.lang.OutOfMemoryError: GC overhead limit exceeded`: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра `-XX:-UseGCOverheadLimit`.
+ `java.lang.OutOfMemoryError: unable to create new native thread`: Выбрасывается, когда нет возможности создавать новые потоки.

+ [Подробнее с примерами-->](http://habrahabr.ru/post/117274/)
+ [Thema#1 Question#23  Go to Exceptions](#Theme1___Exceptions)

## Предположим, есть метод, который может выбросить `IOException` и `FileNotFoundException` в какой последовательности должны идти блоки `catch`? Сколько блоков `catch` будет выполнено?

Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок `catch(Exception ex) {}`, иначе все дальнейшие блоки `catch()` уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику `catch(Exception ex)`.

Таким образом, исходя из факта, что `FileNotFoundException extends IOException` сначала нужно обработать `FileNotFoundException`, а затем уже `IOException`:

```java
void method() {
    try {
        //...
    } catch (FileNotFoundException ex) {
        //...
    } catch (IOException ex) {
        //...
    }
}
```
+ [Thema#1 Question#24  Go to Exceptions](#Theme1___Exceptions)

## Если оператор `return` содержится и в блоке `catch` и в `finally`, какой из них “главнее”?
Вернется из блока finally.
```java
    public static void main(String[] args) {
       String what =  method();
        System.out.println(what);
    }
 
    public static String method() {
        try {
            return "SomeString";
        } catch(Exception ex) {
            return "Catch message";
        } finally {
            return "Finally message";
        }
    }
//Вывод
Finally message
```
+ [Thema#1 Question#25  Go to Exceptions](#Theme1___Exceptions)

## Что вы знаете о `SQLException`? К какому типу `checked` или `unchecked` оно относится, почему?
+ SQLException предоставляет информацию об ошибках доступа к базе данных или других ошибках связанных с работой с базами данных.
+ SQLException относится к checked исключениям, а значит проверяется на этапе компиляции.
Споры об этом типе исключения идут о том, что разработчику приходится постоянно обрабатывать это исключение в коде, хотя большая часть ошибок возникает во время выполнения программы, т.е., по мнению многих, лучше бы отнести его к unchecked runtime исключениям.
```java
try {
    // make some SQL call(s)
} catch {SQLException e) { 
    // log the exception
    return; // and give up
}
```
Аргумент Joshua Bloch из Effective Java Second Edition такой: сделав SQLException проверяемым – это попытка заставить разработчиков обработать исключение и обернуть его в новом уровне абстракции.
+ [Thema#1 Question#26  Go to Exceptions](#Theme1___Exceptions)

## Предположим, есть блок `try-finally`. В блоке `try` возникло исключение и выполнение переместилось в блок `finally`. В блоке `finally` тоже возникло исключение. Какое из двух исключений “выпадет” из блока `try-finally`? Что случится со вторым исключением?
Ответ аналогичный случаю с двумя return – будет обработано в finally блоке. Если было выброшено два исключения – одно в try, второе в finally, то исключение в finally “проглотит” исключение выше (см. пример). Если до блока finally исключение было обработано, то мы можем получить информацию об исключении в блоке try и тем самым не потерять исключение, которое впоследствии может быть перезаписано в finally другим исключением.
```java
public class TestExc {

    public static void main(String[] args) {
        Exception ex = twoExceptionsMethod();
        System.out.println(ex.getClass());
 
        String s = twoExceptionsMethod2();
        System.out.println(s);
    }
 
    public static Exception twoExceptionsMethod() {
        try {
            return new IndexOutOfBoundsException();
        } finally {
            return new NullPointerException();
        }
    }
 
    public static String twoExceptionsMethod2() {
        try {
            throw new NullPointerException();
        }catch (NullPointerException ex) {
            System.out.println(ex.getMessage()+ " catchBlock");;
        }
        finally {
            Exception ex2 = new Exception();
            return ex2.getMessage() + "finallyBlock";
        }
    }
}
//Вывод
class java.lang.NullPointerException
null catchBlock
null finallyBlock
```
+ [Thema#1 Question#27  Go to Exceptions](#Theme1___Exceptions)

## Перечислите исключения по названиям?
Ниже приведен перечень подклассов непроверяемых исключений производными от класса RuntimeException и которые определены в пакете java.lang:
+ ArithmeticException – арифметическая ошибка (например, деление на ноль);
+ ArrayIndexOutOfBoundsException – индекс за пределами массива;
+ ArrayStoreException – присваивание элементу массива объекта несовместимого типа;
+ ClassCastException – неправильное приведение типов;
+ EnumConstantNotPresent – попытка воспользоваться неопределенным значением перечисления;
+ IllegalArgumentException – недопустимый аргумент при вызове метода;
+ IllegalMonitorStateException – недопустимая контрольная операция;
+ IllegalStateException – неверное состояние среды или приложения;
+ IllegalThreadStateException – несовместимость запрашиваемой операции с текущим состоянием потока выполнения;
+ IndexOutOfBoundsException – выход индекса некоторого типа за допустимые границы;
+ NegativeArraySizeException – создание массива отрицательного размера;
+ NullPointerException – неправильное использование пустой ссылки;
+ NumberFormatException – неправильное преобразование символьной строки в числовой формат;
+ SecurityException – попытка нарушения безопасности;
+ StringIndexOutOfBounds – попытка доступа по индексу за пределами символьной строки;
+ TypeNotPresentException – тип не найден;
+ UnsupportedOperationException – найдена неподдерживаемая операция.

В языке Java в пакете java.lang реализован ряд проверяемых исключений. Ниже приведен их перечень:
+ ClassNotFoundException – класс не найден;
+ CloneNotSupportedException – попытка клонировать объект из класса, который не реализует интерфейс Cloneable;
+ IllegalAccessException – запрещен доступ к классу;
+ InstantiationException – попытка создать объект абстрактного класса или интерфейса;
+ InterruptedException – один поток выполнения прерван другим потоком;
+ NoSuchFieldException – запрашиваемое поле не существует;
+ NoSuchMethodException – запрашиваемый метод не существует;
+ ReflectiveOperationException – суперкласс исключений, связанных с рефлексией.

+ [Thema#1 Question#28  Go to Exceptions](#Theme1___Exceptions)

## Какое назначение класса `Throwable`? Методы класса `Throwable`?
Класс Throwable есть базовым для всех стандартных классов исключений Java. Этот класс предоставляет ряд методов, которые можно использовать или переопределять в собственных классах обработки исключений. Эти классы должны быть унаследованы от класса Exception, который унаследован от класса Throwable (см. рисунок). Класс Exception не содержит методов.
Ниже приведен перечень методов класса Throwable.
__Методы:__
+ `final void addSuppressed(Throwable исключение)` - добавляет заданное исключение в список подавляемых исключений. Этот список связывается с вызывающим (данным) исключением. Метод используется для применения в операторе try с ресурсами.
+ `Throwable fillInStackTrace()` - возвращает объект класса Throwable, содержащий полную трассировку стека. Этот объект может быть сгенерирован повторно.
+ `Throwable getCause()` - возвращает исключение, лежащее в основе текущего исключения. Метод возвращает null в случае, если такое исключение отсутствует. Этот метод используется при создании цепочек исключений – он вызывает исключение, вызывающее текущее исключение.
+ `String getLocalizedMessage()` - возвращает локализованное описание исключения.
+ `String getMessage()` - возвращает описание исключения.
+ `StackTraceElement[] getStackTrace()` - возвращает массив, содержащий поэлементную трассировку стека в виде объектов класса StackTraceElement.
+ `final Throwable[] getSuppressed()` - получает подавленные исключения, связанные с вызывающим исключением, и возвращает массив, который содержит результат. Подавленные исключения генерируются в операторе try с ресурсами.
+ `Throwable initCause(Throwable причина_исключения)` - связывает входной параметр причина_исключения с вызывающим исключением, указывая его как причину этого вызывающего исключения. Возвращает ссылку на исключение. Метод используется при создании цепочек исключений.
+ `printStackTrace();` - выводит трассировку стека.
+ `void setStackTrace(StackTraceElement элементы[])` - устанавливает трассировку стека для заданных элементов.
+ `String toString()` - возвращает объект типа String содержащий описание исключения. Этот метод можно вызвать из метода println() при выводе объекта типа Throwable.

+ [Thema#1 Question#29  Go to Exceptions](#Theme1___Exceptions)

## В каком порядке следует обрабатывать исключения в catch блоках?
От наследника к предку.
+ [Thema#1 Question#30  Go to Exceptions](#Theme1___Exceptions)

## Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?
finally-секция может «перебить» throw/return при помощи другого throw/return.
+ [Thema#1 Question#31  Go to Exceptions](#Theme1___Exceptions)

## Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?
В `try-with-resources` добавленна возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия.
+ [Thema#1 Question#32  Go to Exceptions](#Theme1___Exceptions)

## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
+ [Название-->](Ссылка)
+ [Исключения-->](https://www.youtube.com/watch?v=DElNhj71YCk)
+ [Исключения: перехват и обработка-->](https://javarush.ru/groups/posts/1943-iskljuchenija-perekhvat-i-obrabotka)
+ [Исключения: checked, unchecked и свои собственные-->](https://javarush.ru/groups/posts/1944-iskljuchenija-checked-unchecked-i-svoi-sobstvennihe)
+ [Антипаттерны обработки исключений в Java-->](https://dev64.wordpress.com/2012/10/07/exception-handling-antipatterns/)
+ [Исправляем 7 распространенных ошибок обработки исключений в Java-->](https://habr.com/ru/post/337536/)
+ [Приемы и советы. Как избежать NullPointerException в Java приложениях-->](https://javarush.ru/groups/posts/680-priemih-i-sovetih-kak-izbezhatjh-nullpointerexception-v-java-prilozhenijakh)
+ [Основные типы исключений (Exception) в java-->](https://www.fandroid.info/osnovnye-tipy-isklyuchenij-exception-v-java/)
+ [Классы Java для обработки исключительных ситуаций из пакета java.lang. Методы класса Throwable. Примеры-->](https://www.bestprog.net/ru/2019/10/01/java-%D1%81lasses-for-handling-exceptions-from-the-java-lang-package-methods-of-throwable-class-examples-ru/)
+ [Java — исключения-->](https://coderlessons.com/tutorials/java-tekhnologii/uchit-java/java-iskliucheniia)
+ [Java Checked and Unchecked Exceptions-->](https://www.codejava.net/java-core/exception/java-checked-and-unchecked-exceptions)
+ [Обработка исключений Java: try-catch-finally-->](https://javahelp.online/collections/obrabotka-isklyucheniy-java-try-catch-finally)
+ [Полное руководство по обработке исключений в Java-->](https://javadevblog.com/polnoe-rukovodstvo-po-obrabotke-isklyuchenij-v-java.html)



__Theme2 - Serializable&Copy_________________________________________________________________________________________________________

## Что такое _«сериализация»_?
__Сериализация (Serialization)__ - процесс преобразования структуры данных в линейную последовательность байтов для дальнейшей передачи или сохранения. Сериализованные объекты можно затем восстановить (десериализовать).

В Java, согласно спецификации Java Object Serialization существует два стандартных способа сериализации: стандартная сериализация, через использование интерфейса `java.io.Serializable` и «расширенная» сериализация - `java.io.Externalizable`.

Сериализация позволяет в определенных пределах изменять класс. Вот наиболее важные изменения, с которыми спецификация Java Object Serialization может справляться автоматически:

+ добавление в класс новых полей;
+ изменение полей из статических в нестатические;
+ изменение полей из транзитных в нетранзитные.

Обратные изменения (из нестатических полей в статические и из нетранзитных в транзитные) или удаление полей требуют определенной дополнительной обработки в зависимости от того, какая степень обратной совместимости необходима.

+ [Thema#2 Question#1  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Опишите процесс сериализации/десериализации с использованием `Serializable`.
1) Класс объекта должен реализовывать интерфейс `Serializable`
2) Создать поток `ObjectOutputStream (oos)`, который записывает объект в переданный `OutputStream`.
3) Записать в поток: `oos.writeObject(Object)`;
4) Сделать `oos.flush()` и `oos.close()`

При использовании `Serializable` применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:
+ запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор `SerialVersionUID`, идентификаторы полей класса);
+ рекурсивную запись в поток описания суперклассов до класса `java.lang.Object` (не включительно);
+ запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
+ рекурсивную запись объектов, которые являются полями сериализуемого объекта.

При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками.

Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается. Однако при десериализации будет вызван конструктор без параметров родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.
+ [Thema#2 Question#2  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Как изменить стандартное поведение сериализации/десериализации?
+ Реализовать интерфейс `java.io.Externalizable`, который позволяет применение пользовательской логики сериализации. Способ сериализации и десериализации описывается в методах `writeExternal()` и `readExternal()`. Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод `readExternal`.
+ Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его, а не метод по умолчанию :
    + `writeObject()` - запись объекта в поток;
    + `readObject()` - чтение объекта из потока;
    + `writeReplace()` - позволяет заменить себя экземпляром другого класса перед записью;
    + `readResolve()` - позволяет заменить на себя другой объект после чтения.

+ [Thema#2 Question#3  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?
1) Добавить к полю модификатор `transient`. В таком случае после восстановления его значение будет null.
2) Сделать поле `static`. Значения статических полей автоматически не сохраняются. При использовании реализации `Externalizable` сериализовать и десериализовать статическое поле можно, но не рекомендуется этого делать, т.к. это может сопровождаться трудноуловимыми ошибками.
3) Поля с модификатором `final` сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании `Externalizable`, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в `readExternal` изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.

+ [Thema#2 Question#4  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Что обозначает ключевое слово `transient`?
Поля класса, помеченные модификатором `transient`, не сериализуются.

Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить. Другой пример такого поля - ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.
+ [Thema#2 Question#5  Go to Serializable&Copy](#Theme2___SerializableAndCopy)


## Как не допустить сериализацию?
Чтобы не допустить автоматическую сериализацию можно переопределить `private` методы для создания исключительной ситуации `NotSerializableException`.

```java
private void writeObject(ObjectOutputStream out) throws IOException {
    throw new NotSerializableException();
}

private void readObject(ObjectInputStream in) throws IOException {
    throw new NotSerializableException();
}
```
Любая попытка записать или прочитать этот объект теперь приведет к возникновению исключительной ситуации.
+ [Thema#2 Question#6  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Как создать собственный протокол сериализации?
Для создания собственного протокола сериализации достаточно реализовать интерфейс `Externalizable`, который содержит два метода:
```java
public void writeExternal(ObjectOutput out) throws IOException;
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
```
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках.
+ [Thema#2 Question#7  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Какая роль поля `serialVersionUID` в сериализации?
`serialVersionUID` используется для указании версии сериализованных данных. 

Когда мы не объявляем `serialVersionUID` в нашем классе явно, среда выполнения Java делает это за нас, но этот процесс чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей, интерфейсов, которые реализованы в классе и пр. 

Рекомендуется явно объявлять `serialVersionUID` т.к. при добавлении, удалении атрибутов класса динамически сгенерированное значение может измениться и в момент выполнения будет выброшено исключение `InvalidClassException`.
```java
private static final long serialVersionUID = 20161013L;
```
+ [Thema#2 Question#8  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Когда стоит изменять значение поля `serialVersionUID`?
`serialVersionUID` нужно изменять при внесении в класс несовместимых изменений, например при удалении какого-либо его атрибута.
Вы должны изменить `serialVersionUID` только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями , например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.
+ [Thema#2 Question#9  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## В чем проблема сериализации Singleton?
__Проблема__ в том что после десериализации мы получим другой объект. Таким образом, сериализация дает возможность создать Singleton еще раз, что недопустимо. Существует два способа избежать этого:
__Решение__
+ явный запрет сериализации.
+ определение метода с сигнатурой `(default/public/private/protected/) Object readResolve() throws ObjectStreamException`, назначением которого станет возврат замещающего объекта вместо объекта, на котором он вызван.

+ [Thema#2 Question#10  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Какие существуют способы контроля за значениями десериализованного объекта
Если есть необходимость выполнения контроля за значениями десериализованного объекта, то можно использовать интерфейс `ObjectInputValidation` с переопределением метода `validateObject()`.
```java
// Если вызвать метод validateObject() после десериализации объекта, то будет вызвано исключение InvalidObjectException при значении возраста за пределами 39...60.
public class Person implements java.io.Serializable,
                               java.io.ObjectInputValidation {
    ...
    @Override
    public void validateObject() throws InvalidObjectException {
        if ((age < 39) || (age > 60))
            throw new InvalidObjectException("Invalid age");
    }
}
```
Так же существуют способы подписывания и шифрования, позволяющие убедиться, что данные не были изменены:

+ с помощью описания логики в `writeObject()` и `readObject()`.
+ поместить в оберточный класс `javax.crypto.SealedObject` и/или `java.security.SignedObject`. Данные классы являются сериализуемыми, поэтому при оборачивании объекта в `SealedObject` создается подобие «подарочной упаковки» вокруг исходного объекта. Для шифрования необходимо создать симметричный ключ, управление которым должно осуществляться отдельно. Аналогично, для проверки данных можно использовать класс `SignedObject`, для работы с которым также нужен симметричный ключ, управляемый отдельно.

+ [Thema#2 Question#11  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Расскажите про клонирование объектов.
в Java, есть 3 способа клонирования объекта:
1) __С использованием интерфейса Cloneable;__
Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь о клонировании полей-объектов. Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public. Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты. 
2) __С использованием конструктора клонирования объекта;__
В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.
3) __С использованием сериализации.__
Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.


Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на объект. Таким образом, две ссылки указывают на одну и ту же область памяти, на один и тот же объект. Для создания нового объекта с таким же состоянием используется клонирование объекта. 

Класс `Object` содержит `protected` метод `clone()`, осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод `clone()` как `public` для обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию метода `super.clone()`, которая и выполняет собственно клонирование. 

Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс `Cloneable`. Интерфейс `Cloneable` не содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод `clone()` класса `Object` возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение `CloneNotSupportedException`. Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.

Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам объект поля класса.

Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс `Cloneable` и переопределяет метод `clone()`. Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений `final` для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.

Помимо встроенного механизма клонирования в Java для клонирования объекта можно использовать:

+ __Специализированный конструктор копирования__ - в классе описывается конструктор, который принимает объект этого же класса и инициализирует поля создаваемого объекта значениями полей переданного.
+ __Фабричный метод__ - (Factory method), который представляет собой статический метод, возвращающий экземпляр своего класса.
+ __Механизм сериализации__ - сохранение и последующее восстановление объекта в/из потока байтов.

+ [Thema#2 Question#12  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## В чем отличие между _поверхностным_ и _глубоким_ клонированием?
__Поверхностное копирование__ копирует настолько малую часть информации об объекте, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс `Object` не знает о структуре класса, которого он копирует. Клонирование такого типа осуществляется JVM по следующим правилам: 

+ Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
+ Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.

__Глубокое копирование__ дублирует абсолютно всю информацию объекта:
+ Нет необходимости копировать отдельно примитивные данные;
+ Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для каждого такого члена при переопределении метода `clone()` должен вызываться `super.clone()`;
+ Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.

+ [Thema#2 Question#13  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Какой способ клонирования предпочтительней?
Наиболее безопасным и, следовательно, предпочтительным способом клонирования является использование специализированного конструктора копирования: 

+ Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод `clone()`);
+ Поля для клонирования указываются явно;
+ Возможность клонировать даже `final` поля.

+ [Thema#2 Question#14  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Почему метод `clone()` объявлен в классе `Object`, а не в интерфейсе `Cloneable`?
Метод `clone()` объявлен в классе `Object` с указанием модификатора `native`, чтобы обеспечить доступ к стандартному механизму поверхностного копирования объектов. Одновременно он объявлен и как `protected`, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. Непосредственно интерфейс `Cloneable` является маркерным (не содержит объявлений методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть клонированным. Вызов переопределённого метода `clone()` у не `Cloneable` объекта вызовет выбрасывание `CloneNotSupportedException`.
+ [Thema#2 Question#15  Go to Serializable&Copy](#Theme2___SerializableAndCopy)

## Как создать глубокую копию объекта? (2 способа)
1) Глубокое клонирование требует выполнения следующих правил: 
+ Нет необходимости копировать отдельно примитивные данные;
+ Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться `super.clone()` при переопределении метода `clone()`;
+ Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.
2) Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс `Serializable`. Мы сохраняет объект в массив байт и потом прочитать из него.

+ [Thema#2 Question#16  Go to Serializable&Copy](#Theme2___SerializableAndCopy)


## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
+ [Сериализация в Java. Не все так просто-->](https://habr.com/ru/post/431524/#:~:text=%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F)
+ [Сериализация в Java-->](https://habr.com/ru/post/60317/)
+ [Сериализация и десериализация в Java-->](https://javarush.ru/groups/posts/2022-serializacija-i-deserializacija-v-java)
+ [Сериализация как она есть-->](http://www.skipy.ru/technics/serialization.html#top)
+ [Сериализация-->](https://metanit.com/java/tutorial/6.10.php)
+ [Все, что вам нужно знать о Java-сериализации-->]( https://coderlessons.com/articles/java/vse-chto-vam-nuzhno-znat-o-java-serializatsii )
+ [Как настроить сериализацию в Java с помощью внешнего интерфейса-->]( https://translate.google.com/translate?depth=1&pto=aue&rurl=translate.google.ru&sl=en&sp=nmt4&tl=ru&u=https://dzone.com/articles/how-to-customize-serialization-in-java-using-the-e )
+ [Сериализация объектов в Java-->]( https://pro-prof.com/forums/topic/%D1%81%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-java )
+ [Сериализация в Java-->]( https://coderlessons.com/articles/java/serializatsiia-v-java )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )



__Theme3 - Generics_________________________________________________________________________________

## Что такое дженерики?
__Дженерики – это параметризованные типы.__
С их помощью можно объявлять классы, интерфейсы и методы, в которых тип данных указан в виде параметра.
Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных.
Эта информация доступна только на этапе компиляции и стирается в runtime, и в байт код попадет только информация о том, что в программе есть некий список List<Object> list вместо List<String> list, например.
Появились в версии 1.5 
+ [Thema#3 Question#1  Go to Generics](#Theme3___Generics) 

## Для чего нужны дженерики?
__Для строгой типизации и проверки на этапе компиляции.__
Дженерики позволяют передавать тип объекта компилятору в форме <тип>. Таким образом, компилятор может выполнить все необходимые действия по проверке типов во время компиляции, обеспечивая безопасность по приведению типов во время выполнения.
+ [Thema#3 Question#2  Go to Generics](#Theme3___Generics)    
    
## Что такое сырые типы (raw type)?
__Сырые типы — это типы без указания типа в фигурных скобках ( `List list = new ArrayList<>()` )__, они использовались до появления дженериков.
Не указывая их, под капотом используется `Object`. 
+ [Thema#3 Question#3  Go to Generics](#Theme3___Generics)  

## Что такое параметр общего типа?
Type - это имя class или interface . Как следует из названия, параметр общего типа - это когда type может использоваться в качестве параметра в объявлении класса, метода или интерфейса.

Давайте начнем с простого примера, без обобщений, чтобы продемонстрировать это:
```java
public interface Consumer {
    public void consume(String parameter)
}
```
В этом случае тип параметра метода для метода consume() - String. Он не параметризован и не настраивается.

Теперь давайте заменим наш тип String универсальным типом, который мы назовем T. Он назван так по соглашению
```java
public interface Consumer<T> {
    public void consume(T parameter)
}
```
Когда мы реализуем нашего потребителя, мы можем предоставить type , который мы хотим использовать в качестве аргумента. Это параметр общего типа:
```java
public class IntegerConsumer implements Consumer<Integer> {
    public void consume(Integer parameter)
}
```
В этом случае теперь мы можем использовать целые числа. Мы можем поменять этот type на то, что нам нужно.
+ [Thema#3 Question#4  Go to Generics](#Theme3___Generics) 

## Каковы некоторые преимущества использования универсальных типов?
Одним из преимуществ использования дженериков является избежание затрат и обеспечение безопасности типов Это особенно полезно при работе с коллекциями.

Давайте продемонстрируем это:
```java
List list = new ArrayList();
list.add("foo");
Object o = list.get(1);
String foo = (String) foo;
```
В нашем примере тип элемента в нашем списке неизвестен компилятору.
Это означает, что единственное, что может быть гарантировано, это то, что это объект. Поэтому, когда мы получаем наш элемент, объект - это то, что мы получаем обратно.
Как авторы кода, мы знаем, что это String, , но мы должны привести наш объект к одному для явного решения проблемы. Это производит много шума и шаблон.
Далее, если мы начнем думать о комнате для ручной ошибки, проблема с кастингом станет еще хуже. Что если бы в нашем списке случайно было целое число?
```java
list.add(1)
Object o = list.get(1);
String foo = (String) foo;
```
В этом случае мы получили бы ClassCastException во время выполнения, поскольку Integer не может быть приведен к String.

Теперь давайте попробуем повториться, на этот раз используя дженерики:
```java
List<String> list = new ArrayList<>();
list.add("foo");
String o = list.get(1);   //No cast
Integer foo = list.get(1);//Compilation error
```
Как мы видим, ** с помощью обобщений у нас есть проверка типа компиляции, которая предотвращает ClassCastExceptions и устраняет необходимость в приведении.

+ Другое преимущество заключается в том, чтобы избежать дублирования кода ** . Без дженериков мы должны копировать и вставлять один и тот же код, но для разных типов. С дженериками мы не обязаны это делать. Мы даже можем реализовать алгоритмы, которые применяются к универсальным типам.

+ [Thema#3 Question#5  Go to Generics](#Theme3___Generics)  

## Что такое стирание типа?
Важно понимать, что информация об общем типе доступна только компилятору, а не JVM. Другими словами , стирание типа означает, что общая информация о типе не доступна JVM во время выполнения, только во время компиляции .

Причина выбора основной реализации проста - сохранение обратной совместимости со старыми версиями Java. Когда универсальный код компилируется в байт-код, это будет так, как если бы универсальный тип никогда не существовал. Это означает, что компиляция будет:
+ Заменить универсальные типы объектами
+ Замените ограниченные типы (подробнее об этом в следующем вопросе) на первый связанный класс , Вставьте эквивалент приведений при получении общих объектов.

Важно понимать стирание типов. В противном случае разработчик может запутаться и подумать, что он сможет получить тип во время выполнения:
```java
public foo(Consumer<T> consumer) {
   Type type = consumer.getGenericTypeParameter()
}
```
Приведенный выше пример является псевдокодовым эквивалентом того, что может выглядеть без стирания типа, но, к сожалению, это невозможно. Еще раз, информация об общем типе не доступна во время выполнения.
+ [Thema#3 Question#6  Go to Generics](#Theme3___Generics)   

## Если при создании объекта не указан универсальный тип, будет ли код по-прежнему компилироваться?
Поскольку дженерики не существовали до Java 5, их можно вообще не использовать. Например, дженерики были модифицированы для большинства стандартных классов Java, таких как коллекции. Если мы посмотрим на наш список из первого вопроса, то увидим, что у нас уже есть пример пропуска универсального типа:
```java
List list = new ArrayList();
```
Несмотря на возможность компиляции, вполне вероятно, что от компилятора будет предупреждение. Это потому, что мы теряем дополнительную проверку времени компиляции, которую мы получаем от использования обобщений.
Следует помнить, что хотя обратная совместимость и стирание типов позволяют исключать универсальные типы, это плохая практика.
+ [Thema#3 Question#7  Go to Generics](#Theme3___Generics) 

## Чем универсальный метод отличается от универсального типа?
+ Универсальный метод - это когда параметр типа вводится в метод, живущий в рамках этого метода. ** Давайте попробуем это на примере:
```java
public static <T> T returnType(T argument) {
    return argument;
}
```
Мы использовали статический метод, но могли бы использовать и нестатический, если бы захотели. Используя вывод типа (рассмотренный в следующем вопросе), мы можем вызывать это, как любой обычный метод, без необходимости указывать аргументы типа при этом.
+ [Thema#3 Question#8  Go to Generics](#Theme3___Generics) 

## Что такое вывод типа?
Вывод типа - это когда компилятор может посмотреть тип аргумента метода, чтобы вывести обобщенный тип. Например, если мы передали T методу, который возвращает T, , тогда компилятор может выяснить тип возвращаемого значения. Давайте попробуем это, используя наш общий метод из предыдущего вопроса:
```java
Integer inferredInteger = returnType(1);
String inferredString = returnType("String");
```
Как мы видим, нет необходимости в приведении, и нет необходимости передавать какой-либо аргумент общего типа. Тип аргумента выводит только тип возвращаемого значения.
+ [Thema#3 Question#9  Go to Generics](#Theme3___Generics) 

## Что такое параметр ограниченного типа?
До сих пор все наши вопросы охватывали аргументы обобщенных типов, которые не ограничены. Это означает, что наши аргументы универсального типа могут быть любого типа, который мы хотим.

Когда мы используем ограниченные параметры, мы ограничиваем типы, которые можно использовать в качестве аргументов универсального типа. **
В качестве примера, допустим, мы хотим, чтобы наш универсальный тип всегда был подклассом животных:
```java
public abstract class Cage<T extends Animal> {
    abstract void addAnimal(T animal)
}
```
Используя extends _, , мы заставляем T быть подклассом животного . _ Тогда мы могли бы иметь клетку с кошками:
```java
Cage<Cat> catCage;
```
Но у нас не могло быть клетки объектов, поскольку объект не является подклассом животного:
```java
Cage<Object> objectCage;//Compilation error
```
Одним из преимуществ этого является то, что все методы животных доступны для компилятора. Мы знаем, что наш тип расширяет его, поэтому мы могли бы написать общий алгоритм, который работает с любым животным. Это означает, что нам не нужно воспроизводить наш метод для разных подклассов животных:
```java
public void firstAnimalJump() {
    T animal = animals.get(0);
    animal.jump();
}
```

+ [Thema#3 Question#10  Go to Generics](#Theme3___Generics) 

## Можно ли объявить параметр с несколькими ограниченными типами?
Объявление нескольких границ для наших универсальных типов возможно. В нашем предыдущем примере мы указали одну границу, но мы могли бы также указать больше, если мы хотим:
```java
public abstract class Cage<T extends Animal & Comparable>
```
В нашем примере животное - это класс, а сопоставимый - это интерфейс.

Теперь наш тип должен уважать обе эти верхние границы. Если бы наш тип был подклассом animal, но не реализовал сопоставимый, то код не скомпилировался бы. Также стоит помнить, что если одна из верхних границ является классом, это должен быть первый аргумент.
+ [Thema#3 Question#11  Go to Generics](#Theme3___Generics) 

## Что такое подстановочный тип?
Тип подстановочного знака представляет неизвестный type ** . Это взорвано с вопросительным знаком следующим образом:
```java
public static consumeListOfWildcardType(List<?> list)
```
Здесь мы указываем список, который может иметь любой type . Мы могли бы передать список чего угодно в этот метод.
+ [Thema#3 Question#12  Go to Generics](#Theme3___Generics) 

## Что такое верхний ограниченный шаблон?
Верхний ограниченный подстановочный знак - это когда подстановочный тип наследуется от конкретного типа ** . Это особенно полезно при работе с коллекциями и наследованием.

Давайте попробуем продемонстрировать это с классом фермы, который будет хранить животных, сначала без подстановочного типа:
```java
public class Farm {
  private List<Animal> animals;

  public void addAnimals(Collection<Animal> newAnimals) {
    animals.addAll(newAnimals);
  }
}
```
Если бы у нас было несколько подклассов животных _, , таких как кошка и собака , _ , мы могли бы ошибочно предположить, что мы можем добавить их всех в нашу ферму:
```java
farm.addAnimals(cats);//Compilation error
farm.addAnimals(dogs);//Compilation error
```
Это связано с тем, что компилятор ожидает коллекцию конкретного типа animal _, _ , а не подклассов.

Теперь давайте введем ограниченный сверху символ подстановки для нашего метода добавления животных:
```java
public void addAnimals(Collection<? extends Animal> newAnimals)
```
Теперь, если мы попробуем снова, наш код скомпилируется. Это потому, что сейчас мы говорим компилятору принять коллекцию любого подтипа животных.
+ [Thema#3 Question#13  Go to Generics](#Theme3___Generics) 

## Что такое неограниченный шаблон?
Неограниченный подстановочный знак - это подстановочный знак без верхней или нижней границы, который может представлять любой тип. **

Также важно знать, что подстановочный тип не является синонимом объекта. Это связано с тем, что подстановочный знак может быть любого типа, тогда как тип объекта является конкретно объектом (и не может быть подклассом объекта).

Давайте продемонстрируем это на примере:
```java
List<?> wildcardList = new ArrayList<String>();
List<Object> objectList = new ArrayList<String>();//Compilation error
```
Опять же, причина, по которой вторая строка не компилируется, состоит в том, что требуется список объектов, а не список строк. Первая строка компилируется, потому что список любого неизвестного типа является приемлемым.
+ [Thema#3 Question#14  Go to Generics](#Theme3___Generics) 

## Что такое подстановочный знак снизу?
Нижний ограниченный подстановочный знак - когда вместо предоставления верхней границы мы предоставляем нижнюю границу, используя ключевое слово super . Другими словами, ограниченный снизу подстановочный знак означает, что мы заставляем тип быть суперклассом нашего ограниченного типа . Давайте попробуем это на примере:
```java
public static void addDogs(List<? super Animal> list) {
   list.add(new Dog("tom"))
}
```
Используя super, мы можем вызвать addDogs для списка объектов:
```java
ArrayList<Object> objects = new ArrayList<>();
addDogs(objects);
```
Это имеет смысл, поскольку объект является суперклассом животного. Если бы мы не использовали подстановочный знак, ограниченный снизу, код не скомпилировался бы, поскольку список объектов не является списком животных.

Если мы подумаем об этом, мы не сможем добавить собаку в список любого подкласса животных, таких как кошки или даже собаки. Только суперкласс животного. Например, это не скомпилирует:
``` java
ArrayList<Cat> objects = new ArrayList<>();
addDogs(objects);
```
+ [Thema#3 Question#15  Go to Generics](#Theme3___Generics)  

## Когда бы вы выбрали использование ограниченного снизу типа по сравнению с ограниченным сверху?
При работе с коллекциями общим правилом выбора между подстановочными знаками с верхним или нижним ограничением является PECS. PECS расшифровывается как производитель расширяет, потребитель супер.

Это можно легко продемонстрировать с помощью использования некоторых стандартных интерфейсов и классов Java.
+ `Producer extends` просто означает, что если вы создаете производителя универсального типа, используйте ключевое слово extends . Давайте попробуем применить этот принцип к коллекции, чтобы понять, почему он имеет смысл:
```java
public static void makeLotsOfNoise(List<? extends Animal> animals) {
    animals.forEach(Animal::makeNoise);
}
```
Здесь мы хотим вызвать `makeNoise()` для каждого животного в нашей коллекции.

Это означает, что наша коллекция является производителем _, , так как все, что мы делаем с ней, это заставляет ее возвращать животных, чтобы мы могли выполнить нашу операцию. Если мы избавимся от `extends` , мы не сможем перейти в списки кошек , _ собак или любых других подклассов животных. Применяя принцип продления производителя, мы получаем максимально возможную гибкость.
+ `Consumer super` означает противоположность producer extends. Все это означает, что если мы имеем дело с чем-то, что потребляет элементы, то мы должны использовать ключевое слово `super__`. Мы можем продемонстрировать это, повторив наш предыдущий пример:
```java
public static void addCats(List<? super Animal> animals) {
    animals.add(new Cat());
}
```
Мы только добавляем в наш список животных, поэтому наш список животных является потребителем. Вот почему мы используем ключевое слово super . Это означает, что мы можем передать список любого суперкласса животных, но не подкласса. Например, если мы попытаемся передать список собак или кошек, код не скомпилируется.

Последнее, что нужно учитывать, - это что делать, если коллекция является одновременно потребителем и производителем. Примером этого может быть коллекция, в которой элементы добавляются и удаляются. В этом случае следует использовать неограниченный подстановочный знак.
+ [Thema#3 Question#16  Go to Generics](#Theme3___Generics)  

## Существуют ли ситуации, когда информация общего типа доступна во время выполнения?
Существует одна ситуация, когда универсальный тип доступен во время выполнения.

Это когда универсальный тип является частью сигнатуры класса следующим образом:
```java
public class CatCage implements Cage<Cat>
```
Используя отражение, мы получаем этот параметр типа:
```java
(Class<T>) ((ParameterizedType) getClass()
  .getGenericSuperclass()).getActualTypeArguments()[0];
```
Этот код несколько хрупкий. Например, это зависит от параметра типа, который определяется в непосредственном суперклассе. Но это демонстрирует, что JVM имеет эту информацию о типе.
+ [Thema#3 Question#17  Go to Generics](#Theme3___Generics)  

## Что такое __`Wildcards`__?
Маске(wildcard) можно задать ограничения:
1) __“? extends T” (для получения в методе)__  - объект, который наследуется от Т, либо сам Т – __ковариантность__.
Если контейнер объявлен ? extends T, то можно только читать значения. В список нельзя ничего добавить, кроме null.
2) __“? super T” (для отдачи в методе)__ - любой объект подтипа Т, включая Т – __контравариантность__. Нельзя прочитать элемент из контейнера с wildcard ? super, кроме объекта класса Object

При использовании ? мы сообщаем компилятору, чтобы он игнорировал информацию о типе, т.е. <?> - неограниченный символ подстановки. <?> означает то же что и `<? extends Object>`, т.е. принимает всё. Это можно обойти, создав обобщенный метод, объявленный с переменной типа T.

Всегда ли Generics инварианты? Нет. Приведу примеры:
```java
List<Integer> ints = new ArrayList<Integer>();
List<? extends Number> nums = ints;
```
1) Это ковариантность. `List<Integer>` — подтип `List<? extends Number>`

```java
List<Number> nums = new ArrayList<Number>();
List<? super Integer> ints = nums;
```
2) Это контравариантность. `List<Number>` является подтипом `List<? super Integer>`.

Запись вида "`? extends ...`" или "`? super ...`" — называется `wildcard` или символом подстановки, с верхней границей `(extends)` или с нижней границей `(super)`. `List<? extends Number>` может содержать объекты, класс которых является `Number` или наследуется от `Number`. `List<? super Number>` может содержать объекты, класс которых `Number` или  у которых `Number` является наследником (супертип от `Number`).

`extends B` — символ подстановки с указанием верхней границы
`super B` — символ подстановки с указанием нижней границы
где B — представляет собой границу

Запись вида T2 <= T1 означает, что набор типов описываемых T2 является подмножеством набора типов описываемых T1

т.е.
`Number <=? extends Object`
`? extends Number <=? extends Object`
и
`? super Object <=? super Number`

+ [Thema#3 Question#18  Go to Generics](#Theme3___Generics)  

## Что такое `The Get and Put Principle` или __PECS__ (`Producer Extends Consumer Super`?
Особенность `wildcard` с верхней и нижней границей дает дополнительные фичи, связанные с безопасным использованием типов. Из одного типа переменных можно только читать, в другой — только вписывать (исключением является возможность записать `null` для `extends` и прочитать `Object` для `super`). Чтобы было легче запомнить, когда какой `wildcard` использовать, существует принцип `PECS — Producer Extends Consumer Super`.
+ Если мы объявили wildcard с extends, то это producer. Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает.
+ Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может.

Иначе говоря:
+ Если вы только получаете объекты из дженерик-коллекции - это producer и надо использвовать extends.
+ Если вы только кладете объекты в коллекцию - это consumer и надо использовать super.
+ Если вы делаете оба эти действия, то не надо использовать ни super, ни extends.

Рассмотрим использование `Wildcard` и принципа PECS на примере метода copy в классе `java.util.Collections`.
```java
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
…
}
```
Метод осуществляет копирование элементов из исходного списка src в список dest. src — объявлен с `wildcard ? extends` и является продюсером, а dest — объявлен с `wildcard ? super` и является потребителем. Учитывая ковариантность и контравариантность `wildcard`, можно скопировать элементы из списка ints в список nums:
```java
List<Number> nums = Arrays.<Number>asList(4.1F, 0.2F);
List<Integer> ints = Arrays.asList(1,2);
Collections.copy(nums, ints);
```
Если же мы по ошибке перепутаем параметры метода copy и попытаемся выполнить копирование из списка nums в список ints, то компилятор не позволит нам это сделать:
`Collections.copy(ints, nums)`; // Compile-time error
+ [Thema#3 Question#19  Go to Generics](#Theme3___Generics)   


## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
+ [Пришел, увидел, обобщил: погружаемся в Java Generics-->]( https://habr.com/ru/company/sberbank/blog/416413/ )
+ [Lesson: Generics (Updated)-->]( https://docs.oracle.com/javase/tutorial/java/generics/index.html )
+ [Теория дженериков в Java или как на практике ставить скобки-->]( https://javarush.ru/groups/posts/2004-teorija-dzhenerikov-v-java-ili-gde-na-praktike-stavitjh-skobki )
+ [Стирание типов-->]( https://javarush.ru/groups/posts/2315-stiranie-tipov )
+ [Руководство Java Generics-->]( https://o7planning.org/ru/10403/java-generics-tutorial )
+ [Обобщение типа данных, generic-->]( http://java-online.ru/java-generic.xhtml )
+ [Краткое руководство по Java Generics-->]( https://coderlessons.com/articles/java/kratkoe-rukovodstvo-po-java-generics )
+ [Дженерики (Java, обучающая статья)-->]( http://www.quizful.net/post/java-generics-tutorial )
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )


__# Theme4___StreamAPIAndLambda________________________________________________________________________________________

## Что такое Stream API? Для чего нужны стримы?
Интерфейс `java.util.Stream` представляет собой последовательность элементов, над которой можно производить различные операции.

Операции над стримами бывают или _промежуточными (intermediate)_ или _конечными (terminal)_. Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом. 

Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными.

У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не происходит (похоже на создание объекта `Thread` или `Runnable`, без вызова `start()`).

Стримы создаются на основе источников каких-либо, например классов из `java.util.Collection`. 

Ассоциативные массивы (maps), например, `HashMap`, не поддерживаются.

Операции над стримами могут выполняться как последовательно, так и параллельно.

Потоки не могут быть использованы повторно. Как только была вызвана какая-нибудь конечная операция, поток закрывается.

Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных `int`, `long` и `double`: `IntStream`, `LongStream` и `DoubleStream`. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями: 

+ используют специализированные лямбда-выражения, например, `IntFunction` или `IntPredicate` вместо `Function` и `Predicate`; 
+ поддерживают дополнительные конечные операции `sum()`, `average()`, `mapToObj()`.

+ [Thema#4 Question#4  Go to StreamAPIAndLambda](#Theme4___StreamAPIAndLambda)  

## Какие существуют способы создания стрима?
1) Пустой стрим: Stream.empty()
2) Стрим из List: list.stream()
3) Стрим из Map: map.entrySet().stream()
4) Стрим из массива: Arrays.stream(array)
5) Стрим из указанных элементов: Stream.of("1", "2", "3")
6) Можно получить из BufferedReader при помощи метода lines(), который вернет поток строк из потока символов.
7) Из директории на диске при помощи методов Files.list() и Files.walk()
8) Можно получить из строки методом chars(), будет IntStream с символами.
9) Можно порождать динамически, генерировать при помощи supplier.
10) Итерированием какой-то функции
11) Можно получить диапазон чисел в виде стрима range и rangeClosed
12) Конкатенацией других стримов

+ Из коллекции:
```java 
Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();
```
+ Из набора значений:
```java 
Stream<String> fromValues = Stream.of("x", "y", "z");
```
+ Из массива:
```java 
Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});
```
+ Из файла (каждая строка в файле будет отдельным элементом в стриме):
```java 
Stream<String> fromFile = Files.lines(Paths.get("input.txt"));
```
+ Из строки:
```java 
IntStream fromString = "0123456789".chars();
```
+ С помощью `Stream.builder()`:
```java 
Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();
```
+ С помощью `Stream.iterate()` (бесконечный):
```java 
Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);
```
+ С помощью `Stream.generate()` (бесконечный):
```java 
Stream<String> fromGenerate = Stream.generate(() -> "0");
```
+ [Вопрос#2  К оглавлению](#Stream-API-и-Лямбда)

## Как из коллекции создать стрим?
```java
Collection<String> collection = Arrays.asList("a1", "a2", "a3");
Stream<String> streamFromCollection = collection.stream();
```
+ [Вопрос#3  К оглавлению](#Stream-API-и-Лямбда)

## В чем разница между `Collection` и `Stream`?
Коллекции позволяют работать с элементами по-отдельности, тогда как стримы так делать не позволяют, но вместо этого предоставляют возможность выполнять функции над данными как над одним целым.

Также стоит отметить важность самой концепции сущностей: `Collection` - это прежде всего воплощение _Структуры Данных_. Например, `Set` не просто хранит в себе элементы, он реализует идею множества с уникальными элементами,
тогда как `Stream`, это прежде всего абстракция необходимая для реализации _конвеера вычислений_, собственно поэтому, результатом работы конвеера являются те или иные _Структуры Данных_ или же результаты проверок/поиска и т.п. 
+ [Вопрос#4  К оглавлению](#Stream-API-и-Лямбда)

## Какие промежуточные методы работы со стримами вы знаете?
+ `filter()` фильтрует стрим, возвращая только те элементы, что проходят по условию (Predicate)
Проверяет значение на “true” и “false”
+ `skip()` позволяет пропустить определённое количество элементов в начале;
+ `distinct()` возвращает стрим без дубликатов (для метода `equals()`);
+ `map()` Метод map() заданным образом преобразует каждый элемент стрима, потом преобразует все объекты в итоговый стрим. 
+ `peek()` возвращает тот же стрим, применяя к каждому элементу функцию; Предполагается, что `map()` получает на вход один объект, а возвращает другой. Возможно, того же типа, но другой. `peek()` - это частный случай `map()`, который возвращает тот же самый объект, который получил на входе, возможно, с изменённым внутренним состоянием. Конечно, можно использовать для этого `map()`, но есть нюансы. Во-первых, `peek()` на одну строчку короче - не нужно писать `return`, Java и так знает, что нужно возвращать. Во-вторых, вы страхуетесь от ошибок - из `peek()` невозможно вернуть не тот объект, который пришёл на вход.
+ `limit()` позволяет ограничить выборку определенным количеством первых элементов;
+ `sorted()` позволяет сортировать значения либо в натуральном порядке, либо задавая `Comparator`;
+ `mapToInt()`, `mapToDouble()`, `mapToLong()` - аналоги `map()` возвращающие стрим числовых примитивов;
+ `flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()` - похожи на `map()`, но могут создавать из одного элемента несколько.
flatMap возвращает по стриму для каждого объекта в первоначальном стриме, а затем результирующие потоки объединяются в исходный стрим.

Для числовых стримов дополнительно доступен метод `mapToObj()`, который преобразует числовой стрим обратно в объектный.
+ [Вопрос#5  К оглавлению](#Stream-API-и-Лямбда)

## Какие конечные методы работы со стримами вы знаете?
+ `findFirst()` возвращает первый элемент;
+ `findAny()` возвращает любой подходящий элемент;
+ `collect()` представление результатов в виде коллекций и других структур данных;
+ `count()` возвращает количество элементов;
+ `anyMatch()` возвращает `true`, если условие выполняется хотя бы для одного элемента;
+ `noneMatch()` возвращает `true`, если условие не выполняется ни для одного элемента;
+ `allMatch()` возвращает `true`, если условие выполняется для всех элементов;
+ `min()` возвращает минимальный элемент, используя в качестве условия `Comparator`;
+ `max()` возвращает максимальный элемент, используя в качестве условия `Comparator`;
+ `forEach()` применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);
+ `forEachOrdered()` применяет функцию к каждому объекту с сохранением порядка элементов;
+ `toArray()` возвращает массив значений;
+ `reduce()`позволяет выполнять агрегатные функции и возвращать один результат. Результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.

Для числовых стримов дополнительно доступны:
+ `sum()` возвращает сумму всех чисел;
+ `average()` возвращает среднее арифметическое всех чисел.

Терминальный метод можно вызвать только один раз.
Все оконечные методы возвращают `Optional` - оболочка ответа
(этот специальный тип ввели чтобы не возвращать null)
+ [Вопрос#6  К оглавлению](#Stream-API-и-Лямбда)

## Расскажите о параллельной обработке в Java 8.
Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта `Stream` метод `parallel()`. А обратный метод - `sequential()`. Кроме того, можно также использовать блокирующий метод `parallelStream()` интерфейса `Collection` для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.
Работает на фреймворке fork/join.
+ [Вопрос#7  К оглавлению](#Stream-API-и-Лямбда)

## Что такое IntStream и DoubleStream?
В Java 8 создание Stream-ов примитивов напрямую невозможно, из-за дженериков. Но разработчики сделали 3 Stream-а примитивов : `IntStream`, `LongStream`, `DoubleStream`. Работает быстрее, чем стрим с классами-обертками.
Поддерживают дополнительные терминальный методы `sum()`, `average()`, `mapToObj()`
+ [Вопрос#8  К оглавлению](#Stream-API-и-Лямбда)

## Для чего нужен метод `collect()` в стримах?
Метод `collect()` является конечной операцией, которая используется для представление результата в виде коллекции или какой-либо другой структуры данных.

`collect()` принимает на вход `Collector<Тип_источника, Тип_аккумулятора, Тип_результата>`, который содержит четыре этапа: _supplier_ - инициализация аккумулятора, _accumulator_ - обработка каждого элемента, _combiner_ - соединение двух аккумуляторов при параллельном выполнении, _[finisher]_ - необязательный метод последней обработки аккумулятора. В Java 8 в классе `Collectors` реализовано несколько распространённых коллекторов:

+ `toList()`, `toCollection()`, `toSet()` - представляют стрим в виде списка, коллекции или множества;
+ `toConcurrentMap()`, `toMap()` - позволяют преобразовать стрим в `Map`;
+ `averagingInt()`, `averagingDouble()`, `averagingLong()` - возвращают среднее значение;
+ `summingInt()`, `summingDouble()`, `summingLong()` - возвращает сумму;
+ `summarizingInt()`, `summarizingDouble()`, `summarizingLong()` - возвращают `SummaryStatistics` с разными агрегатными значениями;
+ `partitioningBy()` - разделяет коллекцию на две части по соответствию условию и возвращает их как `Map<Boolean, List>`;
+ `groupingBy()` - разделяет коллекцию на несколько частей и возвращает `Map<N, List<T>>`;
+ `mapping()` - дополнительные преобразования значений для сложных `Collector`-ов.

Так же существует возможность создания собственного коллектора через `Collector.of()`:

```java
Collector<String, List<String>, List<String>> toList = Collector.of(
    ArrayList::new,
    List::add,
    (l1, l2) -> { l1.addAll(l2); return l1; }
);
```
+ [Вопрос#9  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах применяются методы `forEach()` и `forEachOrdered()`?
+ `forEach()` применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется;
+ `forEachOrdered()` применяет функцию к каждому объекту стрима с сохранением порядка элементов.

+ [Вопрос#10  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах предназначены методы `map()` и `mapToInt()`, `mapToDouble()`, `mapToLong()`?
Метод `map()` является промежуточной операцией, которая заданным образом преобразует каждый элемент стрима.

`mapToInt()`, `mapToDouble()`, `mapToLong()` - аналоги `map()`, возвращающие соответствующий числовой стрим (то есть стрим из числовых примитивов):

```java
Stream
    .of("12", "22", "4", "444", "123")
    .mapToInt(Integer::parseInt)
    .toArray(); //[12, 22, 4, 444, 123]
```
+ [Вопрос#11  К оглавлению](#Stream-API-и-Лямбда)

## Какова цель метода `filter()` в стримах?
Метод `filter()` является промежуточной операцией принимающей предикат, который фильтрует все элементы, возвращая только те, что соответствуют условию.
+ [Вопрос#12  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах предназначен метод `limit()`?
Метод `limit()` является промежуточной операцией, которая позволяет ограничить выборку определенным количеством первых элементов.
+ [Вопрос#13  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах предназначен метод `sorted()`?
Метод `sorted()` является промежуточной операцией, которая позволяет сортировать значения либо в натуральном порядке, либо задавая `Comparator`.

Порядок элементов в исходной коллекции остается нетронутым - `sorted()` всего лишь создает его отсортированное представление.
+ [Вопрос#14  К оглавлению](#Stream-API-и-Лямбда)

## Для чего в стримах предназначены методы `flatMap()`, `flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()`?
Метод `flatMap()` похож на map, но может создавать из одного элемента несколько. Таким образом, каждый объект будет преобразован в ноль, один или несколько других объектов, поддерживаемых потоком.  Наиболее очевидный способ применения этой операции — преобразование элементов контейнера при помощи функций, которые возвращают контейнеры.
```java
Stream
    .of("H e l l o", "w o r l d !")
    .flatMap((p) -> Arrays.stream(p.split(" ")))
    .toArray(String[]::new);//["H", "e", "l", "l", "o", "w", "o", "r", "l", "d", "!"]
```
`flatMapToInt()`, `flatMapToDouble()`, `flatMapToLong()` - это аналоги `flatMap()`, возвращающие соответствующий числовой стрим.
+ [Вопрос#15  К оглавлению](#Stream-API-и-Лямбда)

## В чем разница методов `peek()` и `forEach()`?
+ __peek__ - Возвращает тот же стрим, но применяет функцию к каждому элементу стрима, промежуточный
+ __forEach__ - Применяет функцию к каждому объекту стрима, терминальный

+ [Вопрос#16  К оглавлению](#Stream-API-и-Лямбда)

## В чем разница методов `map()` и `flatMap()`?
И `map` и `flatMap` могут быть применены к стриму `Stream<T>` и оба возвращают стрим `Stream<R>`. 
Можно парсануть to Int:     String.mapToInt(Integer.parseInt())

Разница заключается в том, что операция `map` создает одно выходное значение для каждого входного значения, тогда как операция 
`flatMap` создает произвольное число(ноль или больше) значений для каждого входного значения.
+ [Вопрос#17  К оглавлению](#Stream-API-и-Лямбда)

## В чем разница методов `range()` и `rangeClosed()`?
+ int sum = IntStream.range(1, 10) диапазон не вкл.конечное значение, т.е. до 10-1
  .sum();//returns 45
+ int sum = IntStream.rangeClosed(1, 10)          включительно 10.
  .sum();//returns 55
Разница в том, что конец range () является эксклюзивным, в то время как он включен в rangeClosed () .

+ [Вопрос#18  К оглавлению](#Stream-API-и-Лямбда)

## Можно ли конкатенировать Стримы? Если да то каким методом? Можно ли получить пустой стрим?
Статический метод `concat()` объединяет элементы двух потоков, возвращая объединенный поток:
Можно получить пустой стрим `Stream.empty()` зачем, при выходе из параметра потока, избежать искл.
+ [Вопрос#19  К оглавлению](#Stream-API-и-Лямбда)

## Отличие Стримов от Итераторов?
+ 1 Разные задачи. Задачи Итератора - обойти коллекцию. Задача Стрима - обойти коллекцию.
+ 2 Стримы выигрывают при работе в парралельном режиме.
+ 3 Разные уровни абстракции и Стримов гораздо выше.
+ 4 Через итератор больше кода и стримы гораздо сложней по логике исполнения.

+ [Вопрос#20  К оглавлению](#Stream-API-и-Лямбда)

## Отличие Стримов от Коллекций?
+ 1 Принцип работы. Коллекции работают с элементами по отдельности, а Стримы с потоком в целом.
+ 2 В Коллекциях можно добавлять, удалять, вставлять элементы в середину, а в Потоках - нет.
+ 3 Разные уровни абстракции. В Потоке элементы от нас скрыты.
+ 4 Логическая задумка Коллекций. Например Сет и ЛинкетСет.
+ 5 Для Стримов возможность сразу работать со всеми данными.

+ [Вопрос#21  К оглавлению](#Stream-API-и-Лямбда)

## На какие группы можно поделить Стримы. Какие бывают Стримы?
+ __1 Конвеерные и Терминальные(Конечные и бесконечные).__
Конвейерные — возвращают другой stream, то есть работают как builder.
Терминальные — возвращают другой объект, такой как коллекция, примитивы, объекты, Optional и т.д.
+ __2 Последовательные и парралельные.__
Стримы бывают последовательными `sequential` и параллельными `parallel`. Последовательные выполняются только в текущем потоке, а вот параллельные используют общий пул `ForkJoinPool.commonPool()`. При этом элементы разбиваются (если это возможно) на несколько групп и обрабатываются в каждом потоке отдельно. Затем на нужном этапе группы объединяются в одну для предоставления конечного результата.
Чтобы получить параллельный стрим, нужно либо вызвать метод `parallelStream()` вместо `stream()`, либо превратить обычный стрим в параллельный, вызвав промежуточный оператор `parallel`.
С помощью, методов `parallel` и `sequential` можно определять какие операции могут быть параллельными, а какие только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот, то есть:
```java
collection.stream().
peek(...). // операция последовательна
parallel().
map(...). // операция может выполняться параллельно,
sequential().
reduce(...) // операция снова последовательна 
```
!!! Внимание: крайне не рекомендуется использовать параллельные стримы для сколько-нибудь долгих операций (получение данных из базы, сетевых соединений), так как все параллельные стримы работают c одним пулом `fork/join` и такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за того отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты.
+ __3 Объектные и примитивные.__
Кроме объектных стримов Stream<T>, существуют специальные стримы для примитивных типов:
  - IntStream для int,
  - LongStream для long,
  - DoubleStream для double.

+ [Вопрос#22  К оглавлению](#Stream-API-и-Лямбда)

## Что такое ленивая инициализация стрима?
+ 1.Никаких вычислений в стриме не производится, пока не будет вызвана терминальная операция
+ 2.Промежуточные и терминальные, сколько бы мы не сделали промежуточных, пока не выполним терминальный, то никаких данных мы не получим, вызываем терминальным, далее создание стримов.

+ [Вопрос#23  К оглавлению](#Stream-API-и-Лямбда)

## Расскажите о параллельной обработке в Java 8.
Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке процессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют общий `ForkJoinPool` доступный через статический `ForkJoinPool.commonPool()` метод. При этом, если окружение не является многоядерным, то поток будет выполняться как последовательный. Фактически применение параллельных стримов сводится к тому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются конечные операции.

Для создания параллельного потока из коллекции можно также использовать метод `parallelStream()` интерфейса `Collection`. 

Чтобы сделать обычный последовательный стрим параллельным, надо вызвать у объекта `Stream` метод `parallel()`. Метод `isParallel()` позволяет узнать является ли стрим параллельным. 

С помощью, методов `parallel()` и `sequential()` можно определять какие операции могут быть параллельными, а какие только последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот: 
```java
collection
.stream()
.peek(...) // операция последовательна
.parallel()
.map(...) // операция может выполняться параллельно,
.sequential()
.reduce(...) // операция снова последовательна 
```
Как правило, элементы передаются в стрим в том же порядке, в котором они определены в источнике данных. При работе с параллельными стримами система сохраняет порядок следования элементов. Исключение составляет метод `forEach()`, который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод `forEachOrdered()`.

Критерии, которые могут повлиять на производительность в параллельных стримах:

+ Размер данных - чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.
+ Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.
+ Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из `ArrayList` легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа `LinkedList` - не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.
+ Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов.
+ Крайне не рекомендуется использовать параллельные стримы для скольких-нибудь долгих операций (например, сетевых соединений), так как все параллельные стримы работают c одним ForkJoinPool, то такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты;
+ Сохранение порядка в параллельных стримах увеличивает издержки при выполнении и если порядок не важен, то имеется возможность отключить его сохранение и тем самым увеличить производительность, использовав промежуточную операцию `unordered()`:

```java
collection.parallelStream()
    .sorted()
    .unordered()
    .collect(Collectors.toList());
```
+ [Вопрос#24  К оглавлению](#Stream-API-и-Лямбда)

## Что такое `StringJoiner`?
Класс `StringJoiner` используется, чтобы создать последовательность строк, разделенных разделителем с возможностью присоединить к полученной строке префикс и суффикс:

```java
StringJoiner joiner = new StringJoiner(".", "prefix-", "-suffix");
for (String s : "Hello the brave world".split(" ")) {
    joiner.add(s);
}
System.out.println(joiner); //prefix-Hello.the.brave.world-suffix
```
+ [Вопрос#25  К оглавлению](#Stream-API-и-Лямбда)

## Что такое `Optional`?
Опциональное значение `Optional` — это контейнер для объекта, который может содержать или не содержать значение `null`. Такая обёртка является удобным средством предотвращения `NullPointerException`, т.к.
имеет некоторые функции высшего порядка, избавляющие от добавления повторяющихся `if null/notNull` проверок:

```java
Optional<String> optional = Optional.of("hello");

optional.isPresent(); // true
optional.ifPresent(s -> System.out.println(s.length())); // 5
optional.get(); // "hello"
optional.orElse("ops..."); // "hello"
```
Замена null-значений, благодаря чему должна повышаться безопасность и читаемость кода.
`findFirst, findAny()`
При написании кода разработчик часто не может знать — будет ли существовать нужный объект на момент исполнения программы или нет, и в таких случаях приходится делать проверки на null. Если такими проверками пренебречь, то рано или поздно (обычно рано) Ваша программа рухнет с NullPointerException. Тесно связан со стримами и лямбдами.
```java
Optional<User> user = Optional.of(repository.findById(userId));
.isPresent() Этот метод возвращает ответ, существует ли искомый объект или нет, в виде Boolean:
.ifPresent()Метод позволяет выполнить какое-то действие, если объект не пустой.
```
+ [Вопрос#26  К оглавлению](#Stream-API-и-Лямбда)

## Как вывести на экран 10 случайных чисел, используя `forEach()`?
```java
(new Random())
    .ints()
    .limit(10)
    .forEach(System.out::println);
```
+ [Вопрос#27  К оглавлению](#Stream-API-и-Лямбда)

## Как можно вывести на экран уникальные квадраты чисел используя метод `map()`?
```java
Stream
    .of(1, 2, 3, 2, 1)
    .map(s -> s * s)
    .distinct()
    .forEach(System.out::println);
```
+ [Вопрос#28  К оглавлению](#Stream-API-и-Лямбда)

## Как вывести на экран количество пустых строк с помощью метода `filter()`?
```java
System.out.println(
    Stream
        .of("Hello", "", ", ", "world", "!")
        .filter(String::isEmpty)
        .count());
```
+ [Вопрос#29  К оглавлению](#Stream-API-и-Лямбда)

## Как вывести на экран 10 случайных чисел в порядке возрастания?
```java
(new Random())
    .ints()
    .limit(10)
    .sorted()
    .forEach(System.out::println);
```
+ [Вопрос#30  К оглавлению](#Stream-API-и-Лямбда)

## Как найти максимальное число в наборе?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt(a -> a)
    .max()
    .getAsInt(); //55
```
+ [Вопрос#31  К оглавлению](#Stream-API-и-Лямбда)

## Как найти минимальное число в наборе?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt(a -> a)
    .min()
    .getAsInt(); //2
```
+ [Вопрос#32  К оглавлению](#Stream-API-и-Лямбда)

## Как получить сумму всех чисел в наборе?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt()
    .sum(); //69
```
+ [Вопрос#33  К оглавлению](#Stream-API-и-Лямбда)

## Как получить среднее значение всех чисел?
```java
Stream
    .of(5, 3, 4, 55, 2)
    .mapToInt(a -> a)
    .average()
    .getAsDouble(); //13.8
```
+ [Вопрос#34  К оглавлению](#Stream-API-и-Лямбда)



## Лямбда
## Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?
__Лямбда__ представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.

Основу лямбда-выражения составляет _лямбда-оператор_, который представляет стрелку `->`. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

```java
interface Operationable {
    int calculate(int x, int y);
}

public static void main(String[] args) {
    Operationable operation = (x, y) -> x + y;     
    int result = operation.calculate(10, 20);
    System.out.println(result); //30
}
```

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.

+ _Отложенное выполнение (deferred execution) лямбда-выражения_- определяется один раз в одном месте программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.

+ _Параметры лямбда-выражения_ должны соответствовать по типу параметрам метода функционального интерфейса:

```java
operation = (int x, int y) -> x + y;
//При написании самого лямбда-выражения тип параметров разрешается не указывать:
(x, y) -> x + y;
//Если метод не принимает никаких параметров, то пишутся пустые скобки, например,
() -> 30 + 20;
//Если метод принимает только один параметр, то скобки можно опустить:
n -> n * n;
```

+ _Конечные лямбда-выражения_ не обязаны возвращать какое-либо значение.

```java
interface Printable {
    void print(String s);
}
 
public static void main(String[] args) {
    Printable printer = s -> System.out.println(s);
    printer.print("Hello, world");
}
```

+ _Блочные лямбда-выражения_ обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции `if`, `switch`, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор `return`:

```java
Operationable operation = (int x, int y) -> {       
    if (y == 0) {
        return 0;
    }
    else {
        return x / y;
    }
};
```

+ _Передача лямбда-выражения в качестве параметра метода_:

```java
interface Condition {
    boolean isAppropriate(int n);
}

private static int sum(int[] numbers, Condition condition) {
    int result = 0;
    for (int i : numbers) {
        if (condition.isAppropriate(i)) {
            result += i;
        }
    }
    return result;
}

public static void main(String[] args) {
    System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -> n != 0));
} 
```
+ [Вопрос#1  К оглавлению](#Stream-API-и-Лямбда)

## К каким переменным есть доступ у лямбда-выражений?
Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно ссылаться на:

+ неизменяемые (_effectively final_ - не обязательно помеченные как `final`) локальные переменные;
Либо явно финализирована, либо не переписана.
```java
final int bonus = 10;
IntUnaryOperator bonusAdder = (x) -> x + bonus;

Для обхода этого ограничения используют массив единичной длины
int[] counter = new int[1];
IntSupplier sequence1 = () -> counter[0]++;
```
+ поля класса;
+ статические переменные.
+ к параметрам лямбда-выражения, а также свободно объявлять и использовать внутри тела лямбда-выражения любые переменные ???

!!! К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.
+ [Вопрос#2  К оглавлению](#Stream-API-и-Лямбда)

## Как отсортировать список строк с помощью лямбда-выражения?
```java
public static List<String> sort(List<String> list){
    Collections.sort(list, (a, b) -> a.compareTo(b));
    return list;
}
```
+ [Вопрос#3  К оглавлению](#Stream-API-и-Лямбда)

## Что такое «ссылка на метод»? Какие виды ссылок на методы вы знаете?
Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом __method reference (ссылка на метод)__ для непосредственной передачи этого метода. Такая ссылка передается в виде:

+ `ContainingClass::staticMethodName` - Ссылка на статический метод;
+ `containingObject::instanceMethodName` - Ссылка на нестатический метод конкретного объекта;
+ `ContainingType::methodName` - Ссылка на нестатический метод любого объекта конкретного типа;
+ `ClassName::new` - Ссылка на конструктор;

Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.

```java
private interface Measurable {
    public int length(String string);
}

public static void main(String[] args) {
    Measurable a = String::length;
    System.out.println(a.length("abc"));
}
```

Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. Кроме того, они предоставляют компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.
+ [Вопрос#4  К оглавлению](#Stream-API-и-Лямбда)


## Объясните выражение `System.out::println`.
Данное выражение иллюстрирует механизм _instance method reference_: передачи ссылки на метод `println()` статического поля `out` класса `System`.
+ [Вопрос#5  К оглавлению](#Stream-API-и-Лямбда)

## Любой анонимный класс можно заменить на лямбду?
+ Ответ - нет. 
Вы можете создать анонимный класс для не финальных классов и интерфейсов. Не то же самое для лямбда-выражений. Они могут использоваться только там, где ожидается интерфейс SAM, то есть интерфейсы только с одним абстрактным методом (до Java 8 каждый интерфейсный метод был абстрактным, но поскольку интерфейсы Java 8 также могут иметь стандартные и статические методы, которые не являются абстрактными, поскольку они имеют реализацию 

**(!)Только анонимные классы, которые являются реализациями интерфейса SAM (например, Runnable, ActionListener, Comparator, Predicate), могут быть заменены лямбда-выражением. DefaultConsumer не может быть лямбда-мишенью, потому что даже не является интерфейсом.
+ [Вопрос#6  К оглавлению](#Stream-API-и-Лямбда)

## Связь лямбда с анонимным классом?
+ __Заменяют анонимные классы, синтаксический сахар, не нужно переопределять методы__.
+ __Что такое «анонимные классы»? Где они применяются?__
- Это вложенный локальный(inner class) класс, без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. 
- Нет конструктора, только тело
- Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический, либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.
Анонимные классы имеют несколько ограничений:
•	Их использование разрешено только в одном месте программы - месте его создания;
•	Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
•	Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.
Анонимные классы обычно применяются для:
•	создания объекта функции (function object), например, реализация интерфейса Comparator;
•	создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
•	в статическом методе генерации;
•	инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.
+ Анонимные классы выполняют две функции, 
1.	Описание класса

2.	Создание экземпляра(объекта) этого класса

+ __Как создать экземпляр анонимного класса (подробно)?__ 
1. Создаем локальный класс без имени, 
2. Можно объявить такой класс, который может расширить (extends) другой класс или реализовать (implements) интерфейс. Объявление такого класса выполняется одновременно с созданием его объекта посредством оператора new и экземпляр некоторого класса.
3. Не должно быть конструктора, 
```java
UnaryOperator<Integer> myOperatorWithoutName = new UnaryOperator<Integer>() {
        @Override
        public Integer apply(Integer x) {
            return x * x;
        }
    };
```
Любые аргументы, которые вы укажете в круглых скобках, стоящих за именем родительского класса в определении анонимного класса, неявно передаются конструктору родительского класса.
+ __Где применяются анонимные классы?__ 
1) Чаще всего анонимные классы применяются для расширения родительских классов простыми классами, которые не требуют аргументов конструктора, поэтому скобки в определении анонимного класса зачастую пусты.
2) Чтобы не создавать отдельный класс, если нужно встроить некоторую логику в существующий класс или связать с др.классом.
3) При обращении создается единожды, Анонимный внутренний класс может быть полезен при создании экземпляра объекта с определенными "extras", такими как переопределяющие методы, без необходимости фактически подклассировать класс.

Когда мы реализуем один единственный метод интерфейса, то нет необходимости его указывать в реализации,  
Я обычно использую его как ярлык для подключения прослушивателя событий:
```java
public void addActionListener(ActionListener listener) {listeners.add(listener)};

    button.addActionListener(new ActionListener() {
       @Override
       public void actionPerformed(ActionEvent e) { //описание структуры анонимного класса
        // do something
       }
    });
```
1.	Нет необходимости явно указывать:
- сам интерфейс, потому что на этапе компиляции он видит заголовок в параметрах метода принимающего значения, 
т.е.:
```java
public void addActionListener(ActionListener listener) {
```
- имя самого метода (поскольку это ФИ и у него единственный метод,) понятно что речь идет только о нем, 
- возвращаемое значение,
- модификаторы доступа,
2.	Чтобы разделить набор параметров, которые мы указываем в круглых скобочках и тело метода реализующего метод интерфейса, после указания аргументов, в скобочках, мы указываем в виде стрелочки, ->
3.	То, во что вырождается анонимный класс называется Лямбда-выражение
Если у метода, в интерфейсе, есть параметры, то типы этих параметров можно не писать, т.к. компилятор узнает эти типы заглянув в заголовок в интерфейсе, а об интерфейсе он узнает из метода public void addActionListener(ActionListener listener) {
4.	Если у метода интерфейса единственный параметр, то можно опустить и круглые скобки, но если их нет совсем, то они должны быть пустые.
5.	Если тело состоит из единственного оператора, фигурные скобки можно опустить, ; (точка с запятой не записывается сразу после тела,
6.	Если единственный оператор это return то он тоже опускается.

+ [Вопрос#7  К оглавлению](#Stream-API-и-Лямбда)

## ССЫЛКИ НА ДОПОЛНИТЕЛЬНУЮ ИНФУ
### ---Info---
+ [Interface Stream<T>-->]( https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html )

### ---Video---
### ---Lessons---
+ [Шпаргалка Java программиста 4. Java Stream API-->]( https://habr.com/ru/company/luxoft/blog/270383/ )
+ [Stream API: универсальная промежуточная операция-->]( https://habr.com/ru/post/262139/ )
+ [Stream API-->]( https://javarush.ru/groups/posts/2203-stream-api )
+ [Полное руководство по Java 8 Stream API в картинках и примерах-->]( https://annimon.com/article/2778 )
+ [Полное руководство по Java Stream API-->]( https://hr-vector.com/java/stream-api )
+ [Введение в Stream API-->]( https://metanit.com/java/tutorial/10.1.php )

+ [Stream API и лямбда выражения в Java.-->]( https://java-master.com/stream-and-lambda-in-java/ )
+ [Использование generic wildcards для повышения удобства Java API-->]( https://habr.com/ru/post/207360/ )
+ [Используйте Stream API проще (или не используйте вообще)-->]( https://habr.com/ru/post/337350/ )
+ __Optional Class__
+ [Объект в футляре или Optional в Java 8 и Java 9. Часть 1: «Как без него прожить?»(2018)-->]( https://habr.com/ru/post/347480/ )
+ [Объект в футляре или Optional в Java 8 и Java 9. Часть 2: «Как это делается в Java 8»(2018)-->]( https://habr.com/ru/post/347576/ )
+ [Объект в футляре или Optional в Java 8 и Java 9. Часть 3: «Что добавилось в Java 9»(2018)-->]( https://habr.com/ru/post/347748/ )
+ [Объект в футляре или Optional в Java 8 и Java 9. Часть 4: «Как футляром с двойным дном закрыть дыру в Java“(2018)-->]( https://habr.com/ru/post/347836/ )
+ [Объект в футляре или Optional в Java 8 и Java 9: Часть 5: Недосказанное и постер в подарок(2018)-->]( https://habr.com/ru/post/350904/ )
+ [Optional: Кот Шрёдингера в Java 8(2018)-->]( https://habr.com/ru/post/346782/ )
+ [Разбираем класс java.util.Optional-->]( https://megahub.me/post/16 )
+ [Разбираемся с Optional в java-->]( https://java-master.com/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-optional-%D0%B2-java/ )
### ---Forum---
+ [Название-->]( Ссылка )
+ [Название-->]( Ссылка )






